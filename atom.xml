<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yqzzxlj</title>
  
  <subtitle>hello world</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-03-19T06:12:57.445Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yqzzxlj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python知识点复习整理</title>
    <link href="http://yoursite.com/2021/03/10/python%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2021/03/10/python%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/</id>
    <published>2021-03-10T10:46:53.000Z</published>
    <updated>2021-03-19T06:12:57.445Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-垃圾回收机制"><a href="#1-垃圾回收机制" class="headerlink" title="1. 垃圾回收机制"></a>1. 垃圾回收机制</h3><h4 id="1-1-对象共用"><a href="#1-1-对象共用" class="headerlink" title="1.1 对象共用"></a>1.1 对象共用</h4><ul><li>小整数[-5, 257)和单个字符，共用对象，常驻内存</li><li>单个单词不可修改，默认开启intern机制，共用对象，引用计数为0时销毁</li><li>字符串（含有空格），大整数，不可修改，没开启intern机制，不共用对象，引用计数为0时销毁</li></ul><h4 id="1-2-垃圾回收"><a href="#1-2-垃圾回收" class="headerlink" title="1.2 垃圾回收"></a>1.2 垃圾回收</h4><ol><li><p>引用计数</p><p>python里每一个东西都是对象，它们的核心就是一个结构体：<code>PyObject</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> struct_object &#123;</span><br><span class="line">    <span class="keyword">int</span> ob_refcnt;</span><br><span class="line">    struct_typeobject *ob_type;</span><br><span class="line">&#125; PyObject;</span><br></pre></td></tr></table></figure><ul><li>优点：简单、实时性（一旦没有引用内存直接释放，将处理回收内存的时间分摊到平时）</li><li>缺点：维护引用计数耗费资源，循环引用问题（容器对象）</li></ul></li><li><p>标记-清除（对活动对象打上标记，清除没有标记的对象）</p><ul><li>零代链表：将所有对象放到一个双向链表（方便插入删除）中，这些对象称为零代。</li><li>循环遍历链表，如果被本链表内的对象引用，则自身的被引用数-1，如果被引用数为0，则出发引用计数回收条件，被回收</li><li>未被回收的对象升级为1代</li><li>当一代列表越来越多，触发gc阈值，对以及链表进行标记清除操作，将剩下活跃对象升级为2代</li></ul></li></ol><p>除了到达阈值外，还可以手动调用gc.collect()或者等python虚拟机退出</p><h3 id="2-迭代器与生成器"><a href="#2-迭代器与生成器" class="headerlink" title="2. 迭代器与生成器"></a>2. 迭代器与生成器</h3><p>当需要扫描内存中放不下的数据集时，我们需要一种惰性获取数据项的方式，即按需要一次获取一个数据项。</p><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li>迭代器用于从集合中取出数据</li><li>生成器用于生成数据</li></ul><h4 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h4><p>迭代器有基本的next()方法和iter()方法</p><ul><li>next():返回后续元素，没有后续元素时抛出异常。</li><li>iter():返回一个迭代器对象，可以通过对其调用next()方法返回下一个</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="built_in">next</span>(it))   <span class="comment"># 输出迭代器的下一个元素</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line"><span class="number">2</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>把一个类作为迭代器需要在类中实现两个方法 <strong><strong>iter</strong></strong>()和<strong><strong>next</strong></strong>()方法</p><p>StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况</p><h4 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h4><p>使用了 yield 的函数被称为生成器（generator）。生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span>(<span class="params">n</span>):</span> <span class="comment"># 生成器函数 - 斐波那契</span></span><br><span class="line">    a, b, counter = <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> (counter &gt; n): </span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        counter += <span class="number">1</span></span><br><span class="line">f = fibonacci(<span class="number">10</span>) <span class="comment"># f 是一个迭代器，由生成器返回生成</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(f), end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        sys.exit()</span><br></pre></td></tr></table></figure><h3 id="3-装饰器"><a href="#3-装饰器" class="headerlink" title="3. 装饰器"></a>3. 装饰器</h3><ul><li>增强函数功能的函数。（函数嵌套（内层+外层），返回函数（外层返回内层，内层添加功能+执行函数），函数作为参数（调用外层函数））</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_name</span>(<span class="params">f</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> can_run:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;Function will not run&quot;</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br><span class="line"> </span><br><span class="line"><span class="meta">@decorator_name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>():</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="string">&quot;Function is running&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>装饰器可以传参，也可以不传参</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">text</span>):</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">          <span class="keyword">if</span> <span class="keyword">not</span> can_run:</span><br><span class="line">              <span class="keyword">return</span> <span class="string">&quot;Function will not run&quot;</span></span><br><span class="line">          <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">      <span class="keyword">return</span> wrapper</span><br><span class="line"> <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure><ul><li><p>用途</p><ul><li>引用日志</li><li>函数执行时间计算</li><li>执行函数之前的预备处理</li><li>执行函数之后的清理</li><li>权限校检</li><li>缓存</li></ul></li><li><p>内置装饰器</p><ul><li><p>@property 将方法作为属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span>(<span class="params">self</span>):</span> ...</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">x</span>(<span class="params">self</span>):</span> ...</span><br><span class="line">x = <span class="built_in">property</span>(x)</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p>@staticmethod：静态方法，不需要实例化，直接通过类名就可以实现调用。不需要表示自身对象的self和自身类的cls参数(这两个参数都不需要添加)</p></li><li><p>@classmethod：类方法，不需要实例化，直接通过类名就可以实现调用。不需要self参数，但第一个参数需要是表示自身类的cls参数。</p></li></ul><h3 id="4-全局解释器锁（Global-Interpreter-Lock，-GIL）"><a href="#4-全局解释器锁（Global-Interpreter-Lock，-GIL）" class="headerlink" title="4. 全局解释器锁（Global Interpreter Lock， GIL）"></a>4. 全局解释器锁（Global Interpreter Lock， GIL）</h3><p>python代码执行有Python虚拟机控制。在解释器中只有一个线程在执行，即任意时刻只有一个线程在解释器中运行。对Python虚拟机的访问有全局解释器锁来控制。</p><p>在多线程环境中，Python虚拟机按照如下方式运行：</p><ol><li>设置GIL</li><li>切换到一个线程去运行</li><li>运行：指定数量的字节码指令或线程主动让出控制</li><li>线程睡眠</li><li>解锁GIL</li><li>重复上述步骤</li></ol><ul><li>因为GIL的存在，只有IO Bound场景下得多线程会得到较好的性能</li><li>如果对并行计算性能较高的程序可以考虑把核心部分也成C模块，或者索性用其他语言实现</li><li>GIL在较长一段时间内将会继续存在，但是会不断对其进行改进</li><li>任何Python线程执行前，必须先获得GIL锁，然后，每执行n条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。</li></ul><h3 id="5-内存管理机制"><a href="#5-内存管理机制" class="headerlink" title="5. 内存管理机制"></a>5. 内存管理机制</h3><ol><li>0层是C的malloc、free管理内存</li><li>1层是python的内存分配</li><li>2层是对象的内存分配（内存池）</li><li>3层是对象缓冲池</li></ol><p>python分大内存和小内存，对象小于256k时由该层分配，大于时由malloc进行分配</p><h3 id="6-对象引用"><a href="#6-对象引用" class="headerlink" title="6. 对象引用"></a>6. 对象引用</h3><ol><li>变量不是盒子，应该把变量视作便利贴</li><li>标识（id)，相等性(is, ==)和别名(id相同)<ol><li>is运算符比==速度快，因为不能重载，所以python不用寻找并调用特殊方法，直接比较两个整数id。</li><li>元组的相对不可变性。</li></ol></li><li>默认作浅复制。<ol><li>构造方法或[:]作的是浅复制（即复制了最外层容器，副本中的元素是源容器中元素的引用。</li><li>深复制用deepcopy，浅复制copy</li></ol></li><li>函数的参数作为引用时<ol><li>不要使用可变类型作为参数的默认值，通常使用None作为接受可变值参数的默认值。没有初始化该参数的类实例会共享该初始值。根源问题是，默认值在定义函数时计算，因此默认值变成了函数对象的属性。因此如果默认值是可变对象，而且修改了它的值，那么后续的函数调用都会受到影响。</li><li>防御可变参数（在处理过程中谨慎修改可变参数，可创建副本）</li></ol></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span>(<span class="params">l = []</span>):</span></span><br><span class="line">    l.append(<span class="number">1</span>)</span><br><span class="line">    print(l)</span><br><span class="line"></span><br><span class="line">outer() <span class="comment"># [1]</span></span><br><span class="line">outer() <span class="comment"># [1, 1]</span></span><br><span class="line">outer() <span class="comment"># [1, 1, 1]</span></span><br></pre></td></tr></table></figure><h3 id="7-方法解析顺序（MRO，-Method-Resolution-Order）多继承查找规则"><a href="#7-方法解析顺序（MRO，-Method-Resolution-Order）多继承查找规则" class="headerlink" title="7. 方法解析顺序（MRO， Method Resolution Order）多继承查找规则"></a>7. 方法解析顺序（MRO， Method Resolution Order）多继承查找规则</h3><p>C3算法最早提出用于Lisp，应用到Python中是为了解决原来深度优先搜索不满足本地优先级、单调性的问题。</p><p>本地优先级：声明父类的顺序C(A, B)，访问父类时应该分局声明顺序优先查找A类然后是B类</p><p>按顺序找到哪个用哪个</p><p>单调性：如果在C的解析顺序中呢，A在B前面，那么C的所有子类都必须是这个顺序</p><p>子类永远在父类前面</p><p>如果有多个父类，会根据它们在列表中的顺序被检查</p><p>如果对下一个类存在两个合法的选择，选择第一个父类</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mro(Child(Base1，Base2)) = [ Child ] + merge( mro(Base1), mro(Base2),  [ Base1, Base2] )</span><br><span class="line">（其中Child继承自Base1, Base2）</span><br></pre></td></tr></table></figure><h3 id="8-变量作用域"><a href="#8-变量作用域" class="headerlink" title="8. 变量作用域"></a>8. 变量作用域</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">L &#x3D; Local     局部作用域</span><br><span class="line">E &#x3D; Enclosing 嵌套作用域</span><br><span class="line">N &#x3D; nonlocal  只作用于嵌套作用域，而且只是作用在函数里面</span><br><span class="line">G &#x3D; global    全局作用域</span><br><span class="line">B &#x3D; Built-in  内置作用域</span><br></pre></td></tr></table></figure><p>python引用变量的顺序： 当前作用域局部变量-&gt;外层作用域变量-&gt;当前模块中的全局变量-&gt;python内置变量.</p><h3 id="9-一切皆对象"><a href="#9-一切皆对象" class="headerlink" title="9. 一切皆对象"></a>9. 一切皆对象</h3><h4 id="函数和类也是对象"><a href="#函数和类也是对象" class="headerlink" title="函数和类也是对象"></a>函数和类也是对象</h4><ol><li>赋值给一个变量</li><li>可以添加到集合对象中</li><li>可以作为参数传递给函数</li><li>可以作为函数的返回值</li></ol><h4 id="Type、Object、-Class"><a href="#Type、Object、-Class" class="headerlink" title="Type、Object、 Class"></a>Type、Object、 Class</h4><ul><li>所有内置类都是由type创建出来的对象（包括type 和Object）</li><li>object是最顶层基类（type继承自Object）</li></ul><h4 id="对象的特征"><a href="#对象的特征" class="headerlink" title="对象的特征"></a>对象的特征</h4><ul><li>身份（id），对象在内存中的地址</li><li>类型（type）实例化对象的类型</li><li>值</li></ul><h3 id="10-元类"><a href="#10-元类" class="headerlink" title="10. 元类"></a>10. 元类</h3><p>元类用来创建类，是类的类。type实际上是一个元类。</p><p>一个类在实例化的时候：</p><ol><li>触发元类中的<code>__call__</code>方法</li><li>通过<code>__new__</code>产生一个空对象</li><li>通过<code>__init__</code>初始化这个对象</li><li>返回</li></ol><h3 id="11-PEP8规范"><a href="#11-PEP8规范" class="headerlink" title="11. PEP8规范"></a>11. PEP8规范</h3><ol><li>缩进4个空格</li><li>行的最大字符数限制为79</li><li>空行<ol><li>顶层函数和类的定义，前后用两个空行隔开</li><li>类里的方法定义用一个空行隔开</li></ol></li><li>imports 导入分组，加入空行</li><li>Comments注释、块注释、行注释</li><li>字符串文档</li><li>命名规则（类名首字母大写，函数名小写）</li></ol><h3 id="12-对python的理解"><a href="#12-对python的理解" class="headerlink" title="12. 对python的理解"></a>12. 对python的理解</h3><ul><li>python是一种解释性语言，与C语言及其衍生语言不同，Python运行之前不需要编译</li><li>python是动态类型的语言，声明变量时，不需要说明变量的类型</li><li>非常适合面向对象编程（OOP），没有访问说明符__x(约定为私有), _x(约定为保护)</li><li>函数是第一类对象（与其他对象具有相同地位，区别于过程），可以被指定给变量，返回函数类型，可以赋值给变量、存储在容器中、作为参数、嵌套、作为返回值。并且当对象实现<strong>call</strong>方法后，也可以被调用。</li><li>Python代码编写快，但是运行慢，Python允许编写C语言的扩展以加快速度</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-垃圾回收机制&quot;&gt;&lt;a href=&quot;#1-垃圾回收机制&quot; class=&quot;headerlink&quot; title=&quot;1. 垃圾回收机制&quot;&gt;&lt;/a&gt;1. 垃圾回收机制&lt;/h3&gt;&lt;h4 id=&quot;1-1-对象共用&quot;&gt;&lt;a href=&quot;#1-1-对象共用&quot; class=&quot;he</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="python3" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/python3/"/>
    
    
    <category term="python3" scheme="http://yoursite.com/tags/python3/"/>
    
    <category term="基础知识" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>教发项目总结</title>
    <link href="http://yoursite.com/2021/03/05/%E6%95%99%E5%8F%91%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2021/03/05/%E6%95%99%E5%8F%91%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%88%E6%9B%B4%E6%96%B0%E4%B8%AD%EF%BC%89/</id>
    <published>2021-03-05T14:55:16.000Z</published>
    <updated>2021-03-19T06:12:57.445Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-介绍一下项目"><a href="#1-介绍一下项目" class="headerlink" title="1. 介绍一下项目"></a>1. 介绍一下项目</h3><h3 id="2-Django"><a href="#2-Django" class="headerlink" title="2. Django"></a>2. Django</h3><h4 id="2-1-对Django的认识"><a href="#2-1-对Django的认识" class="headerlink" title="2.1 对Django的认识"></a>2.1 对Django的认识</h4><ul><li>Django是走大而全的方向，它是出名的自动化管理后台，只需要使用ORM，简单的对象定义，自动生成数据库结构，全功能的管理后台。</li><li>Django内置了一个ORM框架，与其其他模块耦合性较高，理论上必须使用该框架</li><li>Django的最大优势是开发效率高，Django项目达到一定规模后需要重构才能满足性能需求</li><li>适用于中小型网站或大型网站的雏形</li><li>Django模版设计哲学是彻底将代码、样式分离</li></ul><h4 id="2-2-MVC模型和MTV模型"><a href="#2-2-MVC模型和MTV模型" class="headerlink" title="2.2 MVC模型和MTV模型"></a>2.2 MVC模型和MTV模型</h4><ol><li>MVC模型（model，view，controller）</li></ol><p>所谓MVC就是把应用分为模型、控制器、视图三层，以插件式、松耦合的方式放在一起，</p><ul><li>模型负责对象与数据库的映射（ORM）</li><li>视图负责与用户的交互（页面）</li><li>控制器接受用户调入模型和视图完成用户请求。</li></ul><ol start="2"><li>MTV模型（model，template，view）</li></ol><p>Django的MTV模式本质上和MVC是一样的，也是为了各组件间保持松耦合关系，只是定义上有些许不同：</p><ul><li>模型：编写程序应有的功能，负责业务对象与数据库的映射（ORM）</li><li>模版：负责如何把页面（html）展示给用户。</li><li>视图：负责业务逻辑，并在适当时候调用Model和Template。</li></ul><p>除了以上三层之外，还需要一个URL分发器，他的作用是将一个个URL的页面请求分发给不同的View处理，View在调用相应的Model和Template。</p><h4 id="2-3-Django-请求的生命周期"><a href="#2-3-Django-请求的生命周期" class="headerlink" title="2.3 Django 请求的生命周期"></a>2.3 Django 请求的生命周期</h4><p>一般用户通过浏览器发送请求，这个请求访问视图函数，视图函数调用模型，模型去数据库查找数据，然后逐级返回，再填充到模板最后返回给用户。</p><ul><li>wsgi，请求封装后交给web框架（flask、Django）</li><li>中间件，对请求进行校验后在请求中添加相关数据（如csrf、session）</li><li>路由匹配，根据浏览器发送的不同URL去匹配不同的函数</li><li>视图函数，视图函数中进行业务处理，可能涉及到ORM和模板渲染</li><li>中间件，对响应函数进行处理</li><li>wsgi，将响应内容发给浏览器</li></ul><h4 id="2-4-ORM"><a href="#2-4-ORM" class="headerlink" title="2.4 ORM"></a>2.4 ORM</h4><p>ORM是对象关系映射，是MVC框架的一个重要部分。它实现了数据模型与数据的结偶，即数据模型的设计不依赖特定的数据库，通过简单的配置就可以更换数据库，极大地减轻了开发人员的工作量。</p><p>Django 就让开发者 通过 类 和 实例的操作 来对应 数据库 表 和记录的操作。</p><p>select_relect(), 外键查询，通过JOIN语句减少查询次数</p><p>prefetch_relect()，多对多，多对一，缓存，在通过python语句查询，减少查询数据库的次数。</p><h4 id="2-5-中间件"><a href="#2-5-中间件" class="headerlink" title="2.5 中间件"></a>2.5 中间件</h4><p>Django中间件是修改Django request或者response对象的钩子，可以理解为是介于HttpRequest与HttpResponse处理之间的一道处理过程。浏览器从请求到响应的过程中，Django需要通过很多中间件来处理。</p><p>它是一个轻量，低级别的插件系统，用于在全局范围改变Django的输入和输出，每个中间件负责一些特定功能。</p><p>中间件和拦截一部分请求，比如验证session，没有登陆的进行跳转</p><h4 id="2-6-Django的查询特性"><a href="#2-6-Django的查询特性" class="headerlink" title="2.6 Django的查询特性"></a>2.6 Django的查询特性</h4><ul><li>惰性执行、缓存</li><li>创建查询集不会访问数据库，直到使用数据时才会访问数据库，调用数据的情况包括迭代、序列化、与if合用。</li></ul><h4 id="2-7-什么是wsgi、uwsgi、uWSGI"><a href="#2-7-什么是wsgi、uwsgi、uWSGI" class="headerlink" title="2.7 什么是wsgi、uwsgi、uWSGI"></a>2.7 什么是wsgi、uwsgi、uWSGI</h4><p>WSGI：web服务器的网关接口(Web Server Gateway Interface)，是一套协议，用于接受用户请求并进行初次封装，然后交给web服务器。</p><blockquote><p>遵循wsgi规范的 web后端系统， 我们可以理解为 由两个部分组成</p><p>wsgi web server 和 wsgi web application</p><p>它们通常是运行在一个python进程中的两个模块，或者说两个子系统。</p><p>wsgi web server 接受到前端的http请求后，会调用 wsgi web application 的接口（ 比如函数或者类方法）方法，由wsgi web application 具体处理该请求。然后再把处理结果返回给 wsgi web server， wsgi web server再返回给前端。 wsgi web server 负责 提供高效的http请求处理环境，可以使用多线程、多进程或者协程的机制。</p></blockquote><blockquote><p>http 请求发送到 wsgi web server ， wsgi web server 分配 线程或者进程或者 轻量级线程(协程)，然后在 这些 线程、进程、或者协程里面，去调用执行 wsgi web application 的入口代码。</p></blockquote><blockquote><p>wsgi web application 被调用后，负责 处理 业务逻辑。 业务逻辑的处理可能非常复杂， wsgi web application 需要精心的设计来正确处理。</p></blockquote><blockquote><p>django是 wsgi web application 的框架，它只有一个简单的单线程 wsgi web server。 供调试时使用。</p></blockquote><blockquote><p>产品正式上线运行的时候，通常我们需要高效的 wsgi web server 产品，比如 gunicorn，uwsgi，cherrypy等，结合Django ，组成一个高效的 后端服务。</p></blockquote><blockquote><p>所以这个 <a href="http://wsgi.py">wsgi.py</a> 就是 提供给wsgi web server调用 的接口文件，里面的变量application对应对象实现了 wsgi入口，供wsgi web server调用 。</p></blockquote><p>实现wsgi协议的模块：</p><ol><li>wsgiref本质上是一个socket服务器，用于接受用户请求（django）</li><li>werkzeug本质上是一个socket服务器，用于接受用户请求（flask）</li></ol><p>而uswgi也是一种通信协议</p><p>uWSGI是一个web服务器，实现了上述协议。</p><h4 id="2-8-对restful的理解"><a href="#2-8-对restful的理解" class="headerlink" title="2.8 对restful的理解"></a>2.8 对restful的理解</h4><p>restful是一套编写接口的协议，协议规定如何编写url及如何设置返回值，状态信息码等。</p><p>以不同方法请求不同url产生的动作是不一样的。HTTPS、域名/api</p><h3 id="3-Docker"><a href="#3-Docker" class="headerlink" title="3. Docker"></a>3. Docker</h3><h4 id="3-1-使用docker的好处"><a href="#3-1-使用docker的好处" class="headerlink" title="3.1 使用docker的好处"></a>3.1 使用docker的好处</h4><p>将代码和其环境打包在一起，</p><h4 id="3-2-基本组成"><a href="#3-2-基本组成" class="headerlink" title="3.2 基本组成"></a>3.2 基本组成</h4><p>客户端、服务器、仓库</p><h4 id="3-3-和虚拟机的区别"><a href="#3-3-和虚拟机的区别" class="headerlink" title="3.3 和虚拟机的区别"></a>3.3 和虚拟机的区别</h4><p>容器与虚拟机拥有着类似的使命：对应用程序及其关联性进行隔离，从而构建起一套能够随处运行的自容纳单元。</p><p>此外，容器与虚拟机还摆脱了对物理硬件的需求，允许我们更为高效地使用计算资源，从而提升能源效率与成本效益。</p><p>容器与虚拟机之间的核心差异在于其架构方法。</p><ul><li>虚拟机资源占用多，启动慢，冗余步骤多</li><li>传统虚拟机会虚拟出一份硬件，运行一个完整的操作系统，然后在这个系统上安装和运行软件</li><li>docker每个容器都有自己的文件系统，互相隔离。docker内的应用直接运行在宿主机，容器没有自己的内核，也没有虚拟硬件，所以更加轻便。</li></ul><h3 id="4-Redis"><a href="#4-Redis" class="headerlink" title="4. Redis"></a>4. Redis</h3><h4 id="4-1-底层"><a href="#4-1-底层" class="headerlink" title="4.1 底层"></a>4.1 底层</h4><p>简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表</p><h4 id="4-2-对象"><a href="#4-2-对象" class="headerlink" title="4.2 对象"></a>4.2 对象</h4><p>字符串、列表、哈希、集合、有序集合（跳跃表+字典）</p><h4 id="4-3-键的过期时间"><a href="#4-3-键的过期时间" class="headerlink" title="4.3 键的过期时间"></a>4.3 键的过期时间</h4><p>Redis可以为每个键设置过期时间，当键过期时，会自动删除该键。</p><p>对于散列表这种容器，只能为整个键设置过期时间（整个散列表），而不能为键里面的单个元素设置过期时间。</p><h5 id="4-3-1-过期键的删除策略"><a href="#4-3-1-过期键的删除策略" class="headerlink" title="4.3.1 过期键的删除策略"></a>4.3.1 过期键的删除策略</h5><ol><li>定时删除：在设置键的过期时间的通过，创建一个定时器（timer），让定时器在键的过期时间来临时，立即执行对键的删除操作。（对内存最友好，对CPU时间不友好）</li><li>惰性删除：放任键过期不管，但是每次从键空间中获取键时，都检查取得的键是否过期，如果过期就删除;如果没有过期就返回：</li><li>定期删除：每隔一段时间，程序就对数据库进行一次检查，删除里边的过期键。</li></ol><h5 id="4-3-2AOF、RDB-和复制功能对过期键的处理"><a href="#4-3-2AOF、RDB-和复制功能对过期键的处理" class="headerlink" title="4.3.2AOF、RDB 和复制功能对过期键的处理"></a>4.3.2AOF、RDB 和复制功能对过期键的处理</h5><ul><li>执行SAVE命令或者BGSAVE命令所产生的新RDB文件不会包含已经过期的键</li><li>执行BGREWRITEAOF命令所产生的重写AOF文件不会包含已经过期的键</li><li>当一个过期键被删除后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式的删除过期键。</li><li>当主服务器删除一个过期键之后，服务器会追加一条DEL命令到现有AOF文件的末尾，显式的删除过期键。</li><li>从服务器即使发现过期键也不会自作主张地删除它，而是等待主节点发来DEL命令，这种统一、中心化的过期键删除策略可以保证主从服务器数据的一致性。</li></ul><h4 id="4-4-为什么用NOSQL"><a href="#4-4-为什么用NOSQL" class="headerlink" title="4.4 为什么用NOSQL"></a>4.4 为什么用NOSQL</h4><p>超大规模的高并发的社区，传统的关系型数据库很难应对。</p><p>个人信息，社交网络，地理位置等不能用固定的格式。所以用NoSQL</p><ol><li>方便扩展</li><li>大数据量高性能</li><li>数据类型多样。不需要事先设计数据库</li></ol><ul><li>传统的关系型数据库RDBMS<ol><li>结构化组织（行，列）</li><li>SQL</li><li>数据和关系都存在单独的表中</li><li>严格的一致性</li><li>基础的事务</li></ol></li><li>NoSQL<ol><li>不仅仅是数据</li><li>没有固定的查询语言</li><li>键值对存储</li><li>最终一致性</li><li>CAP定理和BASE理论 （异地多活）</li><li>高性能、高可用、高可扩展</li></ol></li><li>CAP<ol><li>P 分区容错性</li><li>C 一致性</li><li>A 可用性</li></ol></li><li>BASE<ol><li>BA 基本可用：出现了不可预知的故障时仍然可用。相比正常的系统而言会有响应时间上的损失和功能上的损失（页面降级）</li><li>S 软状态：允许数据中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时</li><li>E 最终一致性：在软状态的期限过后，应当保证所有副本保持数据一致性，这个时间期限取决于网络延时，系统负载、数据复制方案设计等等因素。</li></ol></li><li>应用场景<ul><li>计数器：对string进行自增自减运算，从而实现计数器功能</li><li>缓存：将热点数据放到内存中，设置内存的最大使用量以及淘汰策略来保证缓存的命中率。</li><li>查找表：查找表和缓存类似，也是利用了Redis快速的查找特性。但是查找表的内容不能失效，因为缓存不作为可靠的数据来源。</li><li>消息队列：List是一个双向链表，可以通过lpush和rpop写入和读取消息。</li><li>会话缓存：可以使用Redis来统一存储多台应用服务器的会话信息。当应用服务器不在存储用户的会话信息，也就不再具有状态，一个用户可以请求任意一个应用服务器，从而更容易实现高可用性以及可伸缩性。</li><li>分布式锁：在分布式场景下，无法使用单机环境下的锁来对多个节点上的进程进行同步。可以使用Redis自带的SETNX命令实现分布式锁</li><li>共同好友：Set</li><li>排行榜：ZSet</li></ul></li></ul><h4 id="4-5-字典"><a href="#4-5-字典" class="headerlink" title="4.5 字典"></a>4.5 字典</h4><p>dictht是一个散列表结构，使用拉链法解决哈希冲突。</p><p>Redis的字典dict中包含两个哈希表dictht，这是为了方便进行rehash操作。在扩容时，将其中一个dictht上的键值对rehash到另一个dichht上面，完成之后释放空间并交换两个dictht的角色。</p><p>rehash操作不是一次性完成，而是渐进方式，这是为了避免一次性执行过多的rehash操作给服务器带来过大的负担。</p><p>渐进式rehash通过记录dict的rehashidx完成，它从0开始，然后每执行一次rehash都会递增。例如在一次rehash中，要把dict[0]rehash到dict[1]，这一次会把dict[0]上table[rehashidx]的键值对rehash到dict[1]上，dict[0]的table【rehashidx指向null，并令rehashidx++。</p><p>在rehash期间，每次对字典执行添加、删除、查找或者更新操作时，都会执行一次渐进式rehash。</p><p>采用渐进式rehash会导致字典中的数据分散在两个dictht上，因此对字典的查找操作也需要到对应的dictht去执行。</p><h4 id="4-6-跳跃表"><a href="#4-6-跳跃表" class="headerlink" title="4.6 跳跃表"></a>4.6 跳跃表</h4><p>是有序集合的底层实现之一。</p><ul><li>跳跃表通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。</li><li>跳跃表支持平均O(logN)、最坏O(N)复杂度的节点查找，还可以通过顺序性操作来批量处理节点。</li></ul><p>当元素数量比较多或者成员是比较长的字符串的时候Redis会用跳跃表来实现有序集合：</p><p>跳跃表在链表的基础上增加了多级索引以提升查找的效率，这是一个用空间换时间的方案，因为索引是占内存的。原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势必然会被放大，而缺点则可以忽略。</p><p>与红黑树等平衡树相比，跳跃表具有以下优点：</p><ul><li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li><li>更容易实现</li></ul><h4 id="跳跃表的实现"><a href="#跳跃表的实现" class="headerlink" title="跳跃表的实现"></a>跳跃表的实现</h4><p>每次创建一个新跳跃表节点的时候，程序都会根据幂次定律随机生成一个介于1和32之间的值作为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line">  <span class="comment">// 后退指针</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>* <span class="title">backward</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 分值</span></span><br><span class="line">  <span class="keyword">double</span> score;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 成员对象</span></span><br><span class="line">  robj* obj;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 层</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line">    <span class="comment">// 前进指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span>* <span class="title">forward</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//  跨度,指向NULL的跨度为0，用来计算排位</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line">  &#125; level[];</span><br><span class="line">&#125; zskiplistNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplist</span> &#123;</span></span><br><span class="line">  <span class="comment">// 表头节点和表尾节点</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">header</span>, *<span class="title">tail</span>;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 表中节点的数量</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> length;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 表中层数最大的节点的层数</span></span><br><span class="line">  <span class="keyword">int</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-7-压缩列表"><a href="#4-7-压缩列表" class="headerlink" title="4.7 压缩列表"></a>4.7 压缩列表</h4><p>连续内存块组成的顺序性数据结构。由尾部向首部遍历。</p><p>由于previous_entry_length的变化可能会引发连锁更新。</p><p>实现</p><ul><li>节点：previois_entry_length + encoding + content</li><li>列表：zlbytes + zltail + Allen + entry1 + … + entry + lend </li></ul><h4 id="4-8-事务"><a href="#4-8-事务" class="headerlink" title="4.8 事务"></a>4.8 事务</h4><ol><li>Redis单条命令保证原子性，但是事务不保证原子性。 编译型错误，都不执行。 运行时错误，出错的不执行</li><li>Redis事务不存在隔离级别的概念。</li></ol><ul><li>开启事务</li><li>命令入队</li><li>执行事务</li></ul><p>watch监视变量是否被其他线程修改 unwatch</p><p>一个事务包含了多个命令，服务器在执行事务期间，不会改去执行其他客户端的命令请求。</p><p>事务中的多个命令被一次性发送给服务器，而不是一条一条发送，这种方式被称为流水线，它可以减少客户端与服务器之间的网络通信次数从而提升性能</p><p>Redis最简单的事务实现方式是使用MULTI和ECEC命令将事务操作包围起来。discard放弃。</p><h4 id="4-9-数据淘汰策略"><a href="#4-9-数据淘汰策略" class="headerlink" title="4.9 数据淘汰策略"></a>4.9 数据淘汰策略</h4><p>可以设置内存最大使用量，当内存使用量超出时，会施行数据淘汰策略。</p><p>Redis具体有6种淘汰策略：</p><table><thead><tr><th>策略</th><th>描述</th></tr></thead><tbody><tr><td>volatile-lru</td><td>从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>volatile-ttl</td><td>从已设置过期时间的数据集中挑选将要国旗的数据淘汰</td></tr><tr><td>volatile-random</td><td>从已设置过期时间的数据集中任意选择数据淘汰</td></tr><tr><td>allkeys-lru</td><td>从所有数据集中挑选最近最少使用的数据淘汰</td></tr><tr><td>allkeys-random</td><td>从所有数据集中任意选择数据进行淘汰</td></tr><tr><td>norviction</td><td>禁止驱逐数据</td></tr></tbody></table><h4 id="4-10-持久化"><a href="#4-10-持久化" class="headerlink" title="4.10 持久化"></a>4.10 持久化</h4><p>Redis是内存型数据库，为了保证数据在断电后不会丢失，需要将内存中的数据持久化到硬盘上。</p><h5 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h5><ul><li>将某个时间点的所有数据都存放到硬盘上</li><li>可以将快照复制到其他服务器从而创建具有相同数据的服务器副本。</li><li>如果系统发生故障，将会丢失最后一次创建快照之后的数据。</li><li>如果数据量很大，保存快照的时间会很长。</li></ul><h5 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h5><p>将写命令添加到AOF文件（Append Only File）的末尾</p><p>使用AOF持久化粗腰设置同步选项，从而确保写命令同步到磁盘文件上的时机。这是因为对文件进行写入并不会马上将内容同步到磁盘上，而是先存储到缓存区，然后有操作系统决定什么时候同步到磁盘。有以下同步选项：</p><table><thead><tr><th>选项</th><th>同步频率</th></tr></thead><tbody><tr><td>always</td><td>每个写命令都同步</td></tr><tr><td>everysec</td><td>每秒同步一次</td></tr><tr><td>no</td><td>让操作系统来决定何时同步</td></tr></tbody></table><ul><li>always 选项会严重减低服务器的性能</li><li>everysec选项比较合适，可以保证系统崩溃时只会丢失一秒左右的数据，并且Redis每秒执行一次同步对服务器性能几乎没有任何影响</li><li>no 选项并不能给服务器性能带来多大的提升，而且也会增加系统崩溃时数据丢失的数量。</li></ul><p>随着服务器写请求的增多，AOF文件会越来越大。Redis提供了一种将AOF重写的特性，能够去除AOF文件中的冗余写命令。</p><h4 id="4-11-Redis为什么快"><a href="#4-11-Redis为什么快" class="headerlink" title="4.11 Redis为什么快"></a>4.11 Redis为什么快</h4><ol><li>IO多路复用</li><li>数据结构简单，操作节省时间</li><li>运行在内存中</li></ol><h4 id="4-12-主从复制"><a href="#4-12-主从复制" class="headerlink" title="4.12 主从复制"></a>4.12 主从复制</h4><h5 id="连接过程"><a href="#连接过程" class="headerlink" title="连接过程"></a>连接过程</h5><h5 id="主从链"><a href="#主从链" class="headerlink" title="主从链"></a>主从链</h5><h4 id="4-13-缓存击穿、缓存穿透、缓存雪崩"><a href="#4-13-缓存击穿、缓存穿透、缓存雪崩" class="headerlink" title="4.13 缓存击穿、缓存穿透、缓存雪崩"></a>4.13 缓存击穿、缓存穿透、缓存雪崩</h4><ul><li><p>缓存穿透：key对应的数据源并不存在，每次针对此key的请求从缓存获取不到，请求都会到数据源，从而可能压垮数据源。比如用一个不存在的用户id获取用户信息，不论缓存还是数据库都没有，若黑客利用此漏洞进行攻击可能压垮数据库。解决方法：1. 采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。2. <strong>另外也有一个</strong>更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p></li><li><p>缓存击穿：key对应的数据存在，但在redis中过期，此时若有大量并发请求过来，这些请求发现缓存过期一般都会从后端DB加载数据并回设到缓存，这个时候大并发的请求可能会瞬间把后端DB压垮。在缓存失效的时候（判断拿出来的值为空），不是立即去load db，而是先使用缓存工具的某些带成功操作返回值的操作（比如Redis的SETNX或者Memcache的ADD）去set一个mutex key，当操作返回成功时，再进行load db的操作并回设缓存；否则，就重试整个get缓存的方法。</p><p>SETNX，是「SET if Not eXists」的缩写，也就是只有不存在的时候才设置，可以利用它来实现锁的效果。</p></li><li><p>缓存雪崩：当缓存服务器重启或者大量缓存集中在某一个时间段失效，这样在失效的时候，也会给后端系统(比如DB)带来很大压力。多数系统设计者考虑用加锁或者队列的方式保证来保证不会有大量的线程对数据库一次性进行读写，从而避免失效时大量的并发请求落到底层存储系统上。还有一个简单方案就时讲缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值，比如1-5分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。</p></li></ul><h4 id="4-14-和Memcached的区别"><a href="#4-14-和Memcached的区别" class="headerlink" title="4.14 和Memcached的区别"></a>4.14 和Memcached的区别</h4><p>二者都是非关系性内存键值数据库，</p><ul><li>数据类型：Redis支持五种不同的数据类型，Memcached仅支持字符串类型</li><li>数据持久化：Redis支持两种持久化策略，Memcached不支持持久化</li><li>分布式：Redis Cluster实现了分布式的支持，Memcached不支持分布式，只能通过在客户端使用一致性哈希来实现分布式存储</li><li>内存管理机制：Memcached的数据则会一直在内存中，Memcached将内存分割成特定长度的块来存储数据。但是这种方式会使得内存的利用率不高</li></ul><h3 id="5-Nginx"><a href="#5-Nginx" class="headerlink" title="5. Nginx"></a>5. Nginx</h3><h4 id="5-1-Nginx概述（多进程单线程）"><a href="#5-1-Nginx概述（多进程单线程）" class="headerlink" title="5.1 Nginx概述（多进程单线程）"></a>5.1 Nginx概述（多进程单线程）</h4><p><a href="https://www.cnblogs.com/mmdln/p/8952261.html">https://www.cnblogs.com/mmdln/p/8952261.html</a> <a href="https://www.cnblogs.com/gccbuaa/p/6795229.html">https://www.cnblogs.com/gccbuaa/p/6795229.html</a></p><p>Nginx(engine x)是一款轻量级、高性能的Web服务器/反向代理服务器及电子邮件(IMAP/POP3)代理服务器，并在一个BSD-like协议下发行。</p><ul><li>跨平台、配置简单</li><li>非阻塞，高并发连接 如果作为web服务器，nginx能够支持高达50000的并发连接数</li><li>内存消耗小，10个nginx才占用150M内存</li><li>处理静态文件好，耗费内存少</li><li>一个master进程生成多个worker进程，</li><li>多进程异步非阻塞事件处理机制（epoll模型）</li><li>内置的健康检查功能：如果有一个服务器宕机，会做一个健康检查，再发送的请求就不会发送到宕机的服务器了。重新将请求提交到其他的节点上。</li><li>可以有多台nginx服务器</li></ul><h4 id="5-2-Nginx的负载均衡算法"><a href="#5-2-Nginx的负载均衡算法" class="headerlink" title="5.2 Nginx的负载均衡算法"></a>5.2 Nginx的负载均衡算法</h4><ul><li><p>round robin（轮询，默认） 每个请求按照一定的时间顺序逐一分配到不同的后端服务器</p></li><li><p>weight 指定轮询的几率， 和访问比例呈正比，用于性能不均的情况。 加权轮询算法分为先深搜索和先广搜索，那么nginx采用的是先深搜索算法，即将首先将请求都分给高权重的机器，直到该机器的权值降到了比其他机器低，才开始将请求分给下一个高权重的机器；</p></li><li><p>IP_hash 根据请求者ip的hash值将请求发送到后台服务器中，可以保证来自同一ip的请求被打到固定的机器上，可以解决session的问题。</p></li><li><p>url_hash 根据请求的url的hash值将请求分到不同的机器中，当后台服务器为缓存的时候效率高</p></li><li><p>fair 根据后台响应时间来分发请求，响应时间短的分发的请求多。</p></li></ul><h4 id="5-3-Nginx解决惊群现象"><a href="#5-3-Nginx解决惊群现象" class="headerlink" title="5.3 Nginx解决惊群现象"></a>5.3 Nginx解决惊群现象</h4><p><strong>惊群现象</strong>：一个网络连接到来，多个睡眠的进程被同时叫醒，但只有一个进程能获得链接，这样会影响系统性能。</p><p>Linux内核2.6已经解决了accept时的惊群问题，多个子进程accept堵塞睡眠时，连接到来，只有一个进程的accept会被唤醒返回。但现在子进程的实现方式不是直接accept，而是将初始化好的fd加入到epoll 的事件队列中，epoll返回后再调用accept。Linux无法解决多个子进程epoll返回的情况。这需要子进程自己处理。</p><p>Nginx中处理epoll时惊群问题的思路很简单，多个子进程有一个锁，谁拿到锁，谁才将accept的fd加入到epoll队列中，其他的子进程拿不到锁，也就不会将fd加入到epoll中，连接到来也就不会导致所有子进程的epoll被唤醒返回。</p><h4 id="5-4-Nginx事件驱动框架"><a href="#5-4-Nginx事件驱动框架" class="headerlink" title="5.4 Nginx事件驱动框架"></a>5.4 Nginx事件驱动框架</h4><p><strong>Nginx事件驱动架构：由一些事件发生源来产生事件，由一个或多个事件收集器来收集事件（epolld）分发事件，许多事件处理器会注册自己感兴趣的事件，同时会消费这些事件。Nginx不会使用进程或线程作为事件消费者，只能是某个模块，当前进程调用模块。</strong></p><p>传统Web服务器（如Apache）的，所谓事件局限在TCP连接建立、关闭上，其他读写都不再是事件驱动，这是会退化成按序执行每个操作的批处理模式，这样每个请求在连接建立后都将始终占用系统资源，直到连接关闭才会释放资源。大大浪费了内存、cpu等资源。并且把一个进程或线程作为事件消费者。</p><p><strong>传统web服务器与Nginx之间的重要差别</strong>： 前者每个事件消费者独占一个进程资源，后者只是被事件分发者进程短期调用而已。</p><h4 id="5-5-一个master进程（管理），多个work进程（工作）"><a href="#5-5-一个master进程（管理），多个work进程（工作）" class="headerlink" title="5.5 一个master进程（管理），多个work进程（工作）"></a>5.5 一个master进程（管理），多个work进程（工作）</h4><p>master对work进程采用信号进行控制</p><h4 id="5-7-Nginx为什么性能高"><a href="#5-7-Nginx为什么性能高" class="headerlink" title="5.7 Nginx为什么性能高"></a>5.7 Nginx为什么性能高</h4><p>得益于他的事件处理器：异步非阻塞事件处理机制，运用了epoll模型，提供一个队列排队解决</p><h4 id="5-8-Nginx为什么不使用多线程"><a href="#5-8-Nginx为什么不使用多线程" class="headerlink" title="5.8 Nginx为什么不使用多线程"></a>5.8 Nginx为什么不使用多线程</h4><p>Apache：创建多个进程或线程，而每个进程或线程都会为其分配cpu和内存并发过大会榨干服务器资源（线程比进程小的多，所以worker支持比perfork高的并发）</p><p>Nginx：采用单线程异步非阻塞处理请求（管理员可以配置Nginx主进程的工作进程的数量）（epoll），不会为每个请求分配cpu和内存资源，节省了大量资源，同时也减少了大量的CPU的上下文切换。所以才使得Nginx支持更高的并发。</p><p>使用多进程模式，不仅能提高并发率，而且进程之间是相互独立的，一 个worker进程挂了不会影响到其他worker进程。</p><h4 id="5-9-Nginx是如何处理一个请求的"><a href="#5-9-Nginx是如何处理一个请求的" class="headerlink" title="5.9 Nginx是如何处理一个请求的"></a>5.9 Nginx是如何处理一个请求的</h4><ul><li>Nginx在启动时，会解析配置文件，得到监听的端口与ip地址，</li><li>然后在nginx的master进程里初始化这个监控socket， 在进行listen</li><li>然后在fork出多个子进程出来，子进程会竞争accept新的连接</li></ul><p>此时，客户端就可以向Nginx发起连接了，当客户端与Nginx进行三次握手，与Nginx建立好一个连接后</p><ul><li>某一个子进程会accept成功，然后创建nginx对连接的封装，及ngx_connection_t结构体</li><li>接着根据事件调用相应的事件处理模块，如http模块与客户端进行数据的交换</li></ul><p>最后，nginx或客户端来主动关闭连接。</p><blockquote><p>当一个 worker 进程在 accept() 这个连接之后，就开始读取请求，解析请求，处理请求，产生数据后，再返回给客户端，最后才断开连接，一个完整的请求。一个请求，完全由worker进程来处理，而且只会在一个worker进程中处理。优点：</p><p>节省锁带来的开销。每个worker进程都彼此独立地工作，不共享任何资源，因此不需要锁。同时在编程以及问题排查上时，也会方便很多。<br>独立进程，减少风险。采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快重新启动新的worker进程。当然，worker进程自己也能发生意外退出。</p></blockquote><h4 id="5-10-正向代理（代理客户端）"><a href="#5-10-正向代理（代理客户端）" class="headerlink" title="5.10 正向代理（代理客户端）"></a>5.10 正向代理（代理客户端）</h4><p>一个位于客户端和原始服务器之间的服务器，为了从原始服务器上获得内容，客户端向代理发送一个请求并指定目标（原始服务器），然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。</p><h4 id="5-11-反向代理（代理服务端）"><a href="#5-11-反向代理（代理服务端）" class="headerlink" title="5.11 反向代理（代理服务端）"></a>5.11 反向代理（代理服务端）</h4><p>反向代理方式是指以代理服务器来接受internet上的连接请求，然后将请求发送给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器就表现为一个反向代理服务器。</p><h4 id="5-12-动静分离"><a href="#5-12-动静分离" class="headerlink" title="5.12 动静分离"></a>5.12 动静分离</h4><p>动态资源、静态资源分离是让动态网站里的动态页面根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路。</p><p>在我们的软件开发中，有些请求是需要后台处理的（.jsp,.do等），有些请求是不需要经过后台处理的（css、html、jpg、js等）。这些不需要后台处理的文件称为静态文件，否则动态文件。因此我们后台处理忽略静态文件。</p><p>动静态分离将网站静态资源和与后台应用分开部署，提高用户访问静态代码的速度，降低对后台应用访问。</p><h4 id="5-13-平滑升级"><a href="#5-13-平滑升级" class="headerlink" title="5.13 平滑升级"></a>5.13 平滑升级</h4><p>（1）在不停掉老进程的情况下，启动新进程。 （2）老进程负责处理仍然没有处理完的请求，但不再接受处理请求。 （3）新进程接受新请求。 （4）老进程处理完所有请求，关闭所有连接后，停止。</p><h3 id="6-遇到的困难"><a href="#6-遇到的困难" class="headerlink" title="6. 遇到的困难"></a>6. 遇到的困难</h3><p>定时任务添加</p><p>短链接生成</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-介绍一下项目&quot;&gt;&lt;a href=&quot;#1-介绍一下项目&quot; class=&quot;headerlink&quot; title=&quot;1. 介绍一下项目&quot;&gt;&lt;/a&gt;1. 介绍一下项目&lt;/h3&gt;&lt;h3 id=&quot;2-Django&quot;&gt;&lt;a href=&quot;#2-Django&quot; class=&quot;he</summary>
      
    
    
    
    <category term="项目相关" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
    <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
    <category term="Django" scheme="http://yoursite.com/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>服务器项目总结</title>
    <link href="http://yoursite.com/2021/03/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2021/03/05/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-05T14:15:36.000Z</published>
    <updated>2021-03-19T06:12:57.445Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Tiny-Web-Server-服务器项目整理总结"><a href="#Tiny-Web-Server-服务器项目整理总结" class="headerlink" title="Tiny Web Server 服务器项目整理总结"></a>Tiny Web Server 服务器项目整理总结</h1><h3 id="1-Reactor模型"><a href="#1-Reactor模型" class="headerlink" title="1. Reactor模型"></a>1. Reactor模型</h3><p>主线程（I/O处理单元）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理新的连接，以及处理客户请求均在工作线程中完成。</p><ol><li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li><li>主线程调用epoll_wait等待socket上有数据可读。</li><li>当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，他从socket读取数据并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。</li><li>主线程调用epoll_wait()等待socket可写。</li><li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</li></ol><h3 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h3><ul><li>资源重用，避免了线程频繁建立、关闭的开销</li><li>控制资源的使用。如果不使用池，每次都需要创建一个线程，这样系统的稳定性受系统连接需求影响很大，很容易产生资源浪费和高负载异常。池能够使性能最大化，将资源利用控制在一定的水平之下。连接池能控制池中的连接数量，增强了系统在大量用户应用时的稳定性。</li><li>实现：构造、析构、任务enqueue</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdexcept&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  ThreadPool(<span class="keyword">size_t</span>);</span><br><span class="line">  ~ThreadPool();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">  <span class="function"><span class="keyword">auto</span> <span class="title">enqueue</span><span class="params">(F&amp;&amp;f, Args&amp;&amp;... args)</span></span></span><br><span class="line">    -&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::thread&gt; workers;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">queue</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;&gt; tasks;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::mutex queue_mutex;</span><br><span class="line">  <span class="built_in">std</span>::condition_variable condition;</span><br><span class="line">  <span class="keyword">bool</span> stop;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">ThreadPool::ThreadPool</span><span class="params">(<span class="keyword">size_t</span> num_threads)</span> : <span class="title">stop</span><span class="params">(<span class="literal">false</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; num_threads; ++i) &#123;</span><br><span class="line">    workers.emplace_back(</span><br><span class="line">      [<span class="keyword">this</span>]()&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">          <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; task;</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; lock(<span class="keyword">this</span>-&gt;queue_mutex);</span><br><span class="line">            <span class="keyword">this</span>-&gt;condition.wait(lock,</span><br><span class="line">              [<span class="keyword">this</span>]()&#123;<span class="keyword">return</span> <span class="keyword">this</span>-&gt;stop || !<span class="keyword">this</span>-&gt;tasks.empty();&#125;);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">this</span>-&gt;stop &amp;&amp; <span class="keyword">this</span>-&gt;tasks.empty()) &#123;</span><br><span class="line">              <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            task = <span class="built_in">std</span>::move(<span class="keyword">this</span>-&gt;tasks.front());</span><br><span class="line">            <span class="keyword">this</span>-&gt;tasks.pop();</span><br><span class="line">          &#125;</span><br><span class="line">          task();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> ThreadPool::~ThreadPool() &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  condition.notify_all();</span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">std</span>::thread&amp; worker : workers) &#123;</span><br><span class="line">    worker.join();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">ThreadPool::enqueue</span><span class="params">(F&amp;&amp; f, Args&amp;&amp;... args)</span></span></span><br><span class="line">  -&gt; std::future&lt;typename std::result_of&lt;F(Args...)&gt;::type&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">using</span> return_type = <span class="keyword">typename</span> <span class="built_in">std</span>::result_of&lt;F(Args...)&gt;::type;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">auto</span> task = <span class="built_in">std</span>::make_shared&lt;<span class="built_in">std</span>::packaged_task&lt;return_type()&gt;&gt; (</span><br><span class="line">    <span class="built_in">std</span>::bind(<span class="built_in">std</span>::forward&lt;F&gt;(f), <span class="built_in">std</span>::forward&lt;Args&gt;(args)...)</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">future</span>&lt;return_type&gt; res = task-&gt;get_future();</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">lock</span><span class="params">(queue_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (stop) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="built_in">std</span>::runtime_error(<span class="string">&quot;enqueue on stopped ThreadPool&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    tasks.emplace([task]()&#123;(*task)();&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  condition.notify_one();</span><br><span class="line">  <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-状态机解析HTTP请求"><a href="#3-状态机解析HTTP请求" class="headerlink" title="3. 状态机解析HTTP请求"></a>3. 状态机解析HTTP请求</h3><p>LINE_STATE， PARSE_STATE, HTTP_CODE</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LINE_STATE</span> &#123;</span>LINE_OK = <span class="number">0</span>, LINE_BAD, LINE_MORE&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">PARSE_STATE</span> &#123;</span>PARSE_REQUESTLINE = <span class="number">0</span>, PARSE_HEADER, PARSE_BODY&#125;;</span><br><span class="line"> <span class="class"><span class="keyword">enum</span> <span class="title">HTTP_CODE</span> &#123;</span>NO_REQUEST = <span class="number">0</span>, GET_REQUEST, BAD_REQUEST, NOT_IMPLEMNTED, </span><br><span class="line">                 FORBIDDEN_REQUEST, INTERNAL_ERROR, CLOSED_CONNECTION&#125;;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">static</span> LINE_STATE <span class="title">parse_line</span><span class="params">(Buffer&amp; buffer)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> HTTP_CODE <span class="title">parse_request_line</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, PARSE_STATE&amp;, HttpRequest&amp;)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> HTTP_CODE <span class="title">parse_headers</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, PARSE_STATE&amp;, HttpRequest&amp;)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> HTTP_CODE <span class="title">parse_body</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;, HttpRequest&amp;)</span></span>;</span><br><span class="line"> <span class="function"><span class="keyword">static</span> HTTP_CODE <span class="title">parse_content</span><span class="params">(Buffer&amp; buffer, PARSE_STATE &amp;parse_state, HttpRequest&amp; request)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="4-定时器结构"><a href="#4-定时器结构" class="headerlink" title="4. 定时器结构"></a>4. 定时器结构</h3><p>最小堆实现。</p><p>每一个TimerNode包含一个expired Time，和Httpdata的指针，</p><p>有一个_deleted字段支持惰性删除。</p><h4 id="实现定时器的其他方式"><a href="#实现定时器的其他方式" class="headerlink" title="实现定时器的其他方式"></a>实现定时器的其他方式</h4><p>升序链表、时间轮</p><h3 id="5-双缓冲区技术实现异步日志系统"><a href="#5-双缓冲区技术实现异步日志系统" class="headerlink" title="5. 双缓冲区技术实现异步日志系统"></a>5. 双缓冲区技术实现异步日志系统</h3><h4 id="为什么要一个日志系统？"><a href="#为什么要一个日志系统？" class="headerlink" title="为什么要一个日志系统？"></a>为什么要一个日志系统？</h4><p> 记录系统状态，方便查找出错原因</p><h4 id="为什么要是实现一个日志系统？"><a href="#为什么要是实现一个日志系统？" class="headerlink" title="为什么要是实现一个日志系统？"></a>为什么要是实现一个日志系统？</h4><p>stdio在使用上不便，容易出现缓冲区溢出、格式字符串混淆等错误，而且很难保证类型安全。不可扩展。</p><p>iostream是可扩展的类型安全的IO机制。但是ostream格式化输出繁琐，istream不适合输入带格式的数据，线程不安全，不适合在多线程程序中做logging。</p><p>应该使用成熟的多线程库。</p><h4 id="双缓冲区？"><a href="#双缓冲区？" class="headerlink" title="双缓冲区？"></a>双缓冲区？</h4><p>准备两块buffer，一块写入日志消息，一块将消息写入文件。 </p><h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><p>用一个线程负责收集日志消息并写入文件，其他业务线程只管往这个“日志线程”发送消息，这称为异步日志。</p><p>多生产者-单消费者问题，对于生产者而言，要尽量做到低延迟，低cpu开销，无阻塞；对消费者而言要做到足够大的吞吐量，并占用较少资源。</p><ul><li>FileUtil 封装了文件的打开，关闭，写入。</li><li>LogFile 在FileUtil的基础上，加了锁，和按写次数flush。</li><li>LogStream 重载operator&lt;&lt;,将内容存在自己的缓存中。</li><li>AsyncLogging 启动一个log线程，负责定时或缓冲区填满时，将log写入logFile。双缓冲交换指针。</li><li>Logging 是对外接口，内含一个LogStream，将内容输入到LogStream的buffer中，并有一个静态的AsyncLogger， 向日志文件内写内容。实现了日志等级</li></ul><h3 id="6-RAII机制"><a href="#6-RAII机制" class="headerlink" title="6. RAII机制"></a>6. RAII机制</h3><p>资源获得即初始化。</p><p>智能指针、unique_lock、fd（socket）</p><h3 id="7-压测"><a href="#7-压测" class="headerlink" title="7. 压测"></a>7. 压测</h3><p>Webbench。4内核、4G内存。1000clients，60s，QPS 36621<br>内部实现有两种机制，一种是等待结果计算再开始下一次请求。另一种不等待计算结果直接开始下一次请求</p><p>会问到HTTP管线化（HTTP pipelining）</p><p>进程间通信(pipe)：</p><p>管道：如果没有缓冲区，单纯的往其中放入元素立马就会进入阻塞状态，必须有其他的线程从其中取走元素。通俗的讲要有一个线程不断的取这个管道的元素，才能往其中放入元素。它就像一个窄窄的门框，进去就得出来。</p><p>而有一个缓冲区的管道想一段地道，放入的元素不会马上进入阻塞状态，只有第二个准备进入而第一个还没有进入的情况下才会阻塞。</p><h3 id="8-一个请求到来的处理过程"><a href="#8-一个请求到来的处理过程" class="headerlink" title="8. 一个请求到来的处理过程"></a>8. 一个请求到来的处理过程</h3><p>启动：服务器listen_fd, 新建线程池，和epoll_fd。 令epoll监听listen_fd(不要注册EPOLLONESHOT）.</p><p>请求到来：connect，epoll通知事件就绪，将client_socket设置非阻塞，Nodelay（禁用nagle算法），将fd和httpData绑定，然后重新加入epoll，添加定时器。将处理连接请求的函数推入线程池的任务队列。</p><p>处理请求：</p><ul><li>从socket中读取数据，逐步分析请求行（方法，url，版本）首部行，空行，实体主体。</li><li>如果是HEAD请求，发送头部，如果是GET，除了头部之外在发送指定文件。（共享内存，mmap，munmap）</li><li>如果是短链接则直接关闭，长连接重新添加定时器，再次令epoll监听fd</li></ul><h3 id="9-遇到的问题"><a href="#9-遇到的问题" class="headerlink" title="9 遇到的问题"></a>9 遇到的问题</h3><ol><li>webbench测试完就会宕机。</li></ol><p>连接建立，若某一端关闭连接，而另一端仍然向它写数据，第一次写数据后会收到RST响应，此后再写数据，内核将向进程发出SIGPIPE信号，通知进程此连接已经断开。而SIGPIPE信号的默认处理是终止程序，导致上述问题的发生。应该忽略SIGPIPE信号。</p><h3 id="10-为什么用非阻塞IO"><a href="#10-为什么用非阻塞IO" class="headerlink" title="10. 为什么用非阻塞IO"></a>10. 为什么用非阻塞IO</h3><ul><li>水平触发：只要缓冲区有数据准备好就传递就绪信号</li><li>边缘触发：只有新数据到来才会传递就绪信号，没有新数据到来时尽管有旧数据没有呗读取也不通知</li></ul><p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h3 id="11-无锁队列"><a href="#11-无锁队列" class="headerlink" title="11. 无锁队列"></a>11. 无锁队列</h3><p>CAS</p><h3 id="12-epoll"><a href="#12-epoll" class="headerlink" title="12. epoll"></a>12. epoll</h3><p>epoll是select和poll的增强版本。相对于select和poll来说，epoll更加的灵活，没有描述符的限制。epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符放到内核一个事件表中，这样用户空间和内核空间的数据拷贝只需要一次。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>epoll_create 创建一个epoll句柄，size用来告诉内核监听的数目。这个不同于select中的第一个参数。需要注意的是，创建好epoll句柄后，他会占用一个fd值，所以使用完后要关闭</p><p>epoll_ctl 事件注册函数，不同于select() 监听事件时告诉内核监听什么样的事件， 而是先注册监听事件的类型。第一个参数是epoll_create()的返回值，第二个参数表示动作。（CTL的增删改）第三个参数是需要监听的参数，第四个参数告诉内核需要监听什么事。events是几个宏 的集合（类似poll）</p><ul><li>水平触发：只要缓冲区有数据准备好就传递就绪信号</li><li>边缘触发：只有新数据到来才会传递就绪信号，没有新数据到来时尽管有旧数据没有被读取也不通知</li></ul><p>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</p><h4 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h4><p>即使使用ET模式，一个socket上的某个事件还是可能被多次触发。比如，一个线程在读取完某个socket上的数据开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读（EPOLLIN再次被触发）此时另外一个线程被唤醒来读取这些新的数据。于是出现了两个线程同时擦耦走一个socket的局面。我们希望<strong>一个socket连接在任意时刻都只被一个线程处理</strong>。这时要使用epoll的EPOLLONESHOT事件实现。</p><p>对于注册了POLLONESHOT事件的文件描述符，系统最多触发一个事件，且只触发一次，<strong>除非用epoll_ctl函数重置</strong>。当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。操作完之后应重置EPOLLONESHOT事件。如果再处理时有新来了请求该线程将继续为这个socket服务。</p><p>监听socket listen_fd 上是不能注册EPOLLONESHOT事件的，否则应用程序只能处理一个客户连接。</p><p>后续的客户连接请求将不再触发listenfd上的EPOLLIN事件</p><h4 id="select-poll-epoll区别"><a href="#select-poll-epoll区别" class="headerlink" title="select poll epoll区别"></a>select poll epoll区别</h4><ul><li>select</li></ul><ol><li>select函数使用整形变量保存当前管理的用户进程数，使用句柄指针向可读进程集合、可写进程集合以及错误进程集合，使用毫秒级定时器结构体进程轮询计时。</li></ol><ul><li>poll</li></ul><ol><li>使用事件代码代替select可读可写错误指针，能够监听更多种事件，将输入输出事件分开，下次进入时不必重新初始化</li><li>计时器采用整形变量，计时精度变低，只能执行秒级计时。</li><li>可监控的数据量远大于select。</li></ol><ul><li>epoll</li></ul><ol><li>定时器超时后不必全局扫描管理的进程，epoll函数只对活跃的socket进行操作，每个socket的数据准备好后会调用回调函数使socket变为活跃。</li><li>使用mmap共享内存加速内核和用户空间消息传递</li></ol><h3 id="13-多进程和多线程的适用场景"><a href="#13-多进程和多线程的适用场景" class="headerlink" title="13. 多进程和多线程的适用场景"></a>13. 多进程和多线程的适用场景</h3><ol><li>需要频繁创建和销毁的优先使用线程,</li><li>强相关的处理使用线程，弱相关使用进程。当数据是共享且可变的，那么用多进程之间的数据同步会成为很大问题。</li><li>可能扩展到多机分布的使用进程，多核分布的使用线程</li></ol><h4 id="1-多进程的工作模式"><a href="#1-多进程的工作模式" class="headerlink" title="1. 多进程的工作模式"></a>1. 多进程的工作模式</h4><ul><li>a. 将一个单线程的进程运行多份</li><li>b. 主进程 + worker进程，比如httpd + fastcgi</li></ul><ul><li>在进行启动和销毁的开销远小于实际任务的耗时时，使用进程是合理的。如果任务耗时较少，可以起一个线程。</li></ul><h4 id="2-必须使用单线程的场合"><a href="#2-必须使用单线程的场合" class="headerlink" title="2. 必须使用单线程的场合"></a>2. 必须使用单线程的场合</h4><ol><li>程序可能会fork();</li><li>限制程序的CPU占用率。</li><li>相比单线程，在IObound（很小的CPU负载便能将IO跑慢）和CPUbound（很小的IO流量就能让CPU跑慢）的场合下，多线程用处不大</li></ol><h4 id="3-使用多线程程序的场景"><a href="#3-使用多线程程序的场景" class="headerlink" title="3. 使用多线程程序的场景"></a>3. 使用多线程程序的场景</h4><p>  提高响应速度，让IO和“计算”相互重叠，降低latency。虽然多线程不能提高绝对性能，但能提高平均响应性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Tiny-Web-Server-服务器项目整理总结&quot;&gt;&lt;a href=&quot;#Tiny-Web-Server-服务器项目整理总结&quot; class=&quot;headerlink&quot; title=&quot;Tiny Web Server 服务器项目整理总结&quot;&gt;&lt;/a&gt;Tiny Web Se</summary>
      
    
    
    
    <category term="项目相关" scheme="http://yoursite.com/categories/%E9%A1%B9%E7%9B%AE%E7%9B%B8%E5%85%B3/"/>
    
    
    <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
    <category term="HTTP" scheme="http://yoursite.com/tags/HTTP/"/>
    
    <category term="项目" scheme="http://yoursite.com/tags/%E9%A1%B9%E7%9B%AE/"/>
    
  </entry>
  
  <entry>
    <title>数据库知识点整理</title>
    <link href="http://yoursite.com/2021/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2021/03/04/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86/</id>
    <published>2021-03-04T14:51:54.000Z</published>
    <updated>2021-03-19T06:12:57.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、事务"><a href="#一、事务" class="headerlink" title="一、事务"></a>一、事务</h2><h3 id="1-什么是事务？4特征"><a href="#1-什么是事务？4特征" class="headerlink" title="1. 什么是事务？4特征"></a>1. 什么是事务？4特征</h3><p>事务是一组原子性的SQL语句，要不全部执行成功，要不全部执行失败。</p><p>ACID：</p><ul><li>A（Atomicity）原子性：一个事务必须被视为一个不可分割的最小单元，整个事务的所有操作要不全部执行，要不全部回滚，对于一个事务来说不可能只执行部分操作。回滚可以通过回滚日志来实现，回滚日志记录着事务执行的修改操作，回滚时反向执行。</li><li>C（Consistently）一致性：数据库总是从一个一致性状态转移到另一个一致性状态。当执行某个事务中途出现错误时，因为没有提交，因此不会保存到服务器中。在一致性状态下，所有事务对一个数据的读取结果都是相同的。</li><li>I（Isolation）隔离性：一个事务提交之前所做的修改，其他事务是看不到的。</li><li>D（Durability）持久性：一旦事务提交，他做的修改就会永远保存在数据库中。即使系统崩溃事务执行结果也不能丢失，使用重做日志来保障持久性。</li></ul><h3 id="2-隔离级别"><a href="#2-隔离级别" class="headerlink" title="2. 隔离级别"></a>2. 隔离级别</h3><ol><li>未提交读：即使事务没有提交，对于其他事务也是可见的，事务可以读取未提交的数据，成为脏读。</li><li>提交读：大部分数据库都是采用这个作为隔离级别（MYSQL不是），一个事务开始时，只能看到已经提交的事务。这个隔离级别也叫做不可重复读，因为两次同样的查询，可能会得到不同的结果。</li><li>可重复读：该级别保证了多次查询结果一致。但是不能解决幻读问题，当一个事务在读取某个范围内的记录的时候，另外一个事务在这个范围内插入了新的数据，当第一个事务在一次读取时，就会产生幻行。通过多版本控制MVCC解决这个问题，MYSQL默认隔离级别</li><li>可串行化：通过强制事务串行执行，避免了幻读的问题。会在每一行数据加锁，会导致超时和锁争用的问题。</li></ol><h3 id="3-隔离级别的实现"><a href="#3-隔离级别的实现" class="headerlink" title="3. 隔离级别的实现"></a>3. 隔离级别的实现</h3><ol><li>锁：通过封锁来保证事务的可串行化。通过共享、排他锁及两阶段封锁协议保证串行化下的并发读</li><li>时间戳：为每一个事务分配一个时间戳，系统维护两个时间戳来保证冲突情况下按照顺序访问数据</li><li>多版本和快照隔离：快照隔离中，我们可以想象每个事务开始时尤其是自身的数据库版本或快照，他从这个私有的版本中读取数据，因为和其他事务的更新隔离。事务的更新只在私有数据库中进行，只有提交时才将信息保存，写入数据库。</li></ol><h2 id="二、封锁"><a href="#二、封锁" class="headerlink" title="二、封锁"></a>二、封锁</h2><h3 id="1-封锁的粒度"><a href="#1-封锁的粒度" class="headerlink" title="1. 封锁的粒度"></a>1. 封锁的粒度</h3><p>MySQL中提供了两种封锁粒度，行级锁和表级锁。</p><p>应当只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，放生锁争用的可能就越小，系统的并发程度就越高。但是加锁需要消耗资源，锁的各种操作（获取锁、释放锁、检查锁的状态）都会增加系统开销，因此封锁粒度越小，系统开销越大。</p><p>所以选择封锁粒度时，应该在锁粒度和系统开销之间作出权衡。</p><h3 id="2-封锁类型"><a href="#2-封锁类型" class="headerlink" title="2. 封锁类型"></a>2. 封锁类型</h3><h4 id="2-1-读写锁"><a href="#2-1-读写锁" class="headerlink" title="2.1 读写锁"></a>2.1 读写锁</h4><ul><li>互斥锁（X锁），又称写锁。一个事务对数据加了X锁，就可以对数据进行读取和更新，加锁期间其他事务不能对数据加任何锁。</li><li>共享锁（S锁），又称读锁。一个事务对数据加了S锁，就可以对数据进行读取，但是不能更新，加锁期间其他事务能对数据加S锁，但是不能加X锁。</li></ul><h4 id="2-2-意向锁"><a href="#2-2-意向锁" class="headerlink" title="2.2 意向锁"></a>2.2 意向锁</h4><p>使用意向锁可以更容易的支持多粒度封锁。在存在行级锁和表级锁的情况下，事务想要加表锁就必须检查是否有其他事务对表或表中的行加了锁，这是非常耗时的。</p><p>意向锁在原来的X/S锁之上引入了IX/IS，IX/IS都是表锁，用来表示一个事务想要在表中的某个数据行上加X锁或S锁</p><ul><li>一个事务在获取某个数据行的S锁之前，必须先获得表的IS锁或着级别强的锁。</li><li>一个事务在获取某个数据行的X锁之前，必须获得表的IX锁。</li></ul><h3 id="3-封锁协议"><a href="#3-封锁协议" class="headerlink" title="3. 封锁协议"></a>3. 封锁协议</h3><h4 id="3-1-三级封锁协议"><a href="#3-1-三级封锁协议" class="headerlink" title="3.1 三级封锁协议"></a>3.1 三级封锁协议</h4><ol><li>一级封锁协议：事务T要修改数据A时必须加X锁，直到T结束才释放锁。解决修改丢失</li><li>二级封锁协议：在一级的基础上，要求读取数据A时必须加S锁，读取完马上释放S锁。解决读脏数据问题，</li><li>三级封锁协议：在二级的基础上，要求读取数据A时必须加S锁，直到事务结束了才能释放S锁。解决不可重复读问题。</li></ol><h4 id="3-2-两段锁协议"><a href="#3-2-两段锁协议" class="headerlink" title="3.2 两段锁协议"></a>3.2 两段锁协议</h4><p>加锁和解锁分为两个阶段进行：</p><ul><li>增长阶段：事务可以获得锁，但是不能释放锁</li><li>缩减阶段：事务可以释放锁，但是不能获得新锁</li></ul><p>可串行化是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。事务遵循两段锁协议是保证可串行化调度的充分条件。例如一下操作满足两段锁协议，它是可串行化调度。</p><h4 id="3-3-MySQL隐式与显示锁定"><a href="#3-3-MySQL隐式与显示锁定" class="headerlink" title="3.3 MySQL隐式与显示锁定"></a>3.3 MySQL隐式与显示锁定</h4><p>MySQL的InnoDB存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。可用语句进行显示锁定。</p><h2 id="三、多版本并发控制（MVCC）"><a href="#三、多版本并发控制（MVCC）" class="headerlink" title="三、多版本并发控制（MVCC）"></a>三、多版本并发控制（MVCC）</h2><h3 id="1-什么是多版本并发控制？"><a href="#1-什么是多版本并发控制？" class="headerlink" title="1. 什么是多版本并发控制？"></a>1. 什么是多版本并发控制？</h3><p>MVCC（Multi-Version Concurrency Control）是实现隔离级别的一种具体实现方式，用于实现提交读和可重复读两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用MVCC无法实现。</p><p>加锁能解决多个事务同时执行时出现的并发一致性，在实际场景中读操作往往多于写操作，因此引入读写锁来避免不必要的加锁操作。而MVCC利用了多版本思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系。</p><p>在MVCC中事务的修改操作都会为数据行新增一个版本快照。</p><h3 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h3><h4 id="1-版本号"><a href="#1-版本号" class="headerlink" title="1.版本号"></a>1.版本号</h4><ul><li>系统版本号SYS_ID:是一个递增的数据，每开始一个新的事务，系统版本号就会递增。</li><li>事务版本号TRX_ID:事务开始时系统的版本号。</li></ul><h4 id="2-Undo日志"><a href="#2-Undo日志" class="headerlink" title="2. Undo日志"></a>2. Undo日志</h4><p>MVCC的多版本指的是多个版本的快照，快照存储在Undo日志中，该日志通过回滚指针ROLL_PTR把一个数据行的所有快照连接起来。INSERT,UPDATE,DELETE操作会创建一个日志，并将事务版本号TRX_ID写入。DELETE可以看成是一个特殊的UPDATE，还会额外将DEL字段设为1。</p><h4 id="3-ReadView"><a href="#3-ReadView" class="headerlink" title="3. ReadView"></a>3. ReadView</h4><p>MVCC维护了一个ReadView结构，主要包含了当前系统未提交的事务列表TRX_IDs {id1, id2, …},还有该列表的最小值TRX_ID_MIN与最大值TRX_ID_MAX。</p><p>进行SELECT操作时，根据数据行快照的TRX_ID与TRX_ID_MAX，TRX_ID_MIN之间的关系，从而判断数据行是否可用。</p><ul><li>TRX_ID &lt; TRX_ID_MIN,表示该数据行的快照是在当前所有未提交事务之前进行更改的，因此可以使用。</li><li>TRX_ID &gt; TRX_ID_MAX,表示该数据行快照是在事务启动之后被更改的，因此不可用。</li><li>TRX_ID_MIN &lt;= TRX_ID &lt;= TRX_ID_MAX, 需要根据隔离级别进行判断：<ul><li>提交读：如果TRX_ID在TRX_IDs列表中，表示该数据行快照对应的事务还未提交，则该快照不可用。否则表示已提交，可以使用。</li><li>可重复读：都不可以使用。</li></ul></li></ul><h4 id="4-快照读与当前读"><a href="#4-快照读与当前读" class="headerlink" title="4. 快照读与当前读"></a>4. 快照读与当前读</h4><ul><li>快照读：MVCC的SELECT操作是快照中的数据，不需要进行加锁操作。</li><li>当前读：MVCC其他会对数据库进行修改的操作（INSERT、DELETE、UPDATE）需要进行加锁操作，从而读取新的数据。可以看到MVCC并不是完全不加锁，而只是避免了SELECT的加锁操作</li></ul><h3 id="3-Next-Key-Locks"><a href="#3-Next-Key-Locks" class="headerlink" title="3. Next-Key Locks"></a>3. Next-Key Locks</h3><p>MVCC不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读隔离级别下，使用MVCC+Next-Key Locks可以解决幻读问题。</p><h4 id="Record-Locks"><a href="#Record-Locks" class="headerlink" title="Record Locks"></a>Record Locks</h4><p>锁定一个记录上的索引，而不是记录本身。</p><h4 id="Gap-Locks"><a href="#Gap-Locks" class="headerlink" title="Gap Locks"></a>Gap Locks</h4><p>锁定索引之间的间隙，但是不包含索引本身。</p><h4 id="Next-Key-Locks"><a href="#Next-Key-Locks" class="headerlink" title="Next-Key Locks"></a>Next-Key Locks</h4><p>它是Record Locks 和Gap Locks的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。</p><h2 id="四、数据库的范式"><a href="#四、数据库的范式" class="headerlink" title="四、数据库的范式"></a>四、数据库的范式</h2><ul><li>第一范式：1NF是对属性的原子性约束，要求属性(列)具有原子性，不可再分解；(只要是关系型数据库都满足1NF)[属性不可再分]</li><li>第二范式：2NF是对记录的惟一性约束，表中的记录是唯一的, 就满足2NF, 通常我们设计一个主键来实现，主键不能包含业务逻辑。（属性完全依赖于主键）[消除对主属性的部份依赖]</li><li>第三范式：3NF是对字段冗余性的约束，它要求字段没有冗余。 没有冗余的数据库设计可以做到（例如，存在一个课程表，课程表中有课程号(Cno),课程名(Cname),学分(Ccredit)，那么在学生信息表中就没必要再把课程名，学分再存储到学生表中，这样会造成数据的冗余，第三范式就是属性不依赖与其他非主属性，也就是说，如果存在非主属性对于码的传递函数依赖，则不符合第三范式），但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。[消除对主属性的传递依赖]</li></ul><h2 id="五、SQL与NOSQL的区别"><a href="#五、SQL与NOSQL的区别" class="headerlink" title="五、SQL与NOSQL的区别"></a>五、SQL与NOSQL的区别</h2><p>关系型数据库的数据结构是表<strong>结构</strong>，它容易理解，同时易于维护，并且提供了通用的<strong>SQL语言</strong>，使用起来非常方便，学习成本较简单，并且支持多个表的连接查询等复杂的查询。但是由于固定的表结构，<strong>扩展性</strong>比较差，一旦进行系统的升级需要很大的变动。然而非关系数据库的存储机制有很多，如键值对，基于文档的等等，具有很高的灵活性，同时易于扩展，但是它不支持复杂的查询。同时由于数据量的增多，关系型数据库通过表的连接进行<strong>查询效率</strong>很低。</p><p>关系型数据库还有一个特点是数据的<strong>一致性</strong>，它的事务遵循ACID的准则。但是在现在的一些应用中，不需要严格的数据一致性和实时性，用户A和用户B看到C的内容的改变可以相差一段时间，因此数据一致性的要求没有那么严谨。同时由于关系型数据库为了满足一致性导致<strong>读写性能</strong>较差，然而现在的应用更多的追求高并发读写要求，因此成为了高并发的瓶颈。（而关系型数据库由于是从*<em>硬盘I/O</em>）</p><p>关系型数据库的优点：<br>1.容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解<br>2.使用方便：通用的SQL语言使得操作关系型数据库非常方便<br>3.易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率</p><p>关系型数据库存在的问题<br>1.网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，硬盘I/O是一个很大的瓶颈<br>2.网站每天产生的数据量是巨大的，对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的<br>3.在基于web的结构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。当需要对数据库系统进行升级和扩展时，往往需要停机维护和数据迁移。<br>4.性能欠佳：在关系型数据库中，导致性能欠佳的最主要原因是多表的关联查询，以及复杂的数据分析类型的复杂SQL报表查询。为了保证数据库的ACID特性，必须尽量按照其要求的范式进行设计，关系型数据库中的表都是存储一个格式化的数据结构。</p><p>非关系型数据库优点 1.用户可以根据需要去添加自己需要的字段，为了获取用户的不同信息，不像关系型数据库中，要对多表进行关联查询。仅需要根据id取出相应的value就可以完成查询。 2.适用于SNS(Social Networking Services)中，例如facebook，微博。系统的升级，功能的增加，往往意味着数据结构巨大变动，这一点关系型数据库难以应付，需要新的结构化数据存储。由于不可能用一种数据结构化存储应付所有的新的需求，因此，非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。</p><p>非关系型数据库不足：<br>只适合存储一些较为简单的数据，对于需要进行较复杂查询的数据，关系型数据库显的更为合适。不适合持久存储海量数据</p><p>MySQL体积小、速度快、成本低、结构稳定、便于查询，可以保证数据的一致性，但缺乏灵活性。NoSQL高性能、高扩展、高可用，不用局限于固定的结构，减少了时间和空间上的开销，却又很难保证数据一致性。</p><p>如果规模和性能比24小时的数据一致性更重要，那NoSQL是一个理想的选择 （NoSQL依赖于BASE模型——基本可用、软状态、最终一致性）。</p><p>但如果要保证到“始终一致”，尤其是对于机密信息和财务信息，那么MySQL很可能是最优的选择（MySQL依赖于ACID模型——原子性、一致性、独立性和耐久性）</p><h2 id="六、索引"><a href="#六、索引" class="headerlink" title="六、索引"></a>六、索引</h2><ul><li>单列索引：一个索引只能包含单个列，一个表可以有多个单列索引</li><li>唯一索引：索引列的值必须唯一，但允许有空值</li><li>复合索引（多列）</li></ul><h3 id="1-MySQL索引"><a href="#1-MySQL索引" class="headerlink" title="1. MySQL索引"></a>1. MySQL索引</h3><h4 id="1-B-TREE索引"><a href="#1-B-TREE索引" class="headerlink" title="1. B+TREE索引"></a>1. B+TREE索引</h4><ul><li>因为不在需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多</li><li>因为B+Tree的有序性，所以除了用于查找，还可以用于排序和分组。</li><li>可以指定多个列作为索引列，多个索引列共同组成键。</li><li>适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。</li><li>InnoDB的B+Tree索引分为主索引和辅助索引。主索引的叶子节点data域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。</li><li>辅助索引的叶子节点的data域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。</li></ul><h4 id="2-hash索引"><a href="#2-hash索引" class="headerlink" title="2. hash索引"></a>2. hash索引</h4><p>哈希索引以O(1)时间进行查找，但是失去了有序性：</p><ul><li>无法用于排序与分组</li><li>只支持精确查找，无法用于部分查找和范围查找。</li></ul><p>InnoDB存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在B+Tree索引之上在创建一个哈希索引，这样就让B+Tree索引具有哈希索引的一些优点，比如快速的哈希查找。</p><h4 id="3-全文索引"><a href="#3-全文索引" class="headerlink" title="3. 全文索引"></a>3. 全文索引</h4><p>查找文本中的关键词，根据空格分词。</p><p>全文索引一般通过倒排索引实现。它在辅助表中存储了单词与单词自身在一个或多个文档中所在的位置之间的映射。</p><h4 id="4-空间数据索引-R-TREE"><a href="#4-空间数据索引-R-TREE" class="headerlink" title="4. 空间数据索引 R-TREE"></a>4. 空间数据索引 R-TREE</h4><p>空间查询，常用于地理数据存储，会从所有维度索引数据。</p><h4 id="5-索引的优缺点及使用"><a href="#5-索引的优缺点及使用" class="headerlink" title="5. 索引的优缺点及使用"></a>5. 索引的优缺点及使用</h4><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ol><li>加快数据检索速度</li><li>减少分组中查找和排序用的时间</li><li>通过创建唯一性索引，保证数据的唯一性</li><li>加速表与表之间的连接</li></ol><h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ol><li>创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。</li><li>索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。</li><li>当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。</li></ol><h4 id="使用情况"><a href="#使用情况" class="headerlink" title="使用情况"></a>使用情况</h4><ol><li>主键自动建立唯一索引</li><li>频繁作为查询条件的字段应该创建索引</li><li>查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找</li><li>查询中统计或者分组的字段；</li></ol><h4 id="不应该使用的情况"><a href="#不应该使用的情况" class="headerlink" title="不应该使用的情况"></a>不应该使用的情况</h4><ol><li>频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件</li><li>where条件里用不到的字段，不创建索引；</li><li>表记录太少，不需要创建索引；</li><li>数据范围小，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引</li></ol><h3 id="2-聚簇索引和非聚簇索引的区别"><a href="#2-聚簇索引和非聚簇索引的区别" class="headerlink" title="2. 聚簇索引和非聚簇索引的区别"></a>2. 聚簇索引和非聚簇索引的区别</h3><p>聚簇索引，就是将索引和数据放到一起，找到索引也就找到了数据，我们刚才看到的B+树索引就是一种聚簇索引，而非聚簇索引就是将数据和索引分开，查找时需要先查找到索引，然后通过索引中保存的主键回表找到相应的数据。InnoDB有且只有一个聚簇索引，而MyISAM中都是非聚簇索引。</p><p><strong>非聚簇索引不一定会回表查询</strong>,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.</p><h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol><li>聚簇索引可以把相关数据存放在一起，例如根据用户ID来聚集数据，这样可以最小化磁盘读取数据页</li><li>数据访问更快，因为数据和索引保存在同一个B+Tree中，因此聚簇索引比非聚簇索引的查找更快</li><li>使用覆盖索引扫描的查询可以直接使用页节点中的主键值</li></ol><h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><ol><li>聚簇数据最大限度的提高了I/O密集型应用的性能，但如果数据全部都放在内存中，则访问的顺序就没有那么重要了，聚簇索引也就没有那么优势了；</li><li>插入速度严重依赖于插入顺序。按照主键的顺序插入是加载数据到InnoDB表中速度最快的方式。但如果不是按照主键顺序加载数据，那么在加载完成后最好使用OPTIMIZE TABLE命令重新组织一下表。</li><li>更新聚簇索引列的代价很高，因为会强制InnoDB将每个被更新的行移动到新的位置。</li><li>基于聚簇索引的表在插入新行，或者主键被更新导致需要移动行的时候，可能面临“页分裂”的问题。当行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次分裂操作。页分裂会导致表占用更多的磁盘空间。</li><li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</li><li>二级索引（非聚簇索引）可能比想象的要更大，因为在二级索引的叶子节点包含了引用行的主键列。</li><li>二级索引访问需要两次索引查找，而不是一次。</li></ol><h4 id="顺序主键的缺点"><a href="#顺序主键的缺点" class="headerlink" title="顺序主键的缺点"></a>顺序主键的缺点</h4><p>对于高并发工作负载，在InnoDB中按主键顺序插入可能会造成明显的争用。主键的上界会成为“热点”。因为所有的插入都发生在这里，所以并发插入可能导致间隙锁竞争。另一个热点可能是auto_increment锁机制；如果遇到这个问题，则可能需要考虑重新设计表或者应用，或者更改innodb_autonc_lock_mode配置。</p><h3 id="3-唯一索引和主码索引的区别"><a href="#3-唯一索引和主码索引的区别" class="headerlink" title="3.  唯一索引和主码索引的区别"></a>3.  唯一索引和主码索引的区别</h3><ol><li>主键不允许空值，唯一索引允许空值</li><li>主键只允许一个，唯一索引允许多个</li><li>主键产生唯一的聚集索引，唯一索引产生唯一的非聚集索引</li></ol><h3 id="4-索引最左前缀匹配问题"><a href="#4-索引最左前缀匹配问题" class="headerlink" title="4. 索引最左前缀匹配问题"></a>4. 索引最左前缀匹配问题</h3><p>联合索引的排序有这么一个原则，从左往右依次比较大小</p><p>MySQL会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配</p><p>我们找到第一个满足条件的人之后，直接向右遍历就可以了，由于索引是有序的，所有满足条件的人都会聚集在一起。</p><p>而这种定位到最左边，然后向右遍历寻找，就是我们所说的最左前缀原则。</p><h3 id="5-hash索引和B-树索引的区别"><a href="#5-hash索引和B-树索引的区别" class="headerlink" title="5. hash索引和B+树索引的区别"></a>5. hash索引和B+树索引的区别</h3><ol><li>hash索引不能进行排序和范围查询。因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.</li><li>hash索引不支持模糊查询和联合索引的最左前缀匹配原则。因此hash函数对于aa和aab是没有相关性。</li><li>hash函数必须要回表查询。B+树索引可以通过聚集索引或覆盖索引不需要回表。</li><li>hash索引虽然等值查询快，但是不稳定。如果hash函数造成的碰撞次数较多，效率可能极差。</li></ol><h3 id="6-索引的底层实现（B-树，为何不采用红黑树，B树）"><a href="#6-索引的底层实现（B-树，为何不采用红黑树，B树）" class="headerlink" title="6. 索引的底层实现（B+树，为何不采用红黑树，B树）"></a>6. 索引的底层实现（B+树，为何不采用红黑树，B树）</h3><p>不适用红黑树，是因为红黑树需要通过旋转变色维护平衡，维护平衡的效率低，同时B+树可以降低高度，提高查找效率。</p><p>不使用B树，是因为<br>（1）非叶子节点不包含Data,这样每页能存更多的索引，深度比较低，查询速度快<br>（2）叶子节点包含所有内容,便于全局遍历.</p><p>红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用B+ Tree作为索引结构，这是因为使用B+树访问磁盘数据有更高的性能。</p><ul><li>B+树有更低的树高</li></ul><p>平衡树的树高<code>O(h)=O(logdN)O(h)=O(logdN)</code>,其中d为每个节点的出度。红黑树的出度为2，而B+ Tree的出度一般都非常大，所以红黑树的树高h很明显比B+Tree大非常多。</p><ul><li>磁盘访问原理</li></ul><p>操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次I/O就能完全载入一个节点。</p><p>如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+Tree相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以B+Tree更适合磁盘数据的读取。</p><ul><li>磁盘预读特性</li></ul><p>为了减少磁盘IO操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。</p><h2 id="七、-优化"><a href="#七、-优化" class="headerlink" title="七、 优化"></a>七、 优化</h2><ul><li>系统的吞吐量瓶颈往往处在数据库的访问速度上</li><li>随着引用程序的运行，数据库中的数据会越来越多</li></ul><h3 id="1-索引优化"><a href="#1-索引优化" class="headerlink" title="1. 索引优化"></a>1. 索引优化</h3><ol><li>全值匹配</li><li>最佳左前缀法则</li><li>不要在索引列上做任何操作，比如计算、使用函数、自动或手动进行类型转换，会导致索引失效，从而使查询转向全表扫描</li><li>存储引擎不能使用范围条件右边的索引列。</li><li>尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select *语句。</li><li>mysql在使用不等于（!=或者&lt;&gt;）的时候无法使用索引会导致全表扫描</li><li>is null，is not null 也无法使用索引。</li><li>like以通配符开头（like’%aaa’）mysql索引失效会变成全表扫描操作。</li></ol><h3 id="2-查询优化"><a href="#2-查询优化" class="headerlink" title="2. 查询优化"></a>2. 查询优化</h3><ol><li>查询缓存</li><li>用索引</li><li>优化关联查询：确保ON或者USING子句中的列上有索引。确保任何的GROUP BY 和ORDER BY中的表达式只涉及到一个表中的列。</li><li>优化COUNT()查询 使用近似值 </li><li>优化LIMIT分页 使用WHERE（尽量走索引）</li><li>优化UNION查询：经常需要手工地将WHERE,LIMIT,ORDER BY等子句”下推”到UNION的各个子查询中。除非确实需要服务器消除重复的行，否则就一定要使用UNION ALL，这一点很重要</li></ol><h3 id="3-库表结构优化"><a href="#3-库表结构优化" class="headerlink" title="3. 库表结构优化"></a>3. 库表结构优化</h3><ol><li>合适的结构类型<ol><li>使用可以存下你的数据的最小的数据类型</li><li>使用简单的数据类型。Int要比varchar类型在mysql处理上简单</li><li>尽可能的使用not null定义字段</li></ol></li><li>表的范式化和反范式化</li><li>表的垂直拆分和水平拆分</li></ol><h3 id="4-水平拆分与垂直拆分"><a href="#4-水平拆分与垂直拆分" class="headerlink" title="4. 水平拆分与垂直拆分"></a>4. 水平拆分与垂直拆分</h3><ul><li><p>水平拆分：通过建立结构相同的几张表分别储存数据。它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。</p></li><li><p>垂直拆分：将经常使用的字段放在一个单独的表中，分割后表记录之间是意义对应的关系。垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。</p><p>在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。</p></li></ul><h3 id="5-主从复制"><a href="#5-主从复制" class="headerlink" title="5. 主从复制"></a>5. 主从复制</h3><ol><li>确保数据安全：做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据的丢失。</li><li>提升I/O性能：随着日常生产中业务量越来越大,I/O访问频率越来越高，单机无法满足，此时做多库的存储，有效降低磁盘I/O访问的频率，提高了单个设备的I/O性能。</li><li>读写分离，用来解决数据库的<strong>读性能瓶颈</strong>，使数据库能支持更大的并发。主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。</li></ol><ul><li><strong>binlog 线程</strong> ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。</li><li><strong>I/O 线程</strong> ：负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Replay log）中。</li><li><strong>SQL 线程</strong> ：负责读取重放日志并重放其中的 SQL 语句。</li></ul><h3 id="6-doublewrite"><a href="#6-doublewrite" class="headerlink" title="6. doublewrite"></a>6. doublewrite</h3><p><a href="https://www.cnblogs.com/geaozhang/p/7241744.html">https://www.cnblogs.com/geaozhang/p/7241744.html</a></p><h2 id="八、存储引擎"><a href="#八、存储引擎" class="headerlink" title="八、存储引擎"></a>八、存储引擎</h2><h3 id="1-InnoDB"><a href="#1-InnoDB" class="headerlink" title="1. InnoDB"></a>1. InnoDB</h3><p>是MySQL默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其他存储引擎。</p><p>实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking防止幻影读。</p><p>主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。</p><p>内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。</p><p>支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取</p><h3 id="2-MyISAM"><a href="#2-MyISAM" class="headerlink" title="2. MyISAM"></a>2. MyISAM</h3><h3 id="3-比较"><a href="#3-比较" class="headerlink" title="3. 比较"></a>3. 比较</h3><ul><li>事务：InnoDB是事务型的，可以使用Commit和Rollback语句。</li><li>并发：MyISAM只支持表级锁，而InnoDB还支持行级锁。但是InnoDB的行锁，只是在WHERE的主键是有效的，非主键的WHERE都会锁全表的。</li><li>外键：InnoDB支持外键。MyISAM不支持</li><li>备份：InnoDB支持在线热备份。</li><li>崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复的速度也很慢。</li><li>其他特性：MyISAM支持压缩表和空间数据索引。</li></ul><h2 id="九-mysql执行原理"><a href="#九-mysql执行原理" class="headerlink" title="九 mysql执行原理"></a>九 mysql执行原理</h2><ol><li>连接模块进行连接</li><li>发送查询请求</li><li>先检查缓存，如果缓存命中，则返回结果</li><li>进行SQL解析，预处理和查询优化</li><li>请求存储引擎进行查询</li><li>返回结果</li></ol><h2 id="十、常用问题"><a href="#十、常用问题" class="headerlink" title="十、常用问题"></a>十、常用问题</h2><h3 id="1-MySQL批量插入遇上唯一索引的避免方法（避免导入重复数据）"><a href="#1-MySQL批量插入遇上唯一索引的避免方法（避免导入重复数据）" class="headerlink" title="1. MySQL批量插入遇上唯一索引的避免方法（避免导入重复数据）"></a>1. MySQL批量插入遇上唯一索引的避免方法（避免导入重复数据）</h3><ol><li>导入差异数据，忽略重复数据（IGNORE INTO）</li><li>导入并覆盖重复数据，（REPLACE INTO）</li><li>导入保留重复数据未指定字段（INSERT INTO ON DUPLICATE KEY UPDATE）</li></ol><h3 id="2-数据库连接池的作用"><a href="#2-数据库连接池的作用" class="headerlink" title="2. 数据库连接池的作用"></a>2. 数据库连接池的作用</h3><p>数据库连接池是程序启动时简历足够的数据库连接，并将这些组成一个连接池，有程序动态地对池中的连接进行申请，使用，释放</p><ol><li>资源重用，避免了数据库连接频繁建立、关闭的开销</li><li>更快的系统响应速度，直接从连接池中国呢获取连接，响应速度加快</li><li>控制资源的使用。如果不使用连接池，每次访问数据库都需要创建一个连接，这样系统的稳定性受系统连接需求影响很大，很容易产生资源浪费和高负载异常。连接池能够使性能最大化，将资源利用控制在一定的水平之下。</li><li>连接池能控制池中的连接数量，增强了系统在大量用户应用时的稳定性。</li></ol><h3 id="3-大小写敏感问题"><a href="#3-大小写敏感问题" class="headerlink" title="3. 大小写敏感问题"></a>3. 大小写敏感问题</h3><p>MySQL在Linux下数据库名、表名、列名、别名的大小写规则：</p><ul><li>数据库名与表名是严格区分大小写的;</li><li>表的别名是严格区分大小写的;</li><li>列名与列的别名在所有的情况下均是忽略大小写的;</li><li>变量名也是严格区分大小写的;</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一、事务&quot;&gt;&lt;a href=&quot;#一、事务&quot; class=&quot;headerlink&quot; title=&quot;一、事务&quot;&gt;&lt;/a&gt;一、事务&lt;/h2&gt;&lt;h3 id=&quot;1-什么是事务？4特征&quot;&gt;&lt;a href=&quot;#1-什么是事务？4特征&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="数据库原理" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="基础知识" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="数据库原理" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络知识点复习整理</title>
    <link href="http://yoursite.com/2021/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2021/03/02/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/</id>
    <published>2021-03-02T15:41:22.000Z</published>
    <updated>2021-03-19T06:12:57.445Z</updated>
    
    <content type="html"><![CDATA[<p>参考之前的笔记以及该<a href="https://leetcode-cn.com/leetbook/detail/">leetbook</a>整理。</p><h2 id="一、-协议层次及服务类型"><a href="#一、-协议层次及服务类型" class="headerlink" title="一、 协议层次及服务类型"></a>一、 协议层次及服务类型</h2><h3 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1. OSI七层模型"></a>1. OSI七层模型</h3><ol><li>应用层：该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。  报文（message）</li><li>表示层：使通信的应用程序能够解释交换数据的含义。该层提供的服务主要包括数据压缩，数据加密以及数据描述。</li><li>会话层：负责建立、管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。</li><li>传输层：为两台主机进程之间的通信提供服务。该服务并不针对某一特定的应用，多种应用可以使用同一个运输层服务。</li><li>网络层：两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网。网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送。</li><li>数据链路层：两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。</li><li>物理层：物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。</li></ol><h3 id="2-TCP-IP参考模型"><a href="#2-TCP-IP参考模型" class="headerlink" title="2. TCP/IP参考模型"></a>2. TCP/IP参考模型</h3><ol><li>应用层：将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。FTP、Telnet、DNS、SMTP等</li><li>传输层：其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。</li><li>网际互联层：负责相同或不同网络中计算机之间的通信。在网际互联层， IP 协议提供的是一个可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。</li><li>网络接入层：对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。</li></ol><h3 id="3-五层参考模型"><a href="#3-五层参考模型" class="headerlink" title="3. 五层参考模型"></a>3. 五层参考模型</h3><h3 id="4-OSI模型和TCP-IP模型比较"><a href="#4-OSI模型和TCP-IP模型比较" class="headerlink" title="4. OSI模型和TCP/IP模型比较"></a>4. OSI模型和TCP/IP模型比较</h3><ul><li>相同点：<ol><li>都采用了层次结构</li><li>都提供面向连接和无连接两种通信服务机制</li></ol></li><li>不同点：<ol><li>OSI七层，TCP/IP四层</li><li>OSI现有模型，后有协议规范，适用于描述各种网络。TCP/IP先有协议集在建立模型，不适用非TCP/IP网络。</li></ol></li></ul><h3 id="5-为什么TCP-IP没有会话层和表示层"><a href="#5-为什么TCP-IP没有会话层和表示层" class="headerlink" title="5. 为什么TCP/IP没有会话层和表示层"></a>5. 为什么TCP/IP没有会话层和表示层</h3><p>由于应用层，表示层，会话层都是在应用程序内部实现，最终的产出是一个应用数据包。应用程序之间时无法实现代码的抽象共享的。数据压缩加密及会话难以抽象成一个协议。</p><h3 id="6-数据如何在各层之间传输（数据的封装过程）"><a href="#6-数据如何在各层之间传输（数据的封装过程）" class="headerlink" title="6. 数据如何在各层之间传输（数据的封装过程）"></a>6. 数据如何在各层之间传输（数据的封装过程）</h3><p>在发送端主机，一个应用层报文被传送到运输层。在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变。运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报。该数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧，在物理层数据帧被封装成比特流，之后通过传输介质传送到对端。</p><h3 id="7-协议对应"><a href="#7-协议对应" class="headerlink" title="7. 协议对应"></a>7. 协议对应</h3><table><thead><tr><th>OSI</th><th>TCP/IP</th><th></th></tr></thead><tbody><tr><td>应用层（application）</td><td>应用层</td><td>HTTP，FTP，SMTP，DNS</td></tr><tr><td>表示层（presentation）</td><td></td><td></td></tr><tr><td>会话层（Session）</td><td></td><td></td></tr><tr><td>传输层（transport）</td><td>传输层</td><td>TCP，UDP</td></tr><tr><td>网络层（Network）</td><td>网络层</td><td>IP，ICMP，ARP，RIP，IGMP</td></tr><tr><td>数据链路层（data link）</td><td>数据链路层</td><td>PPP、Ethernet</td></tr><tr><td>物理层（Physical）</td><td></td><td>IEEE802.1A, IEEE802.3-802.11</td></tr></tbody></table><h2 id="二、应用层"><a href="#二、应用层" class="headerlink" title="二、应用层"></a>二、应用层</h2><h2 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h2><h3 id="1-HTTP报文格式"><a href="#1-HTTP报文格式" class="headerlink" title="1. HTTP报文格式"></a>1. HTTP报文格式</h3><h4 id="1-1-请求报文"><a href="#1-1-请求报文" class="headerlink" title="1.1 请求报文"></a>1.1 请求报文</h4><ul><li>请求行： 方法 sp URL sp 版本 cr lf（回车+换行）</li><li>首部行：首部字段名 sp 值 cr lf    （n个）</li><li>cr lf</li><li>实体主体（post时使用）</li></ul><h4 id="1-2-响应报文"><a href="#1-2-响应报文" class="headerlink" title="1.2 响应报文"></a>1.2 响应报文</h4><ul><li>状态行：版本 sp 状态码 sp 短语 cr lf</li><li>首部行：首部字段名 sp 值 cr lf    （n个）</li><li>cr lf</li><li>实体主体：报文的主要部分，它包含了所请求的对象。</li></ul><h3 id="2-HTTP首部行"><a href="#2-HTTP首部行" class="headerlink" title="2. HTTP首部行"></a>2. HTTP首部行</h3><p>通用头部、请求头部、响应头部、实体头部</p><ol><li>通用头部<ol><li>Cache-Control,指出是否使用缓存机制</li><li>Connection，优先使用的连接类型</li><li>Date，报文创建时间</li><li>Upgrade，要求服务器升级到高版本协议</li><li>Transfer-Encoding，用来改变报文格式</li></ol></li><li>请求头部<ol><li>Accept，告诉服务器自己允许哪些媒体类型</li><li>Accept-charset， 可接受的字符集</li><li>Accept-Encoding，可接受的编码方式</li><li>Accept-Language，可以接受的语言</li><li>Authorization，表示HTTP中需要认证资源的认证信息</li><li>Host，服务器的域名及监听的端口号</li><li>User-Agent，浏览器的身份标识</li></ol></li><li>响应头部<ol><li>Server，服务器信息</li><li>Location，重定向后的URL</li><li>Age，创建响应的时间</li></ol></li><li>实体头部<ol><li>Content-Length，返回内容的字节长度</li><li>Content-encoding，返回内容的编码方式</li><li>Content-Language，响应体的语言</li><li>Content-Type，返回内容的MIME类型</li><li>Last-Modified，请求资源的最后修改时间</li><li>Expires，请求资源的过期时间</li></ol></li></ol><h3 id="3-HTTP方法"><a href="#3-HTTP方法" class="headerlink" title="3. HTTP方法"></a>3. HTTP方法</h3><ul><li>HTTP/1.0定义了三种请求方法：GET、POST、HEAD</li><li>HTTP/1.1增加了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE、CONNECT</li></ul><ol><li>GET：请求指定页面信息，并返回具体内容。通常只用于读取数据。</li><li>POST：向指定资源提交数据进行处理请求（例如提交表单或上传文件）。数据被包含在请求体中。post请求可能会导致新的资源的建立或已有资源的更改。</li><li>HEAD：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头。</li><li>PUT：替换指定的资源，没有就新增。</li><li>DELETE：请求服务器删除指定资源</li><li>CONNECT：将服务器作为代理，让服务器代替用户进行访问。</li><li>OPTIONS：服务器返回指定资源所支持的方法</li><li>TRACE：回显服务器收到的请求数据。</li><li>PATCH：对PUT方法的补充，对已知资源进行局部更新</li></ol><h3 id="4-状态码"><a href="#4-状态码" class="headerlink" title="4. 状态码"></a>4. 状态码</h3><table><thead><tr><th>分类</th><th>描述</th></tr></thead><tbody><tr><td>1XX</td><td>指示信息，表示请求正在处理</td></tr><tr><td>2XX</td><td>成功，表示请求被处理完毕</td></tr><tr><td>3XX</td><td>重定向，要完成的请求需要进行附加操作</td></tr><tr><td>4XX</td><td>客户端错误，请求有语法错误或请求无法实现</td></tr><tr><td>5XX</td><td>服务器错误，服务器处理请求出现错误</td></tr></tbody></table><table><thead><tr><th>状态码</th><th>英文描述</th><th>中文描述</th></tr></thead><tbody><tr><td>100</td><td>continue</td><td>继续，客户端继续处理请求</td></tr><tr><td>101</td><td>switching protocol</td><td>切换协议。服务器根据客户端的请求切换到更高级的协议</td></tr><tr><td>200</td><td>OK</td><td>请求成功</td></tr><tr><td>201</td><td>Created</td><td>请求实现并且新的资源根据请求建立</td></tr><tr><td>204</td><td>No Content</td><td>服务器成功处理了请求，但不需要返回任何实体内容</td></tr><tr><td>301</td><td>Moved Permanently</td><td>永久移动。请求的资源已被永久地移动到新 URI，返回信息会包含新的 URI，浏览器会自动定向到新 URI</td></tr><tr><td>302</td><td>Found</td><td>临时移动。与 301 类似。但资源只是临时被移动，客户端应继续使用原有URI</td></tr><tr><td>304</td><td>Not Modified</td><td>未修改。如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码</td></tr><tr><td>400</td><td>Bad Request</td><td>客户端请求的语法错误，服务器无法理解；请求的参数有误</td></tr><tr><td>401</td><td>Unauthorized</td><td>当前请求需要用户验证</td></tr><tr><td>403</td><td>Forbidden</td><td>服务器已经理解请求，但是拒绝执行它</td></tr><tr><td>404</td><td>Not Found</td><td>请求失败，请求所希望得到的资源未被在服务器上发现</td></tr><tr><td>500</td><td>Internal Server</td><td>服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理</td></tr><tr><td>501</td><td>Not Implemented</td><td>服务器不支持当前请求所需要的某个功能</td></tr><tr><td>502</td><td>Bad Gateway</td><td>作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到无效的响应</td></tr></tbody></table><h4 id="状态码301和302的区别"><a href="#状态码301和302的区别" class="headerlink" title="状态码301和302的区别"></a>状态码301和302的区别</h4><ol><li>301永久移动：请求的资源已被永久的移动到新的URI，旧的地址已经被永久的删除了。返回信息会包括新的URI，浏览器会自动定向到新的URI。今后新的请求都应使用新的URI代替。</li><li>302临时移动：客户端拿到服务端的响应消息后会跳转到一个新的 URL 地址。但资源只是临时被移动，旧的地址还在，客户端应继续使用原有URI。</li></ol><h3 id="5-GET和POST的区别"><a href="#5-GET和POST的区别" class="headerlink" title="5. GET和POST的区别"></a>5. GET和POST的区别</h3><ol><li>GET提交的数据会放在URL之后，并且请求参数会被完整的保留在浏览器的记录里。由于参数直接暴露在URL中，可能会存在安全问题，因此往往用于获取资源信息。而post参数放在请求主体中，并且参数不会被保留，相比get更安全，主要用于修改服务器上的资源。</li><li>get请求只支持URL编码，post请求支持多种编码格式。</li><li>get只支持ASCII字符格式的参数，post方法没有限制。</li><li>get提交的数据大小有限制（受浏览器限制），而post提交的数据没限制。</li><li>get方法产生一个数据包，post方法产生两个（并不是所有浏览器都产生两个）。</li></ol><p>PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）</p><p>Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源</p><h3 id="6-GET的长度限制"><a href="#6-GET的长度限制" class="headerlink" title="6. GET的长度限制"></a>6. GET的长度限制</h3><p>HTTP 中的 GET 方法是通过 URL 传递数据的，而 URL 本身并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器。由于 POST 方法请求参数在请求主体中，理论上讲，post 方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。</p><h3 id="7-HTTP的报文长度"><a href="#7-HTTP的报文长度" class="headerlink" title="7. HTTP的报文长度"></a>7. HTTP的报文长度</h3><p>当响应消息中存在 Content-Length 字段时，我们可以直接根据这个值来判断数据是否接收完成，例如客户端向服务器请求一个静态页面或者一张图片时，服务器能够很清楚的知道请求内容的大小，因此可以通过消息首部字段 Content- Length 来告诉客户端需要接收多少数据。</p><p>如果服务器预先不知道请求内容的大小，例如加载动态页面的时候，就需要使用 Transfer-Encoding: chunked 的方式来代替 Content-Length。分块传输编码（Chunked transfer encoding）是 HTTP/1.1 中引入的一种数据传输机制，其允许 HTTP 由服务器发送给客户端的数据可以分成多个部分，当数据分解成一系列数据块发送时，服务器就可以发送数据而不需要预先知道发送内容的总大小，每一个分块包含十六进制的长度值和数据，最后一个分块长度值为0，表示实体结束，客户机可以以此为标志确认数据已经接收完毕。</p><h3 id="8-HTTP长链接和短链接"><a href="#8-HTTP长链接和短链接" class="headerlink" title="8. HTTP长链接和短链接"></a>8. HTTP长链接和短链接</h3><ul><li>长连接：服务器在响应后保持该 TCP 连接打开，在同一个客户机与服务器之间的后续请求和响应报文可通过相同的连接进行传送。甚至位于同一台服务器的多个 Web 页面在从该服务器发送给同一个客户机时，可以在单个持久 TCP 连接上进行。多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。</li><li>短链接：浏览器每次 发起 HTTP 请求都要与服务器创建一个新的 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。然而创建和关闭连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在用户数目较多的Web网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。</li></ul><h3 id="9-MIME（多用途的网际邮件扩充协议）"><a href="#9-MIME（多用途的网际邮件扩充协议）" class="headerlink" title="9. MIME（多用途的网际邮件扩充协议）"></a>9. MIME（多用途的网际邮件扩充协议）</h3><ul><li>text/html HTML页面</li><li>text/plain 无格式文本</li><li>application/postscript Postscript文档</li><li>image/gif GIF格式编码的二进制图像</li><li>image/png PNG格式编码的二进制图像</li><li>image/jpeg JPEG格式编码的二进制图像</li></ul><p>压缩包、css、xml</p><h3 id="10-HTTP如何保存用户状态"><a href="#10-HTTP如何保存用户状态" class="headerlink" title="10. HTTP如何保存用户状态"></a>10. HTTP如何保存用户状态</h3><p>假如某个特定的客户机在短时间内两次请求同一个对象，服务器并不会因为刚刚为该用户提供了该对象就不再做出反应，而是重新发送该对象，就像该服务器已经完全忘记不久之前所做过的是一样。因为一个 HTTP 服务器并不保存关于客户机的任何信息，所以我们说 HTTP 是一个无状态协议。</p><ul><li><p>Session</p><p>在客户端第一次向服务器发送 HTTP 请求后，服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来，然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端 Cookie 中，之后每次该浏览器发送 HTTP 请求都会带上 Cookie 中的 SessionId 到服务器，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。</p><p>优点：安全性高，因为状态信息保存在服务器端。</p><p>缺点：由于大型网站往往采用的是分布式服务器，浏览器发送的 HTTP 请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。</p><p>【解决方法：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息】</p></li><li><p>Cookie</p><p>当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。</p><p>优点：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。</p><p>缺点：1. 该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。2。浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。</p><p>拓展：Cookie被禁用了怎么办？</p><p>​    若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。</p></li><li><p>token</p><p>验证请求是根据sessionid 到数据库中查找session表的，而数据库操作是服务端常见的性能瓶颈，尤其是当用户量比较大的时候。</p><p>token 简单来说，就是包含了 数据信息 和 校验信息的 数据包。Session 机制是把 数据信息（比如session表）放到 服务端，<strong>服务端数据是客户无法篡改的</strong>，从而保证验证的 可靠性。</p><p>而 token机制 数据信息 直接传给 客户端，客户每次请求再携带过来给服务端。服务端无需查找数据库，直接根据token里面的数据信息进行校验。</p><p>Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。</p></li></ul><h3 id="11-HTTP和HTTPS的区别"><a href="#11-HTTP和HTTPS的区别" class="headerlink" title="11. HTTP和HTTPS的区别"></a>11. HTTP和HTTPS的区别</h3><ol><li>HTTP协议以明文方式发送内容，数据都是为加密的，安全性较差。HTTPS传输过程数据是加密的，安全性较好</li><li>HTTP用80端口，HTTPS用443端口</li><li>HTTPS需要到数字认证机构（CA）申请证书</li><li>HTTP响应比HTTPS快，主要因为HTTP使用TCP3次握手连接；而HTTPS除了3次握手，还需要经历SSL协商过程</li></ol><h3 id="12-HTTPS的加密方式"><a href="#12-HTTPS的加密方式" class="headerlink" title="12. HTTPS的加密方式"></a>12. HTTPS的加密方式</h3><p>HTTPS采用对称加密与非对称加密相结合的方式。首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点（无法确定对方身份），HTTPS 采用证书来进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。</p><h3 id="13-客户端为什么信任第三方证书"><a href="#13-客户端为什么信任第三方证书" class="headerlink" title="13. 客户端为什么信任第三方证书"></a>13. 客户端为什么信任第三方证书</h3><p>假设中间人篡改了证书原文，由于他没有 CA 机构的私钥，所以无法得到此时加密后的签名，因此无法篡改签名。客户端浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书被中间人篡改，证书不可信，从而终止向服务器传输信息。</p><p>上述过程说明证书无法被篡改，我们考虑更严重的情况，例如中间人拿到了 CA 机构认证的证书，它想窃取网站 A 发送给客户端的信息，于是它成为中间人拦截到了 A 传给客户端的证书，然后将其替换为自己的证书。此时客户端浏览器收到的是被中间人掉包后的证书，但由于证书里包含了客户端请求的网站信息，因此客户端浏览器只需要把证书里的域名与自己请求的域名比对一下就知道证书有没有被掉包了。</p><h3 id="14-HTTP和HTTPS的连接过程"><a href="#14-HTTP和HTTPS的连接过程" class="headerlink" title="14. HTTP和HTTPS的连接过程"></a>14. HTTP和HTTPS的连接过程</h3><ul><li><p>HTTP</p><p>使用TCP作为传输协议，其默认工作在 TCP 协议 80 端口，HTTP 客户机发起一个与服务器的 TCP 连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问 TCP。客户机从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文。类似地，服务器也是从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文。其通信内容以明文的方式发送，不通过任何方式的数据加密。当通信结束时，客户端与服务器关闭连接。</p></li><li><p>HTTPS</p><blockquote><p>以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。</p><ol><li>客户端发起一个HTTPS请求，并连接到服务器的443端口，提供自身支持的算法列表和密钥长度等</li><li>服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其它密钥组件一同发送给客户端。</li><li>服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。</li><li>最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。</li><li>SSL 第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为 pre_master_secre，并且该报文是经过证书中的公钥加密过的。</li><li>紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secre 加密的。</li><li>客户端向服务端发送一个 finish 报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。</li><li>服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文</li></ol><p>当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。</p></blockquote></li></ul><h3 id="15-HTTP1-0、1-1的区别"><a href="#15-HTTP1-0、1-1的区别" class="headerlink" title="15. HTTP1.0、1.1的区别"></a>15. HTTP1.0、1.1的区别</h3><ul><li><p>缓存处理：在 HTTP/1.0 中主要使用 header 里的 if-modified-Since, Expries 来做缓存判断的标准。而 HTTP/1.1 请求头中添加了更多与缓存相关的字段，从而支持更为灵活的缓存策略，例如 Entity-tag, If-Unmodified-Since, If-Match, If-None-Match 等可供选择的缓存头来控制缓存策略。</p></li><li><p>节约带宽： 当客户端请求某个资源时，HTTP/1.0 默认将该资源相关的整个对象传送给请求方，但很多时候可能客户端并不需要对象的所有信息。而在 HTTP/1.1 的请求头中引入了 range 头域，它允许只请求部分资源，其使得开发者可以多线程请求某一资源，从而充分的利用带宽资源，实现高效并发。</p></li><li><p>错误通知的管理：HTTP/1.1 在 1.0 的基础上新增了 24 个错误状态响应码，例如 414 表示客户端请求中所包含的 URL 地址太长，以至于服务器无法处理；410 表示所请求的资源已经被永久删除。</p></li><li><p>Host 请求头：早期 HTTP/1.0 中认为每台服务器都绑定一个唯一的 IP 地址并提供单一的服务，请求消息中的 URL 并没有传递主机名。而随着虚拟主机的出现，一台物理服务器上可以存在多个虚拟主机，并且它们共享同一个 IP 地址。为了支持虚拟主机，HTTP/1.1 中添加了 host 请求头，请求消息和响应消息中应声明这个字段，若请求消息中缺少该字段时服务端会响应一个 404 错误状态码。</p></li><li><p>长连接：HTTP/1.0 默认浏览器和服务器之间保持短暂连接，浏览器的每次请求都需要与服务器建立一个 TCP 连接，服务器完成后立即断开 TCP 连接。HTTP/1.1 默认使用的是持久连接，其支持在同一个 TCP 请求中传送多个 HTTP 请求和响应。此之前的 HTTP 版本的默认连接都是使用非持久连接，如果想要在旧版本的 HTTP 协议上维持持久连接，则需要指定 Connection 的首部字段的值为 Keep-Alive。</p></li></ul><h3 id="16-HTTP-1-X和HTTP-2-0的区别"><a href="#16-HTTP-1-X和HTTP-2-0的区别" class="headerlink" title="16. HTTP/1.X和HTTP/2.0的区别"></a>16. HTTP/1.X和HTTP/2.0的区别</h3><ul><li>相比于 HTTP/1.X 的文本（字符串）传送， HTTP/2.0 采用二进制传送。客户端和服务器传输数据时把数据分成帧，帧组成了数据流，流具有流 ID 标识和优先级，通过优先级以及流依赖能够一定程度上解决关键请求被阻塞的问题。</li><li>HTTP/2.0 支持多路复用。因为流 ID 的存在， 通过同一个 HTTP 请求可以实现多个 HTTP 请求传输，客户端和服务器可以通过流 ID 来标识究竟是哪个流从而定位到是哪个 HTTP 请求。</li><li>HTTP/2.0 头部压缩。HTTP/2.0 通过 gzip 和 compress 压缩头部然后再发送，同时通信双方会维护一张头信息表，所有字段都记录在这张表中，在每次 HTTP 传输时只需要传头字段在表中的索引即可，大大减小了重传次数和数据量。</li><li>HTTP/2.0 支持服务器推送。 服务器在客户端未经请求许可的情况下，可预先向客户端推送需要的内容，客户端在退出服务时可通过发送复位相关的请求来取消服务端的推送。</li></ul><h3 id="17-HTTP-3"><a href="#17-HTTP-3" class="headerlink" title="17. HTTP/3"></a>17. HTTP/3</h3><p>http1.0采用的是非持续连接的方式，一次连接只能处理一次请求，如何一个用户多次向服务器提供请求，就是因为多次连接造成大量的交付时延。</p><p>http1.1为了解决这个问题，开始支持持久连接，一次TCP连接可以进行多次http请求。同时增加了更多的缓存处理，带宽优化及网络连接的使用（可以设置请求范围），错误通知的管理，Host头处理（在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname））</p><p>http2.0在http1.0的基础上增加了多路复用（避免第一个请求阻塞后，后面的请求都需要等待，这也就是队头阻塞(Head of line blocking)）同时增加了新的二进制格式，Header压缩，服务端推送功能</p><p>HTTP/3 采用QUIC+UDP，上层仍然是http/2，建立连接快，正常只需要 1 RTT 即可建立连接。</p><h3 id="18-抓包的过程（代理）"><a href="#18-抓包的过程（代理）" class="headerlink" title="18. 抓包的过程（代理）"></a>18. 抓包的过程（代理）</h3><h3 id="19-URL和URI的区别（子集）"><a href="#19-URL和URI的区别（子集）" class="headerlink" title="19. URL和URI的区别（子集）"></a>19. URL和URI的区别（子集）</h3><h3 id="20-socket套接字有哪些（流、数据包、原始）"><a href="#20-socket套接字有哪些（流、数据包、原始）" class="headerlink" title="20. socket套接字有哪些（流、数据包、原始）"></a>20. socket套接字有哪些（流、数据包、原始）</h3><h3 id="21-DNS的作用和原理（UDP）"><a href="#21-DNS的作用和原理（UDP）" class="headerlink" title="21. DNS的作用和原理（UDP）"></a>21. DNS的作用和原理（UDP）</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><p>通常我们有两种方式识别主机：通过主机名或者 IP 地址。人们喜欢便于记忆的主机名表示，而路由器则喜欢定长的、有着层次结构的 IP 地址。为了满足这些不同的偏好，我们就需要一种能够进行主机名到 IP 地址转换的目录服务，域名系统作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。</p><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>（1）查询浏览器，操作系统缓存；<br>（2）查询本地域名服务器；<br>（3）查询根域名服务器；<br>（4）查询主域名服务器；<br>（5）查询对方的域名服务器；<br>（6）找到ip；</p><h3 id="22-其他协议"><a href="#22-其他协议" class="headerlink" title="22. 其他协议"></a>22. 其他协议</h3><h4 id="22-1-FTP"><a href="#22-1-FTP" class="headerlink" title="22.1 FTP"></a>22.1 FTP</h4><p>FTP使用两个并行的TCP连接来传输数据，一个TCP（21号端口）被称为控制连接，用来传输FTP命令；一个TCP（20号端口）连接称为数据连接用于传输文件数据</p><h4 id="22-2-SMTP"><a href="#22-2-SMTP" class="headerlink" title="22.2 SMTP"></a>22.2 SMTP</h4><p>简单邮件传输服务。TCP，25端口</p><h3 id="23-网页解析过程"><a href="#23-网页解析过程" class="headerlink" title="23. 网页解析过程"></a>23. 网页解析过程</h3><ol><li><strong>DNS解析</strong>：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址。</li><li><strong>TCP 连接</strong>：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接后，浏览器便可以将 HTTP 请求数据发送给服务器了。</li><li><strong>发送HTTP请求</strong>：浏览器向 Web 服务器发起一个 HTTP 请求，HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个索要网页的请求。</li><li><strong>处理请求并返回</strong>：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。</li><li><strong>浏览器渲染</strong>：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。</li><li><strong>断开连接</strong>：客户端和服务器通过四次挥手终止 TCP 连接。</li></ol><h3 id="24-（找自己IP（ICMP、UDP、IP、以太网），找网关MAC（DNS，ARP），TCP，HTTP）"><a href="#24-（找自己IP（ICMP、UDP、IP、以太网），找网关MAC（DNS，ARP），TCP，HTTP）" class="headerlink" title="24. （找自己IP（ICMP、UDP、IP、以太网），找网关MAC（DNS，ARP），TCP，HTTP）"></a>24. （找自己IP（ICMP、UDP、IP、以太网），找网关MAC（DNS，ARP），TCP，HTTP）</h3><h4 id="DHCP、UDP、IP和以太网（找本机IP）"><a href="#DHCP、UDP、IP和以太网（找本机IP）" class="headerlink" title="DHCP、UDP、IP和以太网（找本机IP）"></a>DHCP、UDP、IP和以太网（找本机IP）</h4><p>DHCP四个步骤中仅有最后两个步骤是实际必要的。</p><ol><li>主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67（DHCP服务器）和源端口68（DHCP客户）的UDP报文段中。</li><li>该报文段被放入一个具有广播IP目的地址（255.255.255.255）和源IP地址（0.0.0.0)的IP数据报中，因为主机还没有一个IP地址。</li><li>该IP数据报被放置在以太网帧中，该MAC帧具有目的MAC地址（FF:FF:FF:FF:FF:FF),将该帧广播到交换机连接的所有设备(顺利的话也包括DHCP服务器)；该帧的源MAC地址时主机的MAC地址。</li><li>该帧是第一个由主机发送到以太网交换机中的帧。该交换机在所有的出端口广播入帧。</li><li>DHCP服务器的接口受到该帧，不断向上解析得到IP、UDP、DHCP报文，之后生成DHCP的ACK报文，该报文包括IP地址（CIDR分配策略），DNS服务器的IP地址、默认网关路由器的IP地址、子网掩码。将DHCP的ACK报文放入UDP报文段中，UDP报文段被放入IP数据报中，IP数据报在被放入一个以太网帧中。源MAC地址是服务器接口的MAC地址，目的MAC地址是主机MAC地址。</li><li>以太网帧发送到交换机中，由于交换机是自学习的（记录每个接口对应的MAC地址），并且受到过主机的以太网帧，所以交换机仅向主机接口转发该帧。</li><li>主机收到帧后，提取出IP数据报，取出UDP报文段，取出ACK报文。DHCP客户端记录下他的IP地址和他的DNS服务器的IP地址。并在<strong>IP转发表</strong>中安装默认网关的地址，主机会向网关发送目的地址为其子网以外的所有数据报。</li></ol><h4 id="DNS、ARP（找网关MAC地址"><a href="#DNS、ARP（找网关MAC地址" class="headerlink" title="DNS、ARP（找网关MAC地址)"></a>DNS、ARP（找网关MAC地址)</h4><ol><li>主机会通过浏览器生成一个TCP套接字，用于向网站发送HTTP请求，但是需要知道网站的IP地址。</li><li>主机的操作系统生成一个DNS查询报文，将网站的域名放入DNS报文的问题段中。将该报文放入一个目的端口号为53（DNS服务器）的UDP报文段中。该报文段被放入IP目的地址为DNS服务器，源地址为主机IP地址的IP数据报中。</li><li>数据报会放入到以太网帧中。该帧将发送到网关路由器。但是主机通过DHCP过程只知道网关路由器的IP地址，不知道网关路由器的MAC地址。为了获取网关的MAC地址，需要使用ARP协议。</li><li>主机生成一个具有目的IP地址为网关IP的ARP查询报文。放入到一个具有广播地址（FF:FF:FF:FF:FF:FF)的以太网帧中，并向交换机发送这个广播帧，交换机将帧发送给所有连接的设备，包括网关路由器。</li><li>网关在收到该帧后，发现目标IP与自己IP匹配，所以要发送一个ARP回答，指示自己的MAC地址对应自己的IP地址。将ARP回答放入以太网帧中，目的地址为主机的MAC地址，向交换机发送该帧，由交换机发送给主机。</li><li>主机收到该帧并抽取网关路由器的MAC地址，继续DNS解析过程。</li><li>将包含DNS查询报文的数据报放入目的地址为网关MAC地址的以太网帧中，通过交换机发送给网关路由器。主机报文的IP目的地址是DNS服务器，MAC目的地址是网关服务器。</li><li>网关接收到DNS查询的IP数据报后，根据IP数据报的目的地址选择转发给响应的路由器。</li><li>路由器收到IP数据报后，根据目的地址和转发表确定出接口，根据内部网关协议（RIP、OSPF）和外部网关协议（BGP）配置路由器到DNS的路由表项（路由选择）。</li><li>DNS服务器收到数据报后，抽取DNS查询报文。并在DNS库中查找域名。</li><li>找到包含对应域名的IP地址的DNS源记录后，向主机发送一个包含域名到IP地址映射的DNS回答报文，将该DNS回答报文放入UDP报文段、IP数据报中，通过路由器反转发给网关路由器，经过交换机到主机。</li><li>主机从报文中抽取服务器的IP地址。</li></ol><h4 id="TCP、HTTP"><a href="#TCP、HTTP" class="headerlink" title="TCP、HTTP"></a>TCP、HTTP</h4><ol><li>有了服务器的IP地址之后，便生成TCP套接字，用该套接字向服务器发送HTTP GET报文。</li><li>建立HTTP连接需要进行TCP连接，进行三次握手</li><li>建立连接后发送HTTP的GET报文，将报文放入TCP报文段的载荷中，然后生成IP数据报送往服务器。</li><li>服务器从TCP套接字中读取报文，生成HTTP响应报文，将页面内容放入HTTP响应体中，发送到主机。</li><li>浏览器收到HTTP响应报文后抽取Web页面内容进行渲染，显示web页面。</li></ol><h2 id="三、运输层"><a href="#三、运输层" class="headerlink" title="三、运输层"></a>三、运输层</h2><h3 id="1-三次握手和四次挥手机制"><a href="#1-三次握手和四次挥手机制" class="headerlink" title="1. 三次握手和四次挥手机制"></a>1. 三次握手和四次挥手机制</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>三次握手是TCP连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：</p><ol><li>首先客户端向服务器发送一个SYN包，并等待服务器确认。<ul><li>标志位SYN置位，表示请求建立连接。</li><li>序列号Seq=x（随机选择）。</li><li>客户端进入SYN-SENT阶段。</li></ul></li><li>服务器接收到客户端发来的SYN包之后，对该包进行确认结束LISTEN阶段，并返回一段TCP报文。<ol><li>标志位SYN和ACK置位。表示确认客户端的报文Seq序号有效，服务器能正常接受客户端发送的数据，并同意建立连接。</li><li>序列号Seq=y。</li><li>确认号Ack=x+1，表示收到客户端的序号Seq并将其值加1作为确认号Ack的值。随后服务器端进入SYN-RECV状态。</li></ol></li><li>客户端接收到SYN+ACK包之后，明确了从客户端到服务器的数据传输是正常的，从而结束SYN-SENT阶段。并返回最后一段TCP报文。<ol><li>标识位为ACK，表示确认收到服务器端同意连接的信号。</li><li>序列号为Seq=x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值。</li><li>确认号为Ack=y+1，表示收到服务器端的序列号Seq，将其值加1作为自己确认号的值。</li><li>随后客户端进入ESTABLISHED阶段。</li></ol></li></ol><p>当服务器收到来自客户端的报文之后，得知从服务器到客户端的数据传输是正常的，从而结束SYN-RECV阶段，进入ESTABLISH阶段，完成三次握手。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>四次挥手是TCP连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束ESTABLISH阶段。</p><ol><li><p>客户端向服务器发送一段TCP报文表明其想要释放TCP连接。</p><ol><li>标志位为FIN，表示请求释放连接</li><li>序列号为Seq=u，</li><li>随后客户端进入FIN-WAIT-1阶段，即半关闭状态，并且停止向服务器端发送数据。</li></ol></li><li><p>服务器接收到客户端接收请求断开连接的FIN报文后，结束ESTABLISH阶段，进入CLOST-WAIT阶段并返回一段报文。</p><ol><li>标志位为ACK，表示接收到客户端释放连接的请求。</li><li>序列号为Seq=v，</li><li>确认号为Ack=u+1，表示是在接收到客户端报文的基础上，将其序列号加1作为本段报文的确认号。</li></ol><p>客户端收到服务器发送过来的TCP报文后，确认服务器已经收到了客户端连接释放的请求。随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段。</p></li><li><p>服务器端在发出ACK确认报文之后，服务器端会将遗留的待传数据传送给客户端，待传输完成后结束CLOSE-WAIT阶段，准备释放服务器到客户端方向上的连接，再次向客户端发送一段TCP报文，其中，</p><ol><li>标志位为FIN和ACK，表示准备好释放连接了</li><li>序列号为Seq=w，</li><li>确认号为Ack=u+1，表示是在接收到客户端报文的基础上，将其序列号加1作为本段报文的确认号。</li></ol><p>随后服务器端结束CLOST-WAIT阶段，进入LAST-WAIT阶段，并且停止向客户端发送数据。</p></li><li><p>客户端收到服务器端发来的TCP报文，确认了服务器已经做好释放连接的准备，于是结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，向服务器发送一段报文，</p><ol><li>标志位为ACK，表示接收到释放连接的请求。</li><li>序列号为Seq=u+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值。</li><li>确认号为w+1，表示是在接收到客户端报文的基础上，将其序列号加1作为本段报文的确认号。</li></ol><p>随后客户端在TIME-WAIT阶段等待2MSL。服务器收到来自客户端的报文之后结束LAST-ACK阶段，进入CLOSE阶段。由此正式结束服务器端到客户端方向上的连接，客户端等待完2MSL时间后，结束TIME-WAIT阶段，进入CLOSE阶段，由此完成四次挥手。</p></li></ol><h3 id="2-如果每次握手的时候每次握手信息对方没有收到怎么办"><a href="#2-如果每次握手的时候每次握手信息对方没有收到怎么办" class="headerlink" title="2. 如果每次握手的时候每次握手信息对方没有收到怎么办"></a>2. 如果每次握手的时候每次握手信息对方没有收到怎么办</h3><ol><li><p>若第一次握手服务器未接收到客户端请求建立连接的数据包时，服务器不会进行任何相应的动作，而客户端由于在一段时间内没有收到服务器发来的确认报文， 因此会等待一段时间后重新发送 SYN 同步报文，若仍然没有回应，则重复上述过程直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回 -1。</p></li><li><p>若第二次握手客户端未接收到服务器回应的 ACK 报文时，客户端会采取第一次握手失败时的动作，这里不再重复，而服务器端此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文。</p></li><li><p>若第三次握手服务器未接收到客户端发送过来的 ACK 报文，同样会采取类似于客户端的超时重传机制，若重传次数超过限制后仍然没有回应，则 accep() 系统调用返回 -1，服务器端连接建立失败。但此时客户端认为自己已经连接成功了，因此开始向服务器端发送数据，但是服务器端的 accept() 系统调用已返回，此时没有在监听状态。因此服务器端接收到来自客户端发送来的数据时会<strong>发送 RST 报文</strong>给客户端，消除客户端单方面建立连接的状态。</p></li></ol><h3 id="3-为什么要进行三次握手，两次可以吗"><a href="#3-为什么要进行三次握手，两次可以吗" class="headerlink" title="3. 为什么要进行三次握手，两次可以吗"></a>3. 为什么要进行三次握手，两次可以吗</h3><p>三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而<strong>服务器并不知道客户端是否能够收到自己发送的数据</strong>。</p><p>我们知道网络往往是非理想状态的（存在丢包和延迟），当客户端发起创建连接的请求时，如果服务器直接创建了这个连接并返回包含 SYN、ACK 和 Seq 等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直接收不到返回的数据包。由于客户端可能设置了一个超时时间，一段时间后就关闭了连接建立的请求，再重新发起新的请求，而服务器端是不知道的，<strong>如果没有第三次握手告诉服务器客户端能否收到服务器传输的数据的话，服务器端的端口就会一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接</strong>。长此以往， 这样的端口越来越多，就会造成服务器开销的浪费。</p><h3 id="4-为什么要4次挥手"><a href="#4-为什么要4次挥手" class="headerlink" title="4. 为什么要4次挥手"></a>4. 为什么要4次挥手</h3><p>释放 TCP 连接时之所以需要四次挥手，是因为 FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的。 当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文。当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。</p><h3 id="5-CLOSE-WAIT和TIME-WAIT的意义"><a href="#5-CLOSE-WAIT和TIME-WAIT的意义" class="headerlink" title="5. CLOSE-WAIT和TIME-WAIT的意义"></a>5. CLOSE-WAIT和TIME-WAIT的意义</h3><ul><li>CLOSE-WAIT：在服务器收到客户端关闭连接的请求并告诉客户端自己已经成功收到了该请求之后，服务器进入了 CLOSE-WAIT 状态，然而此时有可能服务端还有一些数据没有传输完成，因此不能立即关闭连接，而 CLOSE-WAIT 状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成。</li><li>TIME-WAIT：TIME-WAIT 发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入该状态，若取消该状态，即客户端在收到服务端的 FIN 报文后立即关闭连接，此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则<strong>有可能接收到上一次连接中残留的数据包</strong>，可能会导致不可预料的异常出现。除此之外，假设客户端<strong>最后一次发送的 ACK 包在传输的时候丢失了</strong>，由于 TCP 协议的超时重传机制，<strong>服务端将重发 FIN 报文</strong>，若客户端并没有维持 TIME-WAIT 状态而直接关闭的话，当收到服务端重新发送的 FIN 包时，客户端就会用<strong>RST包</strong>来响应服务端，这将会使得对方认为是有错误发生，然而其实只是正常的关闭连接过程，并没有出现异常情况。</li></ul><h3 id="6-TIME-WAIT状态导致什么问题"><a href="#6-TIME-WAIT状态导致什么问题" class="headerlink" title="6. TIME-WAIT状态导致什么问题"></a>6. TIME-WAIT状态导致什么问题</h3><p>我们考虑高并发短连接的业务场景，在高并发短连接的 TCP 服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 TIME_WAIT 状态，服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。</p><p>解决方案：修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。</p><h3 id="7-TIME-WAIT为什么是2MSL"><a href="#7-TIME-WAIT为什么是2MSL" class="headerlink" title="7. TIME-WAIT为什么是2MSL"></a>7. TIME-WAIT为什么是2MSL</h3><p>当客户端发出最后的 ACK 确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完 ACK 确认报文之后，会设置一个时长为 2 MSL 的计时器。MSL（Maximum Segment Lifetime），指一段 TCP 报文在传输过程中的最大生命周期。2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长。</p><p>若<strong>服务器在 1 MSL 内没有收到客户端发出的 ACK 确认报文</strong>，再次向客户端发出 FIN 报文。如果客户端在 2 MSL 内收到了服务器再次发来的 FIN 报文，说明服务器由于一些原因并没有收到客户端发出的 ACK 确认报文。客户端将再次向服务器发出 ACK 确认报文，并重新开始 2 MSL 的计时。</p><p>若<strong>客户端在 2MSL 内没有再次收到服务器发送的 FIN 报文</strong>，则说明服务器正常接收到客户端 ACK 确认报文，客户端可以进入 CLOSE 阶段，即完成四次挥手。</p><p>所以客户端要经历 2 MSL 时长的 TIME-WAIT 阶段，为的是确认服务器能否接收到客户端发出的 ACK 确认报文。</p><h3 id="8-TCP和UDP的区别"><a href="#8-TCP和UDP的区别" class="headerlink" title="8. TCP和UDP的区别"></a>8. TCP和UDP的区别</h3><table><thead><tr><th>类型</th><th>是否面向连接</th><th>可靠性</th><th>传输形式</th><th>传输效率</th><th>所需资源</th><th>应用场景</th><th>首部字节</th></tr></thead><tbody><tr><td>TCP</td><td>是</td><td>可靠</td><td>字节流</td><td>慢</td><td>多</td><td>文件传输、邮件传输</td><td>20-60</td></tr><tr><td>UDP</td><td>否</td><td>不可靠</td><td>数据报</td><td>快</td><td>少</td><td>即时通讯、域名转换</td><td>8</td></tr></tbody></table><h3 id="9-TCP协议中的定时器"><a href="#9-TCP协议中的定时器" class="headerlink" title="9. TCP协议中的定时器"></a>9. TCP协议中的定时器</h3><p>建立连接定时器、重传定时器、坚持定时器（窗口变大）、延迟应答定时器、保活定时器、FIN-WAIT-2定时器、TIME-WAIT定时器</p><h3 id="10-TCP如何保证可靠性"><a href="#10-TCP如何保证可靠性" class="headerlink" title="10. TCP如何保证可靠性"></a>10. TCP如何保证可靠性</h3><ol><li>数据分块：应用数据被分割成TCP最适合发送的数据块</li><li>序列号和确认应答：CP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。</li><li>校验和：TCP将保持它首部和数据部分的校验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。</li><li>流量控制：TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。</li><li>拥塞控制：当网络某个节点发生拥塞时，减少数据的发送。</li><li>超时重传：当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。</li><li>ARQ协议：每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li></ol><h3 id="11-UDP为什么是不可靠的？bind和connect对于UDP的作用"><a href="#11-UDP为什么是不可靠的？bind和connect对于UDP的作用" class="headerlink" title="11. UDP为什么是不可靠的？bind和connect对于UDP的作用"></a>11. UDP为什么是不可靠的？bind和connect对于UDP的作用</h3><p>UDP只有一个socket接收缓冲区，没有socket发送缓冲区，即只要有数据就发送，不管对方是否能正确接收。而在对方的socket接收缓冲区满了之后，新来的数据报无法进入到socket接收缓冲区，此数据报就会被丢弃，因此UDP不保证数据能够到达目的地，此外，UDP也没有流量控制和重传机制。故UDP的数据传输是不可靠的。</p><p>和TCP建立连接时使用3次握手不同，UDP中调用connect只是把对端的IP和端口号记录下来，并且UDP可多次调用connect来指定新的IP和端口号，或断开旧的IP和端口号。和普通的 UDP 相比，调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性。</p><p>当 UDP 的发送端调用 bind 函数时，就会将这个套接字指定一个端口，若不调用 bind 函数，系统内核会随机分配一个端口给该套接字。当手动绑定时，能够避免内核来执行这一操作，从而在一定程度上提高性能。</p><h3 id="12-TCP超时重传的原理"><a href="#12-TCP超时重传的原理" class="headerlink" title="12. TCP超时重传的原理"></a>12. TCP超时重传的原理</h3><p>发送方在发送一次数据后就开启一个定时器，在一定时间内如果没有得到发送数据包的 ACK 报文，那么就重新发送数据，在达到一定次数还没有成功的话就放弃重传并发送一个复位信号。其中超时时间的计算是超时的核心，而定时时间的确定往往需要进行适当的权衡，因为当定时时间过长会造成网络利用率不高，定时太短会造成多次重传，使得网络阻塞。在 TCP 连接过程中，会参考当前的网络状况从而找到一个合适的超时时间。</p><h3 id="13-TCP的停止等待协议"><a href="#13-TCP的停止等待协议" class="headerlink" title="13. TCP的停止等待协议"></a>13. TCP的停止等待协议</h3><p>停止等待协议是为了实现 TCP 可靠传输而提出的一种相对简单的协议，该协议指的是发送方每发完一组数据后，直到收到接收方的确认信号才继续发送下一组数据。</p><p>可能出现的情况：无差错、超时重传、确认丢失、确认迟到。</p><h3 id="14-TCP最大连接数限制"><a href="#14-TCP最大连接数限制" class="headerlink" title="14. TCP最大连接数限制"></a>14. TCP最大连接数限制</h3><p>client 在每次发起 TCP 连接请求时，如果自己并不指定端口的话，系统会随机选择一个本地端口（local port），该端口是独占的，不能和其他 TCP 连接共享。TCP 端口的数据类型是 unsigned short，因此本地端口个数最大只有 65536，除了端口 0不能使用外，其他端口在空闲时都可以正常使用，这样可用端口最多有 65535 个。</p><p>server 通常固定在某个本地端口上监听，等待 client 的连接请求。不考虑地址重用（Unix 的 SO_REUSEADDR 选项）的情况下，即使 server 端有多个 IP，本地监听端口也是独占的，因此 server 端 TCP 连接 4 元组中只有客户端的 IP 地址和端口号是可变的，因此最大 TCP 连接为客户端 IP 数 × 客户端 port 数，对 IPV4，在不考虑 IP 地址分类的情况下，最大 TCP 连接数约为 2 的 32 次方（IP 数）× 2 的 16 次方（port 数），也就是 server 端单机最大 TCP 连接数约为 2 的 48 次方</p><h3 id="15-TCP流量控制与拥塞控制"><a href="#15-TCP流量控制与拥塞控制" class="headerlink" title="15. TCP流量控制与拥塞控制"></a>15. TCP流量控制与拥塞控制</h3><ul><li>流量控制：所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。如果接收方来不及接收发送方发送的数据，那么就会有分组丢失。在 TCP 中利用可边长的滑动窗口机制可以很方便的在 TCP 连接上实现对发送方的流量控制。主要的方式是接收方返回的 ACK 中会包含自己的接收窗口大小，以控制发送方此次发送的数据量大小（发送窗口大小）。</li><li>拥塞控制：在实际的网络通信系统中，除了发送方和接收方外，还有路由器，交换机等复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。</li><li>区别：拥塞控制往往是一种全局的，防止过多的数据注入到网络之中，而TCP连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处。而流量控制往往指点对点通信量的控制，是端到端的问题。</li></ul><h3 id="16-如果接收方滑动窗口满了，发送方会怎么做"><a href="#16-如果接收方滑动窗口满了，发送方会怎么做" class="headerlink" title="16. 如果接收方滑动窗口满了，发送方会怎么做"></a>16. 如果接收方滑动窗口满了，发送方会怎么做</h3><p>基于 TCP 流量控制中的滑动窗口协议，我们知道接收方返回给发送方的 ACK 包中会包含自己的接收窗口大小，若接收窗口已满，此时接收方返回给发送方的接收窗口大小为 0，此时发送方会等待<strong>接收方发送的窗口大小直到变为非 0 **为止，然而，</strong>接收方回应的 ACK 包是存在丢失的可能<strong>的，为了防止双方一直等待而出现死锁情况，此时就需要</strong>坚持计时器**来辅助发送方周期性地向接收方查询，以便发现窗口是否变大【坚持计时器参考问题】，当发现窗口大小变为非零时，发送方便继续发送数据。</p><h3 id="17-TCP拥塞控制采取的四种算法"><a href="#17-TCP拥塞控制采取的四种算法" class="headerlink" title="17. TCP拥塞控制采取的四种算法"></a>17. TCP拥塞控制采取的四种算法</h3><ol><li><p>慢开始</p><p>当发送方开始发送数据时，由于一开始不知道网络负荷情况，如果立即将大量的数据字节传输到网络中，那么就有可能引起网络拥塞。一个较好的方法是在一开始发送少量的数据先探测一下网络状况，即由小到大的增大发送窗口（拥塞窗口 cwnd）。慢开始的慢指的是初始时令 cwnd为 1，即一开始发送一个报文段。如果收到确认，则 cwnd = 2，之后每收到一个确认报文，就令 cwnd = cwnd* 2。</p><p>但是，为了防止拥塞窗口增长过大而引起网络拥塞，另外设置了一个慢开始门限 ssthresh。</p><p>① 当 cwnd &lt; ssthresh 时，使用上述的慢开始算法；</p><p>② 当 cwnd &gt; ssthresh 时，停止使用慢开始，转而使用拥塞避免算法；</p><p>③ 当 cwnd == ssthresh 时，两者均可。</p></li><li><p>拥塞避免</p><p>拥塞控制是为了让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT （往返时间定义为发送方发送数据到收到确认报文所经历的时间）就把发送方的 cwnd 值加 1，通过让 cwnd 线性增长，防止很快就遇到网络拥塞状态。</p><p>当网络拥塞发生时，让新的慢开始门限值变为发生拥塞时候的值的一半,并将拥塞窗口置为 1 ,然后再次重复两种算法（慢开始和拥塞避免）,这时一瞬间会将网络中的数据量大量降低。</p></li><li><p>快重传</p><p>快重传算法要求接收方每收到一个失序的报文就立即发送重复确认，而不要等到自己发送数据时才捎带进行确认，假定发送方发送了 Msg 1 ~ Msg 4 这 4 个报文，已知接收方收到了 Msg 1，Msg 3 和 Msg 4 报文，此时因为接收到收到了失序的数据包，按照快重传的约定，接收方应立即向发送方发送 Msg 1 的重复确认。 于是在接收方收到 Msg 4 报文的时候，向发送方发送的仍然是 Msg 1 的重复确认。这样，发送方就收到了 3 次 Msg 1 的重复确认，于是立即重传对方未收到的 Msg 报文。由于发送方尽早重传未被确认的报文段，因此，快重传算法可以提高网络的吞吐量。</p></li><li><p>快恢复</p><p>快恢复算法是和快重传算法配合使用的，该算法主要有以下两个要点：</p><p>① 当发送方连续收到三个重复确认，执行乘法减小，慢开始门限 ssthresh 值减半；</p><p>② 由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，把 cwnd 值设置为 ssthresh 减半之后的值，然后执行拥塞避免算法，线性增大 cwnd。</p></li></ol><h3 id="18-TCP粘包问题"><a href="#18-TCP粘包问题" class="headerlink" title="18. TCP粘包问题"></a>18. TCP粘包问题</h3><p>① 发送方写入的数据大于套接字缓冲区的大小，此时将发生拆包。</p><p>② 发送方写入的数据小于套接字缓冲区大小，由于 TCP 默认使用 Nagle 算法，只有当收到在传数据的确认后，才将分组发送给对端，当发送方收集了多个较小的分组，就会一起发送给对端，这将会发生粘包。</p><p>③ 进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP 报文的数据部分大于 MSS 的时候将发生拆包。</p><p>④ 发送方发送的数据太快，接收方处理数据的速度赶不上发送端的速度，将发生粘包。</p><h4 id="常见解决方法"><a href="#常见解决方法" class="headerlink" title="常见解决方法"></a>常见解决方法</h4><p>① 在消息的头部添加消息长度字段，服务端获取消息头的时候解析消息长度，然后向后读取相应长度的内容。</p><p>② 固定消息数据的长度，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。但是该方法会浪费网络资源。</p><p>③ 设置消息边界，也可以理解为分隔符，服务端从数据流中按消息边界分离出消息内容，一般使用换行符。</p><h4 id="什么时候要处理粘包问题"><a href="#什么时候要处理粘包问题" class="headerlink" title="什么时候要处理粘包问题"></a>什么时候要处理粘包问题</h4><p>当接收端同时收到多个分组，并且这些分组之间毫无关系时，需要处理粘包；而当多个分组属于同一数据的不同部分时，并不需要处理粘包问题</p><h3 id="19-TCP报文"><a href="#19-TCP报文" class="headerlink" title="19.TCP报文"></a>19.TCP报文</h3><ol><li>源端口号、目的端口号</li><li>序列号</li><li>确认号</li><li>首部长度、保留字段、URG、ACK、PSH、RST、SYN、FIN、接收窗口</li><li>校验和、紧急数据指针</li><li>选项</li><li>数据</li></ol><ul><li>源端口号和目的端口号：它用于多路复用/分解来自或送往上层应用的数据，其和 IP 数据报中的源 IP 与目的 IP 地址一同确定一条 TCP 连接。</li><li>序列号和确认号：序号是本报文段发送的数据部分中第一个字节的编号，在 TCP 传送的流中，每一个字节一个序号。例如一个报文段的序号为 100，此报文段数据部分共有 100 个字节，则下一个报文段的序号为 200。序号确保了 TCP 传输的有序性。确认号，即 ACK，指明下一个想要收到的字节序号，发送 ACK 时表明当前序号之前的所有数据已经正确接收。这两个字段的主要目的是保证数据可靠传输。</li><li>首部长度：该字段指示了以 32 比特的字为单位的 TCP 的首部长度。其中固定字段长度为 20 字节，由于首部长度可能含有可选项内容，因此 TCP 报头的长度是不确定的，20 字节是 TCP 首部的最小长度。</li><li>保留字段</li><li>控制位<ul><li>URG：紧急指针标志，该位为1时表示紧急指针有效</li><li>ACK：确认序号标志，即相应报文段包含对以成功接收报文的确定</li><li>PSH：push标志，指接收到该报文段后，应当尽快将该报文段交给应用程序，而不是在缓冲区排队。</li><li>RST：重置连接标志，指连接出现错误，使用此标志来拒绝非法的请求。</li><li>SYN：为同步序号，在连接的建立过程中使用，例如三次握手时，发送方发送 SYN 包表示请求建立连接</li><li>FIN：finish标志，用于释放连接，为 1 时表示发送方已经没有数据发送了，即关闭本方数据流。</li></ul></li><li>接收窗口：用于TCP流量控制。该字段告诉发送方其窗口大小，以次控制发送速率，达到流量控制的效果</li><li>校验和：奇偶校验，此校验和是对整个 TCP 报文段，包括 TCP 头部和 数据部分。该校验和是一个端到端的校验和，由发送端计算和存储，并由接收端进行验证，主要目的是检验数据是否发生改动，若检测出差错，接收方会丢弃该 TCP 报文。</li><li>紧急数据指针：紧急数据用于告知紧急数据所在的位置，在URG标志位为 1 时才有效。当紧急数据存在时，TCP 必须通知接收方的上层实体，接收方会对紧急模式采取相应的处理。</li><li>选项：该字段一般为空，可根据首部长度进行推算。主要有以下作用：<ol><li>TCP连接初始化时，通信双方确认最大报文长度</li><li>在高速数据传输时，协商窗口扩大因子</li><li>作为时间戳时，提供一个 较为精准的 RTT，主要为了更好的实现 TCP 流量控制协议。</li></ol></li><li>数据：CP 报文中的数据部分也是可选的，例如在 TCP 三次握手和四次挥手过程中，通信双方交换的报文只包含头部信息，数据部分为空，只有当连接成功建立后，TCP 包才真正携带数据。</li></ul><h3 id="20-SYN-FLOOD"><a href="#20-SYN-FLOOD" class="headerlink" title="20. SYN FLOOD"></a>20. SYN FLOOD</h3><p>SYN FLOOD是典型的DoS（拒绝服务）攻击，其目的是通过消耗服务器可用资源是服务器无法处理合法请求。通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求。</p><h3 id="21-为什么服务端易受到SYN攻击"><a href="#21-为什么服务端易受到SYN攻击" class="headerlink" title="21. 为什么服务端易受到SYN攻击"></a>21. 为什么服务端易受到SYN攻击</h3><p>在TCP建立连接的过程中，因为服务端不确定自己发给客户端的 SYN-ACK 消息或客户端反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接状态设一个定时器，如果超过时间还没有收到客户端的 ACK 消息，则重新发送一次 SYN-ACK 消息给客户端，直到重试超过一定次数时才会放弃。</p><p>服务端为了维持半开连接状态，需要分配内核资源维护半开连接。当攻击者伪造海量的虚假 IP 向服务端发送 SYN 包时，就形成了 SYN FLOOD 攻击。攻击者故意不响应 ACK 消息，导致服务端被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。</p><p>解决方法：1. 减少半开资源占用时间，2. 黑名单阻止恶意IP</p><p>SYN cache、SYN cookie。 由于服务端不保存半连接状态，所以没有超时重传能力</p><p>SYN proxy</p><h3 id="22-TCP-fastopen"><a href="#22-TCP-fastopen" class="headerlink" title="22. TCP fastopen"></a>22. TCP fastopen</h3><p><a href="https://blog.csdn.net/weixin_34430692/article/details/112412253">fastopen</a></p><p>绕过三次握手，减少一个RTT流程。</p><p>第一次发送http+get请求的时候需要三次握手，但是之后再向服务器建立连接时，用cookie。</p><h3 id="23-糊涂窗口综合征"><a href="#23-糊涂窗口综合征" class="headerlink" title="23. 糊涂窗口综合征"></a>23. 糊涂窗口综合征</h3><p>如果发送端为产生数据很慢的应用程序服务(典型的有telnet应用)，例如，一次产生一个字节。这个应用程序一次将一个字节的数据写入发送端的TCP的缓存。如果发送端的TCP没有特定的指令，它就产生只包括一个字节数据的报文段。结果有很多41字节的<a href="https://baike.baidu.com/item/IP数据报/1581132">IP数据报</a>就在互连网中传来传去。</p><p>窗口增大、nagle算法、延迟确认</p><h2 id="四、网络层"><a href="#四、网络层" class="headerlink" title="四、网络层"></a>四、网络层</h2><h3 id="1-IP协议的定义与作用"><a href="#1-IP协议的定义与作用" class="headerlink" title="1. IP协议的定义与作用"></a>1. IP协议的定义与作用</h3><p>IP协议（Internet Protocol）又称互联网协议，是支持网间互联的数据包协议。该协议工作在网络层，主要目的是为了提高网络的可扩展性。和传输层的TCP相比，IP是一种无连接、不可靠、尽力而为的数据包传输服务，其与TCP协议（传输控制协议）一起构成了TCP/IP协议族的核心。IP协议主要有以下几个作用</p><ul><li>寻址和路由：在IP 数据包中会携带源 IP 地址和目的 IP 地址来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至抵达目的主机。</li><li>分段与重组：IP数据包在传输过程中可能会经过不同的网络，不同的网络中数据包的最大长度限制是不同的。IP协议通过给每个IP数据包分配一个标识符以及分段与组装的相关信息，使得数据包在不同的网络中能够被传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在<strong>到达目的主机后由目的主机完成重组工作</strong>，恢复出原来的 IP 数据包。</li></ul><h3 id="2-域名和IP的关系"><a href="#2-域名和IP的关系" class="headerlink" title="2. 域名和IP的关系"></a>2. 域名和IP的关系</h3><p>一个域名只能对应一个 IP 地址，是一对一的关系；而一个 IP 却可以对应多个域名，是一对多的关系。</p><h3 id="3-IPv4地址不够怎么解决"><a href="#3-IPv4地址不够怎么解决" class="headerlink" title="3. IPv4地址不够怎么解决"></a>3. IPv4地址不够怎么解决</h3><ul><li>DHCP： 动态主机配置协议。动态分配IP地址，只给接入网络的设备分配IP地址。因此同一个MAC地址的设备每次接入互联网时得到的IP地址不一定是相同的，该协议使得空闲的IP可以得到充分利用。</li><li>CIDR：无类别域间路由。CIDR消除了A类、B类、C类地址以及子网划分概念，因而更加有效的分配IPv4的地址空间，但无法从根本上解决地址耗尽问题。一个IP地址包括标识网络的前缀和紧接着的在这个网络内的主机地址，CIDR使得前缀可变长。</li><li>NAT：网络地址转换协议。属于不同局域网的主机可以使用相同的IP地址，从一定程度上解决了IP资源枯竭的问题，然而主机在局域网中使用的 IP 地址是不能在公网中使用的，当局域网主机想要与公网进行通信时， NAT 方法可以将该主机 IP 地址转换成全球 IP 地址。该协议能够有效解决 IP 地址不足的问题。</li><li>IPv6:作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址。</li></ul><h3 id="4-路由器的分组转发流程"><a href="#4-路由器的分组转发流程" class="headerlink" title="4. 路由器的分组转发流程"></a>4. 路由器的分组转发流程</h3><ol><li>从IP数据包提取目的主机的IP地址D，其所在的网络N</li><li>判断目的IP地址所在的网络N是否与本路由器直接相连，如果是，则不需要经过其他路由器，直接交付，不是执行3</li><li>检查路由表中是否有目的IP地址D的特定主机路由，如果有，则按照路由表跳转到下一跳路由器中，否则执行4</li><li>逐条检查路由表，若路由表中有到达网络N的路由，则把数据报传给路由表中所指明的下一跳路由器，否则执行5</li><li>若路由表中设置有默认路由，则按默认路由转发到默认路由中，没有执行6</li><li>无法找到合适路由，向源主机报错</li></ol><h3 id="5-路由器和交换机的区别"><a href="#5-路由器和交换机的区别" class="headerlink" title="5. 路由器和交换机的区别"></a>5. 路由器和交换机的区别</h3><ul><li>交换机：交换机用于局域网，利用主机的MAC地址确定数据转发的目的地址，工作在数据链路层</li><li>路由器：路由器根据数据包中的目标IP地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的，路由器根据路由选择协议和路由表信息从而确定数据的转发路径，直到到达目的网络，它工作于网络层。</li></ul><h3 id="6-ICMP协议概念-作用"><a href="#6-ICMP协议概念-作用" class="headerlink" title="6. ICMP协议概念/作用"></a>6. ICMP协议概念/作用</h3><p>ICMP（Internet Control Message Protocol）是因特网控制报文协议，主要实现IP协议中未实现的部分功能，是一种网络层协议。该协议并不传输数据，而是传递控制信息来辅助网络层通信。其主要功能是用来验证网络是否畅通（确认接收方能否成功接收到数据包）以及辅助IP协议实现可靠传输（如果发生IP丢包，ICMP会通知发送方IP数据包被丢弃的原因，之后发送方会进行相应的处理）</p><h3 id="7-ICMP的应用"><a href="#7-ICMP的应用" class="headerlink" title="7. ICMP的应用"></a>7. ICMP的应用</h3><h4 id="7-1-ping"><a href="#7-1-ping" class="headerlink" title="7.1 ping"></a>7.1 ping</h4><p>Ping（Packet Internet Groper）即因特网包探测器。是一种工作在网络层的服务命令，主要用于测试网络连接量。本地主机通过向目的主机发送ICMP Echo请求报文，目的主机接收到之后会发送Echo响应报文，Ping会根据时间和成功响应的次数估算出数据包往返时间以及丢包率从而推断网络是否通畅、运行是否正常等。</p><h4 id="7-2-TraceRoute"><a href="#7-2-TraceRoute" class="headerlink" title="7.2 TraceRoute"></a>7.2 TraceRoute</h4><p>TraceRoute 是 ICMP 的另一个应用，其主要用来跟踪一个分组从源点耗费最少 TTL 到达目的地的路径。TraceRoute 通过逐渐增大 TTL 值并重复发送数据报来实现其功能，首先，TraceRoute 会发送一个 TTL 为 1 的 IP 数据报到目的地，当路径上的第一个路由器收到这个数据报时，它将 TTL 的值减 1，此时 TTL = 0，所以路由器会将这个数据报丢掉，并返回一个差错报告报文，之后源主机会接着发送一个 TTL 为 2 的数据报，并重复此过程，直到数据报能够刚好到达目的主机。此时 TTL = 0，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文，之后源主机便知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。</p><h3 id="8-两台电脑ping不同的问题"><a href="#8-两台电脑ping不同的问题" class="headerlink" title="8. 两台电脑ping不同的问题"></a>8. 两台电脑ping不同的问题</h3><ol><li>网络是否正常连接，网卡驱动是否正确安装</li><li>局域网设置问题，IP地址是否正确设置</li><li>看是否被防火墙阻拦（有些设置中防火墙会对 ICMP 报文进行过滤），如果是的话，尝试关闭防火墙 。</li><li>看是否被第三方软件拦截。</li><li>两台设备间的网络延迟是否过大（例如路由设置不合理），导致 ICMP 报文无法在规定的时间内收到。</li></ol><h3 id="9-ARP地址解析协议的原理和地址解析过程"><a href="#9-ARP地址解析协议的原理和地址解析过程" class="headerlink" title="9. ARP地址解析协议的原理和地址解析过程"></a>9. ARP地址解析协议的原理和地址解析过程</h3><p>ARP（Address Resolution Protocol）是地址解析协议的缩写，该协议提供根据IP地址获取物理地址的功能，它工作在数据链路层，在网络层和物理层之间进行联系，同时向上层提供服务。当通过以太网发送IP数据包时，需要先封装32位的IP地址和48位MAC地址，在局域网中两台主机进行通信时需要依靠各自的物理地址进行标识，但由于发送方只知道IP地址，不知道其MAC地址，因此需要地址解析协议。ARP协议的解析过程：</p><ol><li>首先，每个主机都会在自己的ARP缓冲区中建立一个ARP表，以表示IP地址和MAC地址之间的对应关系</li><li>当源主机要发送数据时，首先检查ARP列表中是否有IP地址对应的目的主机MAC地址，如果存在，则可以直接发送数据，否则就向同一子网的所有主机发送ARP数据包，该数据包包括源主机的IP地址、MAC地址和目的主机的IP地址。</li><li>当本网络中的所有主机收到该 ARP 数据包时，首先检查数据包中的 目的 主机IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖，然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。</li><li>源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败</li></ol><h3 id="10-网络地址转换NAT"><a href="#10-网络地址转换NAT" class="headerlink" title="10. 网络地址转换NAT"></a>10. 网络地址转换NAT</h3><p>NAT（Network Address Translation），即网络地址转换，它是一种把内部私有网络地址翻译成公有网络IP地址的技术，该技术不仅能解决IP地址不足的问题，还能够隐藏和保护网络内部主机，避免来自外部网络的攻击。</p><p>NAT的实现方式：</p><ol><li>静态转换：内部私有 IP 地址和公有 IP 地址是一对一的关系，并且不会发生改变。通过静态转换，可以实现外部网络对内部网络特定设备的访问，这种方式原理简单，但当某一共有 IP 地址被占用时，跟这个 IP 绑定的内部主机将无法访问 Internet。</li><li>动态转换：采用动态转换的方式时，私有 IP 地址每次转化成的公有 IP 地址是不唯一的。当私有 IP 地址被授权访问 Internet 时会被随机转换成一个合法的公有 IP 地址。当 ISP 通过的合法 IP 地址数量略少于网络内部计算机数量时，可以采用这种方式。</li><li>端口多路复用：该方式将外出数据包的源端口进行端口转换，通过端口多路复用的方式，实现内部网络所有主机共享一个合法的外部 IP 地址进行 Internet 访问，从而最大限度地节约 IP 地址资源。同时，该方案可以隐藏内部网络中的主机，从而有效避免来自 Internet 的攻击。</li></ol><h3 id="11-TTL是什么，有什么作用"><a href="#11-TTL是什么，有什么作用" class="headerlink" title="11. TTL是什么，有什么作用"></a>11. TTL是什么，有什么作用</h3><p>TTL 是指生存时间，简单来说，它表示了数据包在网络中的时间。每经过一个路由器后 TTL 就减一，这样 TTL 最终会减为 0 ，当 TTL 为 0 时，则将数据包丢弃。</p><p>通过设置 TTL 可以避免这两个路由器之间形成环导致数据包在环路上死转的情况，由于有了 TTL ，当 TTL 为 0 时，数据包就会被抛弃。</p><h3 id="12-运输层协议和网络层协议的区别"><a href="#12-运输层协议和网络层协议的区别" class="headerlink" title="12. 运输层协议和网络层协议的区别"></a>12. 运输层协议和网络层协议的区别</h3><p>网络层协议负责提供主机间的逻辑通信；运输层协议负责提供进程间的逻辑通信。</p><h3 id="13-IP报文"><a href="#13-IP报文" class="headerlink" title="13. IP报文"></a>13. IP报文</h3><p>目标地址、源地址、检验和，版本号、首部长度、总长度、上层协议、TTL、标识（分片重组）标志（3bit，分片信息）保留字段。</p><ol><li>版本号、首部长度、服务类型（质量，8）、数据包长度（16）</li><li>标识（16）、标志（3）保留字段</li><li>TTL、上层协议、检验和</li><li>源IP地址</li><li>目的IP地址</li><li>选项</li><li>数据</li></ol><h3 id="14-保留-私有IP地址"><a href="#14-保留-私有IP地址" class="headerlink" title="14. 保留/私有IP地址"></a>14. 保留/私有IP地址</h3><p>私有：</p><ul><li>A类 10.0.0.0 ~ 10.255.255.255（10/8）</li><li>B类 172.16.0.0 ~ 172.31.255.255（172.16/12）</li><li>C类 192.168.0.0 ~ 192.168.255.255（192.168/16） 包含在这个范围内的IP地址都属于私有IP，在此之外的IP称为全局IP。</li></ul><p>保留（常见）：</p><ul><li>0.0.0.0/8 This host is on network</li><li>127.0.0.0/8 LoopBack 凡是以<code>127</code>开头的<strong>IP地址</strong>，都是<strong>回环地址（Loop back address）</strong>，其所在的回环接口一般被理解为虚拟网卡，并不是真正的路由器接口。正常的<code>数据包</code>会从<code>IP层</code>进入<code>链路层</code>，然后发送到<code>网络</code>上；而给<code>回环地址</code>发送<code>数据包</code>，<code>数据包</code>会直接被发送主机的<code>IP层</code>获取，后面就没有<code>链路层</code>他们啥事了。</li><li>255.255.255.255/32 Limited Broadcast  传播范围非常有限，到了广播域的边界（<strong>网关</strong>）会自动终结</li><li>169.254.X.X是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP。</li></ul><h2 id="五、数据链路层"><a href="#五、数据链路层" class="headerlink" title="五、数据链路层"></a>五、数据链路层</h2><h3 id="1-MAC地址和IP地址有什么区别"><a href="#1-MAC地址和IP地址有什么区别" class="headerlink" title="1. MAC地址和IP地址有什么区别"></a>1. MAC地址和IP地址有什么区别</h3><ul><li>MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址。MAC 地址用来定义网络设备的位置。</li><li>IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。</li></ul><h3 id="2-为什么有了-MAC-地址还需要-IP-地址"><a href="#2-为什么有了-MAC-地址还需要-IP-地址" class="headerlink" title="2. 为什么有了 MAC 地址还需要 IP 地址"></a>2. 为什么有了 MAC 地址还需要 IP 地址</h3><p>如果我们只使用 MAC 地址进行寻址的话，我们需要路由器记住每个 MAC 地址属于哪一个子网，不然每一次路由器收到数据包时都要满世界寻找目的 MAC 地址。而我们知道 MAC 地址的长度为 48 位，也就是说最多总共有 2 的 48 次方个 MAC 地址，这就意味着每个路由器需要 256 T 的内存，这显然是不现实的</p><p>和 MAC 地址不同，IP 地址是和地域相关的，在一个子网中的设备，我们给其分配的 IP 地址前缀都是一样的，这样路由器就能根据 IP 地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。</p><h3 id="3-为什么有了-IP-地址还需要-MAC-地址"><a href="#3-为什么有了-IP-地址还需要-MAC-地址" class="headerlink" title="3. 为什么有了 IP 地址还需要 MAC 地址"></a>3. 为什么有了 IP 地址还需要 MAC 地址</h3><p>只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候或者在分配 IP 地址的过程中，我们需要 MAC 地址来区分不同的设备。</p><h3 id="4-私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗"><a href="#4-私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗" class="headerlink" title="4. 私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗"></a>4. 私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗</h3><p>当采用静态或者动态转换时，由于一个私网 IP 地址对应一个公网地址，因此经过转换之后的公网 IP 地址是不同的；而采用端口复用方式的话，在一个子网中的所有地址都采用一个公网地址，但是使用的端口是不同的。</p><h3 id="六、-计算机网络中的安全"><a href="#六、-计算机网络中的安全" class="headerlink" title="六、 计算机网络中的安全"></a>六、 计算机网络中的安全</h3><h3 id="1-安全攻击有哪些"><a href="#1-安全攻击有哪些" class="headerlink" title="1. 安全攻击有哪些"></a>1. 安全攻击有哪些</h3><p>网络安全攻击主要分为两类：主动攻击和被动攻击</p><ul><li>被动攻击：攻击者窃听和监听数据传输，从而获取到传输的数据信息，被动攻击主要有两种形式：消息内容泄露攻击和流量分析攻击。由于攻击者并没有修改数据，使得这种攻击类型是很难被检测到的。</li><li>主动攻击：攻击者修改传输的数据流或者故意添加错误的数据流，例如假冒用户身份从而得到一些权限，进行权限攻击，除此之外，还有重放、改写和拒绝服务等主动攻击的方式。</li></ul><h3 id="2-ARP攻击"><a href="#2-ARP攻击" class="headerlink" title="2. ARP攻击"></a>2. ARP攻击</h3><p>在ARP解析过程中，局域网上的任何一台主机如果接收到一个ARP应答报文，并不会去检测这个报文的真实性，而是直接记入自己ARP缓存表中，并且这个ARP缓存表是可以被更改的，当表中的某一列长时间不使用时就会被删除。ARP攻击就是利用了这一点，不断的发送ARP报文，将源MAC地址改为自己的MAC地址，而源IP地址改为自己的IP地址，通过不断发送这些伪造的 ARP 报文，让网络内部的所有主机和网关的 ARP 表中被攻击者的 IP 地址所对应的 MAC 地址为攻击者的 MAC 地址。这样所有发送给被攻击者的信息都会发送到攻击者的主机上，从而产生 ARP 欺骗。通常可以把 ARP 欺骗分为以下几种：</p><ol><li><p>洪泛攻击</p><p>攻击者恶意向局域网中的网关、路由器和交换机等发送大量 ARP 报文，设备的 CPU 忙于处理 ARP 协议，而导致难以响应正常的服务请求。其表现通常为：网络中断或者网速很慢。</p></li><li><p>欺骗主机</p><p>这种攻击方式也叫仿冒网关攻击。攻击者通过 ARP 欺骗使得网络内部被攻击主机发送给网关的信息实际上都发送给了攻击者，主机更新的 ARP 表中对应的 MAC 地址为攻击者的 MAC。当用户主机向网关发送重要信息使，该攻击方式使得用户的数据存在被窃取的风险。</p></li><li><p>欺骗网关</p><p>该攻击方式和欺骗主机的攻击方式类似，不过这种攻击的欺骗对象是局域网的网关，当局域网中的主机向网关发送数据时，网关会把数据发送给攻击者，这样攻击者就会源源不断地获得局域网中用户的信息。该攻击方式同样会造成用户数据外泄。</p></li><li><p>中间人攻击</p><p>攻击者同时欺骗网关和主机，局域网的网关和主机发送的数据最后都会到达攻击者这边。这样，网关和用户的数据就会泄露。</p></li><li><p>IP地址冲突</p><p>攻击者对局域网中的主机进行扫描，然后根据物理主机的 MAC 地址进行攻击，导致局域网内的主机产生 IP 冲突，使得用户的网络无法正常使用。</p></li></ol><h3 id="3-对称加密（AES）和非对称（RSA）的区别，非对称加密有哪些"><a href="#3-对称加密（AES）和非对称（RSA）的区别，非对称加密有哪些" class="headerlink" title="3. 对称加密（AES）和非对称（RSA）的区别，非对称加密有哪些"></a>3. 对称加密（AES）和非对称（RSA）的区别，非对称加密有哪些</h3><ul><li>加密解密过程不同：对称加密和解密过程使用同一个密钥；非对称加密中加密和解密采用公钥和私钥两个密钥，一般使用公钥进行加密，使用私钥进行解密。</li><li>加密解密速度不同：对称加密和解密速度较快，当数据量比较大时适合使用；非对称加密和解密时间较长，速度相对较慢，适合少量数据传输的场景。</li><li>传输的安全性不同：采用对称加密方式进行通信时，收发双方在数据传送前需要协定好密钥，而这个密钥还有可能被第三方窃听到的，一旦密钥泄漏，之后的通信就完全暴漏给攻击者了；非对称加密采用公钥加密和私钥解密的方式，其中私钥是基于不同的算法生成的随机数，公钥可以通过私钥通过一定的算法推导得出，并且私钥到公钥的推导过程是不可逆的，也就是说公钥无法反推导出私钥，即使攻击者窃听到传输的公钥，也无法正确解出数据，所以安全性较高。</li></ul><h3 id="4-DDoS-有哪些，如何防范"><a href="#4-DDoS-有哪些，如何防范" class="headerlink" title="4. DDoS 有哪些，如何防范"></a>4. DDoS 有哪些，如何防范</h3><p>DDoS 为分布式拒绝服务攻击，是指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了不同位置上的多台机器并利用这些机器对受害者同时实施攻击。和单一的 DoS 攻击相比，DDoS 是借助数百台或者数千台已被入侵并添加了攻击进程的主机一起发起网络攻击。</p><p>DDoS 攻击主要有两种形式：流量攻击和资源耗尽攻击。前者主要针对网络带宽，攻击者和已受害主机同时发起大量攻击导致网络带宽被阻塞，从而淹没合法的网络数据包；后者主要针对服务器进行攻击，大量的攻击包会使得服务器资源耗尽或者 CPU 被内核应用程序占满从而无法提供网络服务。</p><p>SYN FLOOD, </p><p>DRDOS:黑客冒充了被攻击主机。黑客发送请求包所用的软件是可以伪造源地址的，接到伪造数据包的主机会根据源地址把回应发出去，这当然就是被攻击主机的地址。黑客同时还会把发送请求包的时间间隔减小，这样在短时间能发出大量的请求包，使被攻击主机接到从被欺骗计算机那里传来的洪水般的回应，就像遭到了DDoS攻击导致系统崩溃</p><p>HTTP FLOOD:攻击者通过代理或僵尸主机向目标服务器发起大量的HTTP报文，请求涉及数据库操作的URI（Universal Resource Identifier）或其它消耗系统资源的URI，造成服务器资源耗尽，无法响应正常请求。</p><h3 id="5-CSRF"><a href="#5-CSRF" class="headerlink" title="5. CSRF"></a>5. CSRF</h3><p><strong>跨站请求伪造</strong>（英语：Cross-site request forgery），也被称为 <strong>one-click attack</strong> 或者 <strong>session riding</strong>，通常缩写为 <strong>CSRF</strong> 或者 <strong>XSRF</strong>， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，<strong>XSS</strong> 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。</p><h4 id="攻击细节"><a href="#攻击细节" class="headerlink" title="攻击细节"></a>攻击细节</h4><p>跨站请求攻击，简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并运行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去运行。这利用了web中用户身份验证的一个漏洞：<strong>简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的</strong>。</p><p><strong>例子</strong></p><p>假如一家银行用以运行转账操作的URL地址如下：<code>http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName</code></p><p>那么，一个恶意攻击者可以在另一个网站上放置如下代码： <code>&lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt;</code></p><p>如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。</p><p>这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着<strong>如果服务端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险</strong>。</p><p>透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是<strong>欺骗用户浏览器，让其以用户的名义运行操作</strong>。</p><h4 id="防御措施"><a href="#防御措施" class="headerlink" title="防御措施"></a>防御措施</h4><p><strong>检查Referer字段</strong></p><p>HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于<code>www.examplebank.com</code>之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于<code>www.examplebank.com</code>之下，这时候服务器就能识别出恶意的访问。</p><p>这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。</p><p><strong>添加校验token</strong></p><p>由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再运行CSRF攻击。这种数据通常是窗体中的一个数据项。服务器将其生成并附加在窗体中，其内容是一个伪随机数。当客户端通过窗体提交请求时，这个伪随机数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪随机数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪随机数的值，服务端就会因为校验token的值为空或者错误，拒绝这个可疑请求。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考之前的笔记以及该&lt;a href=&quot;https://leetcode-cn.com/leetbook/detail/&quot;&gt;leetbook&lt;/a&gt;整理。&lt;/p&gt;
&lt;h2 id=&quot;一、-协议层次及服务类型&quot;&gt;&lt;a href=&quot;#一、-协议层次及服务类型&quot; class=&quot;hea</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="基础知识" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>操作系统知识点复习整理</title>
    <link href="http://yoursite.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2021/02/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/</id>
    <published>2021-02-27T12:25:47.000Z</published>
    <updated>2021-03-19T06:12:57.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-操作系统基础"><a href="#1-操作系统基础" class="headerlink" title="1. 操作系统基础"></a>1. 操作系统基础</h2><h3 id="1-1-什么是操作系统"><a href="#1-1-什么是操作系统" class="headerlink" title="1.1 什么是操作系统"></a>1.1 什么是操作系统</h3><p>特征、功能、运行机制</p><h4 id="1-1-1-操作系统的特征"><a href="#1-1-1-操作系统的特征" class="headerlink" title="1.1.1 操作系统的特征"></a>1.1.1 操作系统的特征</h4><ol><li>并发：两个或多个时间在同一时间间隔内发生。通过分时实现</li><li>共享：指系统中的资源可供内存中并发的进程同时使用</li><li>虚拟：把一个物理上的实体变为若干个逻辑上的对应物</li><li>异步：并发执行时，由于资源有限，进程的执行不是一贯到底而是走走停停。以不可预知的速度向前推进。</li></ol><h4 id="1-1-2-操作系统的功能"><a href="#1-1-2-操作系统的功能" class="headerlink" title="1.1.2 操作系统的功能"></a>1.1.2 操作系统的功能</h4><ol><li>由上向下：管理分配资源，组织调度计算机的工作（处理器管理，存储器管理、设备管理、文件管理）</li><li>由下向上：为用户和其他软件提供接口和环境</li></ol><h4 id="1-1-3-运行机制"><a href="#1-1-3-运行机制" class="headerlink" title="1.1.3 运行机制"></a>1.1.3 运行机制</h4><ul><li>内核态（管态）：在管态中，操作系统能够访问所有硬件，以及执行任何机器能够运行的命令。能访问所有的内存空间和对象，且所占用的处理机是不允许被抢占的。</li><li>用户态（目态）：只用到了机器指令的一个子集。“管理程序”要执行的特权指令不允许在用户态中的程序使用。如I/O指令、置中断指令等影响机器控制的指令。进程所能访问的内存空间和对象受到限制，其所占有的处理机是可被抢占的；</li><li>用户态切换到内核态的唯一途径——&gt;中断/异常/陷入（系统调用）</li></ul><h5 id="进入内核态的过程"><a href="#进入内核态的过程" class="headerlink" title="进入内核态的过程"></a>进入内核态的过程</h5><p>1.用户空间的应用程序，通过系统调用，进入内核空间。这个时候用户空间的进程要传递很多变量、参数的值给内核，内核态运行的时候也要保存用户进程的一些寄存器值、变量等。所谓的“进程上下文”，可以看作是用户进程传递给内核的这些参数以及内核要保存的那一整套的变量和寄存器值和当时的环境等。</p><p>2.硬件通过触发信号，导致内核调用中断处理程序，进入内核空间。这个过程中，硬件的一些变量和参数也要传递给内核，内核通过这些参数进行中断处理。所谓的“中断上下文”，其实也可以看作就是硬件传递过来的这些参数和内核需要保存的一些其他环境（主要是当前被打断执行的进程环境）。</p><h3 id="1-2-什么是系统调用"><a href="#1-2-什么是系统调用" class="headerlink" title="1.2 什么是系统调用"></a>1.2 什么是系统调用</h3><p>系统调用运行在系统的内核态。操作系统为用户提供的使用硬件设备的接口服务。</p><p>作用：封装了内核，简化的用户程序的开发，用户程序和内核开发的分离，控制开放权限，增强系统稳定性。</p><h2 id="2-进程和线程"><a href="#2-进程和线程" class="headerlink" title="2. 进程和线程"></a>2. 进程和线程</h2><h3 id="2-1-什么是进程"><a href="#2-1-什么是进程" class="headerlink" title="2.1 什么是进程"></a>2.1 什么是进程</h3><p>进程是计算机中处于运行中程序的实体。程序本身只是指令、数据及其组织形式的描述，进程才是程序（指令和数据）的真正运行实例。</p><h4 id="1-进程-程序-数据-PCB"><a href="#1-进程-程序-数据-PCB" class="headerlink" title="1. 进程 = 程序+数据+PCB"></a>1. 进程 = 程序+数据+PCB</h4><blockquote><p>进程结构一般由3部分组成：代码段、数据段和堆栈段。代码段用于存放程序代码数据，数个进程可以共享同一个代码段。数据段存放程序的全局变量、常量和静态变量。堆栈段中栈用于函数调用，它存放着函数的参数，它存放着函数的参数，函数内部定义的局部变量。堆栈段还包括了进程控制块（Process Control Block， PCB）。PCB处于进程核心堆栈的底部，不需要额外分配空间。PCB时进程存在的唯一标识，系统通过PCB的存在而感知进程的存在</p></blockquote><h4 id="2-linux的PCB：task-struct"><a href="#2-linux的PCB：task-struct" class="headerlink" title="2. linux的PCB：task_struct"></a>2. linux的PCB：task_struct</h4><ul><li>所有运行在系统中的进程都以 task_struct 链表的形式存在内核中</li><li>PCB中的信息<ul><li>进程描述信息：进程标识符，亲属关系，从属关系（用户，组）</li><li>进程控制信息：进程当前状态、进程优先级、程序开始地址，计时信息，通信信息</li><li>资源管理信息：代码段指针，数据段指针，堆栈段指针，文件描述符，输入输出设备</li><li>处理器调度信息：通用寄存器，地址寄存器，控制寄存器，标志寄存器，状态字</li></ul></li></ul><h4 id="3-进程的状态"><a href="#3-进程的状态" class="headerlink" title="3. 进程的状态"></a>3. 进程的状态</h4><p>就绪、执行、阻塞、创建、终止。</p><h4 id="4-上下文切换"><a href="#4-上下文切换" class="headerlink" title="4. 上下文切换"></a>4. 上下文切换</h4><h5 id="4-1-上下文"><a href="#4-1-上下文" class="headerlink" title="4.1 上下文"></a>4.1 上下文</h5><p>进程上下文指的是记录重启进程或者启动新进程使之活动所有的信息。主要包括括，指向可执行文件的指针,栈,内存(数据段和堆),进程状态, 优先级, 程序I/O的状态, 授予权限, 调度信息, 审计信息, 有关资源的信息(文件描述符和读/写指针), 关事件和信号的信息, 寄存器组(栈指针, 指令计数器)等等, 诸如此类。(当一个进程在执行时,CPU的所有寄存器中的值、进程的状态以及堆栈中的内容被称 为该进程的上下文。)</p><h5 id="4-2-上下文切换"><a href="#4-2-上下文切换" class="headerlink" title="4.2 上下文切换"></a>4.2 上下文切换</h5><p>上下文切换就是从当前执行任务切换到另一个任务执行的过程。但是，为了确保下次能从正确的位置继续执行，在切换之前，会保存上一个任务的状态。在切换的过程中，操作系统需要先存储当前进程的状态(包括内存空间的指针，当前执行完的指令等等)，再读入下一个进程的状态，然后执行此进程。 进程切换分为两步：<br>（1）切换页目录以使用新的地址空间<br>（2）切换内核栈和硬件上下文</p><ul><li>挂起一个进程，将这个进程的cpu中的状态（上下文）存储于内存中的某处。</li><li>在内存中检索下一个进程的上下文将其在cpu的寄存器恢复</li><li>跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程</li></ul><h5 id="4-3-进程上下文切换和线程上下文切换的区别"><a href="#4-3-进程上下文切换和线程上下文切换的区别" class="headerlink" title="4.3 进程上下文切换和线程上下文切换的区别"></a>4.3 进程上下文切换和线程上下文切换的区别</h5><p>进程上下文切换与线程上下文切换最主要的区别就是线程的切换虚拟空间内存是相同的（因为都是属于自己的进程），但是，进程切换的虚拟空间内存则是不同的。 同时，这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。</p><p>切换的性能消耗：</p><p>1、线程上下文切换和进程上下问切换一个最主要的区别是线程的切换虚拟内存空间依然是相同的，但是进程切换是不同的。这两种上下文切换的处理都是通过操作系统内核来完成的。内核的这种切换过程伴随的最显著的性能损耗是将寄存器中的内容切换出。</p><p>2、另外一个隐藏的损耗是上下文的切换会扰乱处理器的缓存机制。简单的说，一旦去切换上下文，处理器中所有已经缓存的内存地址一瞬间都作废了。还有一个显著的区别是当你改变虚拟内存空间的时候，处理的页表缓冲（processor’s Translation Lookaside Buffer (TLB)）或者相当的神马东西会被全部刷新，这将导致内存的访问在一段时间内相当的低效。但是在线程的切换中，不会出现这个问题。</p><h3 id="2-2-进程的创建与结束"><a href="#2-2-进程的创建与结束" class="headerlink" title="2.2 进程的创建与结束"></a>2.2 进程的创建与结束</h3><p>进程的创建方式有两种：一种是由操作系统创建，一种是由父进程创建</p><blockquote><ol><li>为进程申请一个唯一的进程识别号和空白PCB（PCB是有限的，若PCB申请失败则创建失败）</li><li>为进程分配资源、为新进程的程序、数据、用户栈分配内存空间（如果资源不足，并不是创建失败，而是处于等待状态，等待资源。</li><li>初始化PCB，主要包括标志信息、状态信息、处理机信息等。</li><li>如果就绪队列能够接受新进程，就将进程插入就绪队列中</li></ol></blockquote><ul><li>fork函数在新的地址空间里创建进程：拷贝当前进程创建一个子进程。父子进程的区别仅在于PID、PPID、和某些资源和统计量 fork函数不需要参数，返回值是一个进程标识符。fork函数实际上最终是调用clone函数。</li><li>exec函数负责读取可执行文件并将其载入地址空间开始运行。</li><li>子进程完全复制了父进程的地址空间，包括堆栈段和数据段。但是子进程并未复制代码段，而是共用代码段。</li></ul><p><strong>写时拷贝</strong>：传统的fork系统调用直接把所有的资源复制给新创建的进程。Linux中使用写时拷贝，只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。在此之前只是以只读方式共享。</p><p>结束状态：进程从系统中消失，这可能因为正常结束或其他原因中断退出。进程结束时，系统首先置该进程为结束状态，然后进一步释放和回收资源。</p><blockquote><ol><li>根据被终止的标识符，检索PCB，从中读取进程状态</li><li>若进程处于执行状态，立即终止并置标志为真</li><li>若进程还有子孙进程，则终止子孙进程防止其不可控</li><li>将终止进程的所有资源释放给系统或父进程</li><li>将终止进程移除队列</li></ol></blockquote><h3 id="2-3-僵尸进程、孤儿进程、守护进程"><a href="#2-3-僵尸进程、孤儿进程、守护进程" class="headerlink" title="2.3 僵尸进程、孤儿进程、守护进程"></a>2.3 僵尸进程、孤儿进程、守护进程</h3><ul><li>僵尸进程：是指一个进程使用fork创建子进程，如果子进程退出，而父进程没有用wait或waitpid调用子进程的状态信息，子进程的进程描述符仍在系统中，这种进程被成为僵尸进程。</li><li>孤儿进程：指一个父进程退出后，而它的一个或多个子进程还在运行，那么那些进程将成为孤儿进程。孤儿进程将被init进程（进程号为1）所收养，并由init进程对他们完成状态收集工作</li><li>守护进程：守护进程是脱离于终端在后台运行的进程，守护进程脱离终端是为了避免进程在执行过程中在终端上显示并且不会被终端的信息打断。从被执行时开始运转，整个系统关闭时才退出。</li></ul><h3 id="2-4-进程间的通信（IPC）"><a href="#2-4-进程间的通信（IPC）" class="headerlink" title="2.4 进程间的通信（IPC）"></a>2.4 进程间的通信（IPC）</h3><ul><li>管道：<strong>父子进程</strong>通过管道<strong>单向通信</strong>的机制。没有名字、大小受限、无格式数据。</li><li>具名管道：FIFO，使互不相关的进程实现通信，管道可以路径名指定，文件系统可见。</li><li>消息队列：以消息链表形式出现，保存消息队列。相比管道独立于进程存在。不需要进程自己提供同步方法。进程有选择的接收消息。</li><li>共享内存：允许两个不相关的程序访问同一个逻辑内存。数据共享使进程间不用进行数据传送，没有亲缘关系的要求。但是没有同步机制。</li><li>socket：套接字也是一种进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信</li><li>信号量：信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制</li><li>信号：用于通知接收进程某个事件已经发生。</li></ul><h3 id="2-5-进程的调度"><a href="#2-5-进程的调度" class="headerlink" title="2.5 进程的调度"></a>2.5 进程的调度</h3><ol><li>低级调度（进程调度）：根据某种算法，将处理机分配给进程。</li><li>中级调度（内存调度）：暂时不能运行的进程挂起，释放内存资源，并把它们调到外存上去等待</li><li>高级调度（作业调度）：根据某种算法，把外存上的作业调入内存，并为之创建进程，分配处理机并执行</li></ol><h4 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h4><ol><li>先来先服务（FCFS）：算法简单，但效率低；对长作业比较有利，但对短作业不利（相对SJF 和高响应比）；有利于CPU繁忙型作业，而不利于I/O繁忙型作业。</li><li>短作业（进程）优先：对长作业不利，没有考虑紧迫程度</li><li>优先级：优先权太低的任务一直就绪，得不到运行，出现“饥饿”现象。</li><li>高响应比</li><li>时间片轮转：优点: 定时有响应，等待时间较短；缺点: 上下文切换次数较多；</li><li>多级反馈队列：时间片轮转算法和优先级调度算法</li></ol><h3 id="2-6-什么是线程"><a href="#2-6-什么是线程" class="headerlink" title="2.6 什么是线程"></a>2.6 什么是线程</h3><p>线程作为CPU调度的基本单位，节省时间（上下文切换）和空间（资源）</p><h3 id="2-7-多线程同步"><a href="#2-7-多线程同步" class="headerlink" title="2.7 多线程同步"></a>2.7 多线程同步</h3><ol><li>互斥锁：互斥锁它有上锁和解锁两个状态。互斥锁一般被设置为全局变量。打开互斥锁可以由某个线程获得，一旦获得，这个互斥锁就会被锁上，只有该线程有权打开其他想要获得互斥锁的线程，会等待直到互斥锁再次打开的时候。</li><li>条件变量：条件变量提供了一种线程间的通信机制：当某个共享数据达到某个值的时候，唤醒等待这个共享数据的线程</li><li>读写锁：一些程序中存在读者写者问题，某些资源的访问可能出现两种情况，一种是排他性的（独占），另一种操作访问是可以共享的，可以有多个线程同时去访问某个资源。</li><li>信号量：互斥锁只允许一个线程进入临界区，而信号量允许多个线程进入临界区。</li></ol><h3 id="2-8-多线程重入"><a href="#2-8-多线程重入" class="headerlink" title="2.8 多线程重入"></a>2.8 多线程重入</h3><ul><li>“可重入函数”是指可以由多个函数并发使用而不担心错误的函数。可重入函数可以在任意时刻被中断，稍后在继续运行，且不会丢失数据。</li><li>不可重入函数是指只能由一个任务占有，除非能确保函数互斥。</li></ul><h3 id="2-9-进程和线程的区别"><a href="#2-9-进程和线程的区别" class="headerlink" title="2.9 进程和线程的区别"></a>2.9 进程和线程的区别</h3><ol><li><p><strong>根本区别</strong>：进程是资源分配的基本单位，线程是CPU调度的基本单位。</p></li><li><p><strong>内存分配</strong>：进程有独立的地址空间，线程不会分配内存，只能共享进程的资源。</p></li><li><p><strong>资源开销</strong>：进程具有独立的代码和数据空间，开销大；同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。</p></li><li><p><strong>包含关系</strong>：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。</p></li><li><p><strong>影响关系</strong>：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。</p><p><a href="https://blog.csdn.net/u012218309/article/details/81912074">https://blog.csdn.net/u012218309/article/details/81912074</a></p><blockquote><p>创建线程和进程的步骤一样，只是最终传给clone()函数的参数不同。</p><p>在内核中创建的内核线程与普通的进程之间还有个主要区别在于：内核线程没有独立的地址空间，它们只能在内核空间运行。（Linux内核是个单内核）</p><p>在 Linux 中进程和线程实际上都是用一个结构体 <code>task_struct</code>来表示一个执行任务的实体。进程创建调用<code>fork</code> 系统调用，而线程创建则是 <code>pthread_create</code> 方法，但是这两个方法最终都会调用到 <code>do_fork</code> 来做具体的创建操作 ，区别就在于传入的参数不同。linux根本没有<strong>线程</strong>，它创建的就是进程，只不过通过参数指定多个进程之间共享某些资源（如虚拟内存、页表、文件描述符等），函数调用栈、寄存器等线程私有数据则独立。</p></blockquote><h3 id=""><a href="#" class="headerlink" title=""></a></h3></li></ol><h4 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h4><ul><li>协程不是被操作系统内核所管理，而完全是由程序所控制（也就是在用户态执行）。 这样带来的好处就是性能得到了很大的提升，不会像线程切换那样消耗资源。协程的开销远远小于线程的开销。</li><li>一个线程中可以有任意多个协程，但某一时刻只能有一个协程在运行，多个协程分享该线程分配到的计算机资源。</li><li>一旦创建完线程，你就无法决定他什么时候获得时间片，什么时候让出时间片了，你把它交给了内核。而协程编写者可以有可控的切换时机，很小的切换代价。</li></ul><h3 id="2-10-线程池的使用"><a href="#2-10-线程池的使用" class="headerlink" title="2.10 线程池的使用"></a>2.10 线程池的使用</h3><p>（1）高并发、任务执行时间短的业务，线程池线程数可以设置为CPU核数+1，减少线程上下文的切换<br>（2）并发不高、任务执行时间长的业务要区分开看<br>　　a）假如是业务时间长集中在IO操作上，也就是IO密集型的任务，因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，可以适当加大线程池中的线程数目，让CPU处理更多的业务<br>　　b）假如是业务时间长集中在计算操作上，也就是计算密集型任务，这个就没办法了，和（1）一样吧，线程池中的线程数设置得少一些，减少线程上下文的切换</p><ol><li>线程池可以减少线程创建和回收的时间。</li><li>当线程过多时，会抢占资源，线程池可以控制。</li><li>对线程一些简单管理如延迟运行很好控制。</li></ol><h3 id="2-11-哲学家就餐"><a href="#2-11-哲学家就餐" class="headerlink" title="2.11 哲学家就餐"></a>2.11 哲学家就餐</h3><h3 id="2-12-读者写者"><a href="#2-12-读者写者" class="headerlink" title="2.12 读者写者"></a>2.12 读者写者</h3><h3 id="2-13-生产者消费者"><a href="#2-13-生产者消费者" class="headerlink" title="2.13 生产者消费者"></a>2.13 生产者消费者</h3><h2 id="3-内存管理"><a href="#3-内存管理" class="headerlink" title="3. 内存管理"></a>3. 内存管理</h2><h3 id="3-1-内存管理机制"><a href="#3-1-内存管理机制" class="headerlink" title="3.1 内存管理机制"></a>3.1 内存管理机制</h3><h4 id="3-1-1-连续分配"><a href="#3-1-1-连续分配" class="headerlink" title="3.1.1 连续分配"></a>3.1.1 连续分配</h4><ol><li>单一连续分配：分配到内存固定区域，只适合单任务系统</li><li>固定分区分配：分配到内存中不同的固定区域，分区可以相等也可以不相等。内部碎片</li><li>动态分区分配：按程序的需要进程动态划分。外部碎片</li></ol><h5 id="空闲内存管理"><a href="#空闲内存管理" class="headerlink" title="空闲内存管理"></a>空闲内存管理</h5><ul><li>位图（bitmap）</li><li>空闲列表（free lists）</li></ul><h4 id="3-1-2-非连续分配"><a href="#3-1-2-非连续分配" class="headerlink" title="3.1.2 非连续分配"></a>3.1.2 非连续分配</h4><p>非连续分配（分页/分段）允许一个程序分散地装入到不相邻的内存分区中去</p><h5 id="1-分页管理"><a href="#1-分页管理" class="headerlink" title="1. 分页管理"></a>1. 分页管理</h5><p>内存分为大小固定的块，按物理结构划分，会有内部碎片</p><ul><li>进程中的块称为<strong>页</strong>，内存中的块称为<strong>页框</strong>。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框。</li><li>地址结构：页面+页内偏移量</li><li>页表： 为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表，记录页面在内存中对应的物理块号。页表一般放在内存中。若页表全部放在内存中，则存取一条数据或指令至少需要访问两次内存：一次访问页表，确定物理地址，第二次存取数据或指令</li></ul><h5 id="2-分段管理"><a href="#2-分段管理" class="headerlink" title="2. 分段管理"></a>2. 分段管理</h5><p>内存块的大小不固定，按逻辑结构划分，会有外部碎片</p><p>段式管理方式按照用户进程中的自然段划分逻辑空间（段内要求连续，段间不要求连续）</p><h5 id="3-段页式管理"><a href="#3-段页式管理" class="headerlink" title="3.段页式管理"></a>3.段页式管理</h5><p>基本分段和基本分页的结合，会有内部碎片。</p><p>作业的地址空间首先被分为若干个逻辑段，每一段再被分为若干个大小固定的页。</p><h3 id="3-2-快表和多级页表"><a href="#3-2-快表和多级页表" class="headerlink" title="3.2 快表和多级页表"></a>3.2 快表和多级页表</h3><ol><li>每次访问操作都需要进行逻辑地址到物理地址的转换，<strong>地址转换过程必须足够快，否则访存速度会降低</strong></li><li>每个进程引入了页表，用于存储映射机制，<strong>页表不能太大，否则内存利用率会降低</strong></li></ol><ul><li><p>快表/联想寄存器/TLB 在地址变换机构中的一个具有并行查找能力的高速缓冲存储器。用来存放当前访问的若干页表项，以加速地址变换的过程。主存中的页表称为慢表。</p></li><li><p>多级页表 一级页号+二级页号+业内偏移</p></li></ul><h3 id="3-3-分页机制和分段机制的区别、共同点"><a href="#3-3-分页机制和分段机制的区别、共同点" class="headerlink" title="3.3 分页机制和分段机制的区别、共同点"></a>3.3 分页机制和分段机制的区别、共同点</h3><p>非连续分配。寻址方式类似。</p><ul><li>分页产生内部碎片，分段产生外部碎片；</li><li>分页地址1维，分段地址2维。</li><li>分页按物理结构划分，大小固定；分段按逻辑结构划分，大小不固定</li></ul><h3 id="3-4-逻辑地址和物理地址"><a href="#3-4-逻辑地址和物理地址" class="headerlink" title="3.4 逻辑地址和物理地址"></a>3.4 逻辑地址和物理地址</h3><ul><li>物理地址：加载到内存地址寄存器中的地址，内存单元的真正地址。</li><li>逻辑地址：CPU生成的地址。逻辑地址是内部和编程使用的、并不唯一。它是相对于你当前进程数据段的地址（偏移地址），不和绝对物理地址相干。</li></ul><h3 id="3-5-CPU寻址"><a href="#3-5-CPU寻址" class="headerlink" title="3.5 CPU寻址"></a>3.5 CPU寻址</h3><p>快表-&gt;慢表（内存-&gt;硬盘）-&gt;物理地址</p><h3 id="3-6-虚拟内存"><a href="#3-6-虚拟内存" class="headerlink" title="3.6 虚拟内存"></a>3.6 虚拟内存</h3><h4 id="3-6-1-虚拟内存的作用"><a href="#3-6-1-虚拟内存的作用" class="headerlink" title="3.6.1 虚拟内存的作用"></a>3.6.1 虚拟内存的作用</h4><ol><li>虚拟内存将主存储器看成一个存储在磁盘上的地址空间的高速缓存，在主存中只保存活动区域，并根据需要在磁盘和主存储器之间来回传送数据。</li><li>为每个进程提供了一致的地址空间。</li><li>保护了每个进程的地址空间不被其他进程破坏。</li></ol><p>随着软件的不断增大，需要运行的程序往往大到内存无法容纳。应用交换技术并不是很高效（交换几GB的内存）。</p><p>虚拟内存使用了外存上的空间来扩充内存的空间，通过一定的换入换出，使得整个系统在逻辑上能够使用一个远远超出其物理内存大小的内存容量。</p><ul><li>虚拟存储器：对物理存储器的抽象，<strong>允许程序申请大于实际物理存储的内存</strong>，提供一致性的地址空间。基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统讲所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放要掉入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。</li><li>内存管理单元（Memory Management Unit， MMU），MMU把虚拟地址映射为物理内存地址。</li></ul><h4 id="3-6-2-局部性原理"><a href="#3-6-2-局部性原理" class="headerlink" title="3.6.2 局部性原理"></a>3.6.2 局部性原理</h4><ul><li>时间局部性：如果一条指令被执行或某个数据被访问过，那么不久以后该指令可能再次执行，该数据可能再次被访问</li><li>空间局部性：如果某个单元被访问过，那么不久之后它周围的空间也会被访问。</li></ul><h4 id="3-6-3-特征："><a href="#3-6-3-特征：" class="headerlink" title="3.6.3 特征："></a>3.6.3 特征：</h4><ol><li>多次性， 无需在作业时一次性全部装入内存，而是允许被分成多次调入内存运行</li><li>对换性，无需在作业运行时一直常驻内存，允许在作业的运行过程中，进行换进和换出</li><li>虚拟性，从逻辑上扩充内存的容量，用户看到的内存容量，远大于实际的内存容量</li></ol><h4 id="3-6-4虚拟内存技术的实现"><a href="#3-6-4虚拟内存技术的实现" class="headerlink" title="3.6.4虚拟内存技术的实现"></a>3.6.4虚拟内存技术的实现</h4><ul><li>一定容量的内存和外存</li><li>页表机制（或段表机制），作为主要的数据结构</li><li>中断机构，当用户程序访问到的部分尚未调入内存，则产生中断</li><li>地址变换机构（MMU），逻辑地址到物理地址的变换</li></ul><h3 id="3-7-页面置换算法"><a href="#3-7-页面置换算法" class="headerlink" title="3.7 页面置换算法"></a>3.7 页面置换算法</h3><ol><li>最佳页面置换算法：以后最长时间不访问的置换出</li><li>先进先出算法</li><li>LRU（最久未访问）算法：需要有寄存器或栈的支持。(实现方法：双向链表+hashmap)</li><li>LFU（最不频繁使用）算法：两个双向链表+hash</li><li>CLOCK算法：循环扫描缓冲区，像时钟的针一样转动。给每一帧关联一个使用位。当缺页错误出现时，首先检查指针指向的页面，如果R位是0就淘汰页面，并把新页面插入，然后表针前移；如果R位是1就清零前移。</li></ol><h2 id="4-死锁"><a href="#4-死锁" class="headerlink" title="4. 死锁"></a>4. 死锁</h2><p>多个进程因为竞争资源而造成的互相等待的僵局。</p><h3 id="4-1-死锁的四个条件"><a href="#4-1-死锁的四个条件" class="headerlink" title="4.1 死锁的四个条件"></a>4.1 死锁的四个条件</h3><ol><li>互斥：进程需要独占资源</li><li>不剥夺：进程所获资源未使用结束之前，不会被其他进程强行夺走</li><li>请求和保持：请求资源失败时不会释放已获得资源</li><li>循环等待：存在进程的循环等待链。</li></ol><h3 id="4-2-死锁的处理策略"><a href="#4-2-死锁的处理策略" class="headerlink" title="4.2 死锁的处理策略"></a>4.2 死锁的处理策略</h3><p>破坏四个条件。</p><ul><li>鸵鸟策略：解决死锁问题，代价很高，所以不去解决。</li><li>预防：银行家算法。将操作系统看作银行家，资源看作资金。每次进程请求资源时，系统会评估进程的最大需求资源，检查资源分配后系统是否处于安全状态，来决定是否分配资源。</li><li>检测：资源分配图简化。在图中找到既不阻塞有不是孤点的进程p。如果它请求的资源小于系统空闲资源，则消除其请求边和分配边，使之成为孤点。如果死锁发生，该图不可完全简化。</li></ul><h3 id="4-3-悲观锁和乐观锁"><a href="#4-3-悲观锁和乐观锁" class="headerlink" title="4.3 悲观锁和乐观锁"></a>4.3 悲观锁和乐观锁</h3><ul><li>悲观锁：它指的是对数据被外界（包括本系统当前的其他事务，以及来自外部系统的事务处理）修改持保守态度(悲观)，因此，在整个数据处理过程中，将数据处于锁定状态。悲观锁的实现，往往依靠数据库提供的锁机制.比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。</li><li>乐观锁：总认为不会产生问题，每次取数据的时候总认为不会有其他线程对数据进行修改。不会上锁，但在更新时会判断其他线程在这之前有没有对数据进行过修改。比较适合读取操作比较频繁的场景，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</li><li>乐观锁实现方式：1. 数据版本记录机制。2. CAS（compare and swap）算法，会有ABA问题。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-操作系统基础&quot;&gt;&lt;a href=&quot;#1-操作系统基础&quot; class=&quot;headerlink&quot; title=&quot;1. 操作系统基础&quot;&gt;&lt;/a&gt;1. 操作系统基础&lt;/h2&gt;&lt;h3 id=&quot;1-1-什么是操作系统&quot;&gt;&lt;a href=&quot;#1-1-什么是操作系统&quot; cla</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="操作系统" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="基础知识" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>C++知识点复习整理</title>
    <link href="http://yoursite.com/2021/02/26/C++/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2021/02/26/C++/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/</id>
    <published>2021-02-26T06:29:12.000Z</published>
    <updated>2021-03-19T06:12:57.441Z</updated>
    
    <content type="html"><![CDATA[<p>参考之前的笔记以及该<a href="https://leetcode-cn.com/leetbook/read/cpp-interview-highlights">leetbook</a>整理。</p><h2 id="一、编译内存相关"><a href="#一、编译内存相关" class="headerlink" title="一、编译内存相关"></a>一、编译内存相关</h2><h3 id="1-C-程序编译过程"><a href="#1-C-程序编译过程" class="headerlink" title="1. C++程序编译过程"></a>1. C++程序编译过程</h3><p>四个过程：预处理、编译、汇编、链接</p><ol><li>预处理：处理以#开头的指令（#define展开， #include递归包含， #if等条件编译指令，过滤注释，添加行号、文件标识名，#pragma保留）</li><li>编译：生成汇编代码（词法分析、语法分析、语义分析、源代码优化、代码生成、目标代码优化）</li><li>汇编：生成机器指令</li><li>链接：把每个模块的源代码独立编译，然后组装起来。（把一些指令对其他符号地址的引用加以修正，包括地址和空间分配、符号决议、和重定位等步骤）。每个目标文件除了拥有自己的数据和二进制代码以外，还提供了3个符号表。未解决符号表、导出符号表、地址重定向表。extern、static、普通变量和函数。<ul><li>静态链接：编译时期完成，将代码从静态链接库copy到最终的程序中。在程序执行时，这些代码会被装入该进程的虚拟地址空间中。</li><li>动态链接：对库函数的链接推迟到运行期。代码被放入动态链接库中，链接程序只是在最终的程序中记录了共享对象的名字等信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进程的地址空间中。</li><li>优缺点：静态链接浪费空间，更新困难，执行时运行速度快。动态链接节省内存，更新方便，但每次执行都需要链接，会有性能损失。</li></ul></li></ol><h3 id="2-C-内存管理"><a href="#2-C-内存管理" class="headerlink" title="2. C++ 内存管理"></a>2. C++ 内存管理</h3><p>c++内存分区：栈、堆、静态存储区、常量存储区和代码区</p><ul><li>栈：存放局部变量、函数参数、返回地址等。由编译器自动分配和释放</li><li>堆：动态申请的内存空间。malloc和free控制内存的分配和释放。如果程序执行结束还没有释放，则操作系统自动回收。</li><li>静态存储区：存放全局变量和静态变量。程序运行结束操作系统自动释放</li><li>常量存储区：存放常量，不允许修改，程序运行结束自动释放</li><li>代码区：存放代码，不允许修改，程序运行结束自动释放</li></ul><p>static const 常量应该存在常量区或代码区，编译器会在编译期间进行值替换，所以不能对其进行取地址操作。</p><h3 id="3-堆和栈的区别"><a href="#3-堆和栈的区别" class="headerlink" title="3. 堆和栈的区别"></a>3. 堆和栈的区别</h3><p>申请方式（效率）、内存连续性、存放内容、访问效率</p><ol><li>申请方式：栈是系统自动分配，剩余空间大于申请空间即申请成功，否则申请失败栈溢出，申请效率高。堆是人为申请，堆分配时沿空闲内存地址链表寻找第一个大于申请空间的节点分配给程序。再将其从链表中删除，之后将剩余空闲节点链接到连表上，申请效率低。</li><li>内存连续：栈在内存中是一段连续的地址空间（向低地址扩展），最大容量由系统设置好；堆在内存中的空间不连续（向高地址扩展）。受限于计算机系统中有效的虚拟内存，比较大。</li><li>存放内容：栈存放的是局部变量、函数参数、返回地址等。堆人为控制。</li><li>访问效率：访问堆的一个具体单元需要两次访问内存，一次取得指针，二次取得内容。栈只需要一次。此外，堆的内容被操作系统交换到外存的概率较大。</li></ol><h3 id="4-变量的区别"><a href="#4-变量的区别" class="headerlink" title="4. 变量的区别"></a>4. 变量的区别</h3><p>全局变量、局部变量、静态全局变量、静态局部变量的区别</p><p>C++变量根据定义的位置的不同，具有不同的作用域：全局作用域、局部作用域、语句作用域、类作用域、命名空间作用域和文件作用域。</p><p>从作用域看：</p><ul><li>全局变量：具有全局作用域。全局变量只需要在一个源文件中定义，就可以作用于所有的源文件。其他不包含全局变量定义的源文件需要用extern关键字再次声明该全局变量</li><li>静态全局变量：具有文件作用域。它与全局变量的区别在于如果程序包含多个源文件的话，它作用于定义它的源文件中，不能作用到其他源文件中。即使两个不同的源文件都定义了相同名字的静态全局变量，也是不同变量。</li><li>局部变量：具有局部作用域。在程序运行期间不是一直存在，只有在函数执行期间存在，执行完被销毁。</li><li>静态局部变量：具有局部作用域。只被初始化一次，之后一直存在到程序运行结束。</li></ul><p>从内存空间看：</p><ul><li>静态存储区：全局变量、静态全局变量、静态局部变量</li><li>栈：局部变量。</li></ul><p>附：</p><ul><li>静态变量和全局变量的区别：静态变量用static告知编译器，自己仅在变量的作用范围内可见。</li><li>静态变量和栈变量、堆变量的区别：静态变量存储在静态存储区，下次调用时仍是原来的值，而栈变量和堆变量不能保证。</li></ul><h3 id="5-对象创建限制在堆或栈"><a href="#5-对象创建限制在堆或栈" class="headerlink" title="5. 对象创建限制在堆或栈"></a>5. 对象创建限制在堆或栈</h3><p>C++类的对象的建立分为两种：静态建立和动态建立。</p><ul><li>静态建立：由编译器为对象在栈空间上分配空间，直接调用类的构造函数创造对象。</li><li>动态建立：使用new关键字在堆空间上创建对象。底层首先调用operator new()函数，在堆空间上寻找合适的内存并分配；然后调用类的构造函数创建对象。</li></ul><h4 id="5-1-限制对象只能创建在堆上"><a href="#5-1-限制对象只能创建在堆上" class="headerlink" title="5.1 限制对象只能创建在堆上"></a>5.1 限制对象只能创建在堆上</h4><p>构造函数设为protected，并提供一个public的静态函数来完成构造。</p><h4 id="5-2-限制对象只能创建在栈上"><a href="#5-2-限制对象只能创建在栈上" class="headerlink" title="5.2 限制对象只能创建在栈上"></a>5.2 限制对象只能创建在栈上</h4><p>将operator new()函数设置为私有。</p><h3 id="6-内存对齐"><a href="#6-内存对齐" class="headerlink" title="6. 内存对齐"></a>6. 内存对齐</h3><p>什么是内存对齐？对齐的原则？原因？优点？</p><h4 id="6-1-什么是内存对齐"><a href="#6-1-什么是内存对齐" class="headerlink" title="6.1 什么是内存对齐"></a>6.1 什么是内存对齐</h4><p>编译器将程序中的每个数据单元安排在字的整数倍的地址指向的内存空间之中。</p><h4 id="6-2-内存对齐的原则"><a href="#6-2-内存对齐的原则" class="headerlink" title="6.2 内存对齐的原则"></a>6.2 内存对齐的原则</h4><blockquote><ol><li><p>1.结构体内成员按自身按自身长度自对齐。<br>自身长度，如char=1，short=2，int=4，double=8,。所谓自对齐，指的是该成员的起始位置的内存地址必须是它自身长度的整数倍。如int只能以0,4,8这类的地址开始<br>2.结构体的总大小为结构体的有效对齐值的整数倍<br>结构体的有效对齐值的确定：<br>1）当未明确指定时，以结构体中最长的成员的长度为其有效值<br>2）当用#pragma pack(n)指定时，以n和结构体中最长的成员的长度中较小者为其值。数据成员、结构体和类的有效对齐值：自身对齐值和指定对齐值中小的那个值。影响各成员偏移与总大小<br>3） <strong>attribute((aligned (n)))，让所作用的结构成员对齐在n字节自然边界上。如果结构中有成员的长度大于n，则按照最大成员的长度来对齐。告诉编译器一个结构体或者类或者联合或者一个类型的变量(对象)分配地址空间时的地址对齐方式。也就是所，如 果将</strong>attribute**((aligned(m)))作用于一个类型，那么该类型的变量在分配地址空间时，其存放的地址一定按照m字节对齐(m必 须是2的幂次方)。并且其占用的空间，即大小,也是m的整数倍，以保证在申请连续存储空间的时候，每一个元素的地址也是按照m字节对齐。 影响整个结构的大小</p><p>**attribute__ ((packed))，取消结构在编译过程中的优化对齐，按照实际占用字节数进行对齐。</p></li><li><p>ps:Vc,Vs等编译器默认是#pragma pack(8)，所以测试我们的规则会正常；注意gcc默认是#pragma pack(4)，并且gcc只支持1,2,4对齐。套用三原则里计算的对齐值是不能大于#pragma pack指定的n值。</p></li></ol></blockquote><h4 id="6-3-内存对齐的原因"><a href="#6-3-内存对齐的原因" class="headerlink" title="6.3 内存对齐的原因"></a>6.3 内存对齐的原因</h4><ol><li>会对CPU的存取效率产生影响：比如有些平台CPU从内存中偶数地址开始读取地址，如果数据其实位置正好为偶数，则1个读取周期就可以读出一个int类型的值，而如果数据地址为奇数，那我们就需要两个读取周期独处数据，并对高地址和低地址进行拼凑，这在读取效率上显然已经落后很多了。</li><li>还有其他硬件设备的原因。</li></ol><h3 id="7-类的大小"><a href="#7-类的大小" class="headerlink" title="7. 类的大小"></a>7. 类的大小</h3><p>类的大小指类的实例化对象的大小。用sizeof对类型名操作时，结果是该类型的对象的大小。</p><p>计算原则：</p><ul><li>结构体的内存对齐原则</li><li>与普通成员变量有关，与成员函数和静态成员变量无关，因为它们被类的对象共享，不属于那个具体的对象。</li><li>虚函数对类的大小有影响，因为虚函数表指针。</li><li>虚继承对类的大小有影响，因为虚基表指针。</li><li>空类的大小为1，保证不同对象具有不同地址。</li></ul><h3 id="8-内存泄漏"><a href="#8-内存泄漏" class="headerlink" title="8. 内存泄漏"></a>8. 内存泄漏</h3><p>由于疏忽或错误导致程序未能释放已不再使用的内存。包括堆内存泄漏和系统资源泄露（scoket，bitmap…)</p><p>指针重新复制，类定义不规范。（释放对象数组、基类的析构函数应为虚函数。。。）</p><h3 id="9-防止内存泄露的方法"><a href="#9-防止内存泄露的方法" class="headerlink" title="9. 防止内存泄露的方法"></a>9. 防止内存泄露的方法</h3><p>内部封装+智能指针</p><p>内存检测工具：建立两个全局表，valid-value和valid-address，检测每个字节对应的值或地址是有有效。</p><h3 id="10-智能指针"><a href="#10-智能指针" class="headerlink" title="10 智能指针"></a>10 智能指针</h3><p>解决动态内存分配时带来的内存泄露以及多次释放同一内存空间提出来的。<memory></p><ul><li>shared_ptr:多个指针可以指向同一个对象，当最后一个指针对象离开作用域时，内存自动释放。use_count()查看引用个数，release()释放所有权。</li><li>unique_ptr:资源只能被一个指针占有，该指针不能拷贝构造和赋值，但可以进行移动构造和移动赋值构造。move()</li><li>weak_ptr:指shared_ptr指向的对象，解决循环引用问题。</li></ul><h4 id="10-1-智能指针的实现"><a href="#10-1-智能指针的实现" class="headerlink" title="10.1 智能指针的实现"></a>10.1 智能指针的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span> : </span><br><span class="line">T *_ptr;</span><br><span class="line"><span class="keyword">size_t</span> *_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SmartPtr(T *ptr = <span class="literal">nullptr</span>) : _ptr(ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr)</span><br><span class="line">&#123;</span><br><span class="line">_count = <span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">_count = <span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~SmartPtr()</span><br><span class="line">&#123;</span><br><span class="line">(*<span class="keyword">this</span>-&gt;_count)--;</span><br><span class="line"><span class="keyword">if</span> (*<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SmartPtr(<span class="keyword">const</span> SmartPtr &amp;ptr) <span class="comment">// 拷贝构造：计数 +1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line"><span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">(*<span class="keyword">this</span>-&gt;_count)++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SmartPtr &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr &amp;ptr) <span class="comment">// 赋值运算符重载 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr == ptr._ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr) <span class="comment">// 将当前的 ptr 指向的原来的空间的计数 -1</span></span><br><span class="line">&#123;</span><br><span class="line">(*<span class="keyword">this</span>-&gt;_count)--;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line"><span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">(*<span class="keyword">this</span>-&gt;_count)++; <span class="comment">// 此时 ptr 指向了新赋值的空间，该空间的计数 +1</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T &amp;<span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line">assert(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T *<span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line">assert(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">use_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="11-循环引用"><a href="#11-循环引用" class="headerlink" title="11. 循环引用"></a>11. 循环引用</h3><p>两个类中分别定义另一个类的共享指针，两个指针会互相指向对方的内存空间，导致内存无法释放。</p><p>使用weak_ptr解决问题。weak_ptr具有非拥有性，使用前先转化为shared_ptr.(项目1中httpdata与timernode)</p><h3 id="12-C-函数调用的压栈过程"><a href="#12-C-函数调用的压栈过程" class="headerlink" title="12. C++函数调用的压栈过程"></a>12. C++函数调用的压栈过程</h3><p>栈帧，也就是stackframe，其本质就是一种栈，只是这种栈专门用于保存函数调用过程中的各种信息。 寄存器ebp指向当前的栈帧的底部（高地址），寄存器esp指向当前的栈帧的顶部（低地址）</p><p>调用者的栈帧：<br>（1）参数入栈，从右往左（函数调用）<br>（2）函数调用结束后需要继续执行的指令地址压栈（保存现场）<br>被调用者：<br>（3）将老的（调用者的） %ebp 压入栈，此时 %esp 指向它<br>（4）将 %esp的值赋给%ebp,%ebp就有了新的值,它也指向存放老 %ebp 的栈空间<br>（5）分配一段空间用于存放本地变量</p><h2 id="二、语言对比"><a href="#二、语言对比" class="headerlink" title="二、语言对比"></a>二、语言对比</h2><h3 id="1-c-11新特性"><a href="#1-c-11新特性" class="headerlink" title="1. c++11新特性"></a>1. c++11新特性</h3><h4 id="1-1-auto类型推导"><a href="#1-1-auto类型推导" class="headerlink" title="1.1 auto类型推导"></a>1.1 auto类型推导</h4><p>自动类型推导，编译器在<strong>编译期间</strong>通过<strong>初始值</strong>推导出变量的类型，通过auto定义的变量必须有初始值。</p><h4 id="1-2-decltype类型推导"><a href="#1-2-decltype类型推导" class="headerlink" title="1.2 decltype类型推导"></a>1.2 decltype类型推导</h4><p>declare type的缩写，和auto一样，在编译期间进行类型推导。从表达式中推断出要定义的变量的类型。</p><p>区别：</p><ol><li>auto根据=右边的初始值推断出变量的类型，decltype根据表达式推断变量的类型，变量的初始值与表达式的值无关</li><li>auto要求变量必须初始化</li></ol><h4 id="1-3-lambda表达式（匿名函数）"><a href="#1-3-lambda表达式（匿名函数）" class="headerlink" title="1.3 lambda表达式（匿名函数）"></a>1.3 lambda表达式（匿名函数）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>](parameter <span class="built_in">list</span>) -&gt; <span class="keyword">return</span> type &#123;</span><br><span class="line">function body;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-4-范围for语句"><a href="#1-4-范围for语句" class="headerlink" title="1.4 范围for语句"></a>1.4 范围for语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (delaration : expression) &#123;</span><br><span class="line">statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>expression 必须是一个序列。拥有能返回迭代器的begin，end成员</li><li>delaration 定义一个变量，序列中每一个元素都能转化成该变量的类型。常用auto</li></ul><h4 id="1-5-右值引用"><a href="#1-5-右值引用" class="headerlink" title="1.5 右值引用"></a>1.5 右值引用</h4><p>右值引用：绑定到右值的引用，用&amp;&amp;来获得右值引用，右值引用智能绑定到要销毁的对象。</p><h4 id="1-6-标准库move函数"><a href="#1-6-标准库move函数" class="headerlink" title="1.6 标准库move函数"></a>1.6 标准库move函数</h4><p>通过该函数获得绑定到左值上的右值引用。</p><h4 id="1-7-智能指针"><a href="#1-7-智能指针" class="headerlink" title="1.7 智能指针"></a>1.7 智能指针</h4><h4 id="1-8-delete函数和default函数"><a href="#1-8-delete函数和default函数" class="headerlink" title="1.8 delete函数和default函数"></a>1.8 delete函数和default函数</h4><ul><li>=delete表示该函数不能被调用</li><li>=default表示编译器默认生成的函数</li></ul><h3 id="2-C和C-的区别"><a href="#2-C和C-的区别" class="headerlink" title="2. C和C++的区别"></a>2. C和C++的区别</h3><ul><li>面向过程：分析解决分析需要的步骤，并用函数将这些步骤实现。</li><li>面向对象：把构成问题的事物分解成各个对象，建立对象的目的不是完成一个步骤，而是描述某个事物在解决问题时的行为。</li></ul><p>区别和联系</p><ol><li>c语言是面向过程的编程。通过main函数来调用各个子函数，程序的执行顺序都是实现决定好的。C++面向对象编程，类是它的主要特点，过程的概念被淡化。以类驱动程序运行，将数据及操作封装在类中，以事件或消息来驱动对象执行处理。</li><li>应用领域：c语言主要应用于嵌入式领域、驱动开发等与硬件直接打交道的领域。C++可以用于应用层开发，用户界面开发等与操作系统打交道的领域。</li><li>C++既继承了c强大的底层操作特性，又被赋予了面向对象机制。特性繁多，多继承，值传递和引用传递的区分以及const关键字等等</li><li>C++对c语言的增强表现在：类型检查更为严格，增加了面向对象的机制、泛性编程的机制。异常处理、运算符重载，STL、命名空间等。</li></ol><h3 id="3-JAVA和C-的区别"><a href="#3-JAVA和C-的区别" class="headerlink" title="3. JAVA和C++的区别"></a>3. JAVA和C++的区别</h3><ul><li>语言特性<ul><li>指针。c++可以直接操作指针。</li><li>多重继承。C++支持多重继承。</li><li>数据类型和类。java完全面向对象，所有变量和函数必须是类的一部分。而C++允许将函数和变量定义成全局的。</li></ul></li><li>垃圾回收<ul><li>java具备垃圾回收机制，有效防止内存泄露</li></ul></li><li>应用场景<ul><li>java运行在虚拟机上，和开发平台无关。C++直接编译成可执行文件，是否跨平台在于用到的编译器是否有多平台的支持。</li><li>C++直接编译成可执行文件，运行效率比java高</li><li>java主要用来开发web应用，c++用在网络、并发编程等方面</li></ul></li></ul><h3 id="4-python和C-的区别"><a href="#4-python和C-的区别" class="headerlink" title="4. python和C++的区别"></a>4. python和C++的区别</h3><ul><li>语言<ul><li>python为脚本语言，解释执行，不需要经过编译。</li><li>C++是一种编译型语言，在特定的机器上编译后执行。</li></ul></li><li>运行效率<ul><li>c++运行效率高，安全稳定。直接编译成机器指令，其中还有优化。</li><li>python解释执行，和cpu之间多了解释器，</li></ul></li><li>开发效率<ul><li>python开发效率高，语法格式灵活。</li></ul></li></ul><h2 id="三、面向对象"><a href="#三、面向对象" class="headerlink" title="三、面向对象"></a>三、面向对象</h2><h3 id="1-什么是面向对象，面向对象的特性"><a href="#1-什么是面向对象，面向对象的特性" class="headerlink" title="1. 什么是面向对象，面向对象的特性"></a>1. 什么是面向对象，面向对象的特性</h3><p>面向对象：对象指的是某一事物，这些事物的抽象就是类，类中包含成员数据和成员方法。</p><p>面向对象的特性：</p><ul><li>封装：将具体的实现过程和数据封装成类，只能通过接口访问，降低耦合性。</li><li>继承：子类继承父类的特征和行为。子类有父类的非private方法或成员变量，子类可以对父类的方法进行重写，增加耦合性。被关键字final修饰的类不能被继承，成员不能被重写或修改</li><li>多态：不同继承类的对象，对同一消息能够做出不同反应。</li></ul><h3 id="2-重载、重写和隐藏的区别"><a href="#2-重载、重写和隐藏的区别" class="headerlink" title="2. 重载、重写和隐藏的区别"></a>2. 重载、重写和隐藏的区别</h3><ul><li>重载：同一可访问区内被声明几个具有不同参数列表（类型，数量，顺序）的同名函数，根据参数列表确定调用哪个函数，重载函数不关心返回类型</li><li>隐藏：指派生类的函数屏蔽了与其同名的基类函数。只要是同名函数，不管参数列表是否相同，基类函数都会被隐藏</li><li>重写：指派生类存在重新定义的函数。函数名、参数列表、返回类型都必须与基类函数相同，只有函数体不同，且基类函数有virtual关键字修饰</li></ul><h3 id="3-多态极其实现"><a href="#3-多态极其实现" class="headerlink" title="3. 多态极其实现"></a>3. 多态极其实现</h3><p>多态就是不同继承类的对象，对同一消息作出不同反应。</p><p>基类的指针指向派生类的对象，使得基类指针呈现不同的表现方式。</p><p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时会根据对象的实际类型来调用相应的函数。</p><h4 id="3-1-实现方法"><a href="#3-1-实现方法" class="headerlink" title="3.1 实现方法"></a>3.1 实现方法</h4><p>通过虚函数实现，虚函数的地址保存在虚函数表中，虚函数表的地址保存在虚函数的类的实例对象的内存空间中。</p><h4 id="3-2-实现过程"><a href="#3-2-实现过程" class="headerlink" title="3.2 实现过程"></a>3.2 实现过程</h4><ol><li>在类中用virtual关键字声明虚函数</li><li>存在虚函数的类都存在一个虚函数表，当创建一个类的对象时，该对象有一个指向该虚函数表的虚表指针。</li><li>当基类指针指向派生类对象，调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的函数。</li></ol><h2 id="四、关键字和库函数"><a href="#四、关键字和库函数" class="headerlink" title="四、关键字和库函数"></a>四、关键字和库函数</h2><h3 id="1-strlen-和sizeof的区别"><a href="#1-strlen-和sizeof的区别" class="headerlink" title="1. strlen 和sizeof的区别"></a>1. strlen 和sizeof的区别</h3><ol><li><p>strlen是头文件<cstring>中的库函数，sizeof是c++的运算符。</p></li><li><p>strlen测量的是字符串的实际长度，以’\0’结束，sizeof测量的是字符数组的分配大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(arr) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若字符数组作为函数的形参，sizeof(arr)被当作字符指针来处理，strlen(arr)中arr依然是字符数组。</p></li><li><p>strlen是库函数，在运行时确定长度。sizeof是运算符，在编译时计算长度。</p></li><li><p>sizeof的参数可以是类型，也可以是变量。strlen的参数必须是char*类型的变量。</p></li></ol><h3 id="2-explict的作用"><a href="#2-explict的作用" class="headerlink" title="2. explict的作用"></a>2. explict的作用</h3><p>用来声明类的构造函数是显式调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可以用来修饰<strong>单参构造函数</strong>。</p><h3 id="3-static的作用"><a href="#3-static的作用" class="headerlink" title="3. static的作用"></a>3. static的作用</h3><p>static用来修饰静态变量和静态函数</p><ul><li>保持变量内容持久：static修饰局部变量时，改变了其声明周期，使得该变量存在于定义后知道程序结束运行的时间内。</li><li>隐藏：static修饰全局变量和函数时，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用。</li><li>static作用于类的成员变量和成员函数时，使得类变量或者类成员函数和类有关。不用定义类的对象就可以通过类访问这些静态成员。注意类的静态成员函数中只能访问静态成员变量和静态成员函数，不能将类的静态成员函数定义为虚函数。继承时父类子类的static变量是同一个。</li></ul><h3 id="4-static在类中的使用"><a href="#4-static在类中的使用" class="headerlink" title="4. static在类中的使用"></a>4. static在类中的使用</h3><ul><li>static静态成员变量<ol><li>静态成员变量是在类内进行声明，类外进行定义和初始化。在类外定义和初始化时不能出现static、private等关键字</li><li>静态成员变量被类的所有对象共享，<strong>包括派生类的对象</strong></li><li>静态成员变量可以作为成员函数的参数。</li><li>静态成员变量的类型可以是所属类的类型。普通的只能是指针或引用。</li></ol></li><li>static静态成员函数<ol><li>静态成员函数不能调用非静态成员变量或非静态成员函数，因为静态成员函数没有this指针。静态成员函数作为类作用域的全局函数</li><li>静态成员函数不能声明为虚函数virtual，const函数和volatile函数</li></ol></li></ul><h3 id="5-const作用及用法"><a href="#5-const作用及用法" class="headerlink" title="5. const作用及用法"></a>5. const作用及用法</h3><ul><li>作用<ol><li>const修饰成员变量，定义成const常量，相较于宏常量，可进行类型检查、节省内存空间、提高效率。</li><li>const修饰函数参数，使得传递过来的函数参数的值不能被改变。</li><li>const修饰成员函数，使得成员函数不能修改任何类型的成员变量，<strong>mutable修饰的成员变量除外</strong>，也不能调用非const成员函数。</li></ol></li><li>用法<ol><li>const成员变量<ol><li>const成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。</li><li>const成员变量只在某个对象的生命周期内是是常量，对于整个类而言是可变的，所以不能在类声明中初始化const成员变量</li></ol></li><li>const成员函数<ol><li>不能修改成员变量的值，除非有mutable修饰，只能访问成员变量。</li><li>不能调用非const成员函数</li></ol></li></ol></li></ul><h3 id="6-define和const的区别"><a href="#6-define和const的区别" class="headerlink" title="6. define和const的区别"></a>6. define和const的区别</h3><ul><li>编译阶段：define是在预处理阶段进程替换，const是在编译阶段确定其值。</li><li>安全性：define定义的宏常量没有数据类型，只是进行简单的替换，不会进行安全检查。const是有类型的，类型检查能避免一些简单的错误。</li><li>内存占用：define定义的宏常量在程序中使用多少次就会发生多少次替换，内存中就会有多少次备份，占用代码段的空间；const定义的常量存储在静态存储区，运行过程中只有一份</li><li>调试：define定义的宏常量不能调试，因为在预处理阶段就已经替换了，const定义的常量可以进行调试。</li></ul><h3 id="7-define和typedef的区别"><a href="#7-define和typedef的区别" class="headerlink" title="7. define和typedef的区别"></a>7. define和typedef的区别</h3><ul><li><p>原理：#define作为预处理指令，在预处理阶段进行替换，不做正确性检查，只有在编译被展开的源程序时才会发现可能的错误并报错。typedef是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型起别名，但不能在一个函数定义里面使用typedef。</p></li><li><p>功能：typedef用来定义类型的别名，方便使用。#define不仅可以为类型取别名，还可以定义常量、变量、编译开关等</p></li><li><p>指针操作：在处理指针是完全不一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTPTR1 int *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> * INTPTR2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INTPTR1 p1, p2; <span class="comment">// p1: int *; p2: int</span></span><br><span class="line">    INTPTR2 p3, p4; <span class="comment">// p3: int *; p4: int *</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> INTPTR1 p5 = &amp;var; <span class="comment">// 相当于 const int * p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。</span></span><br><span class="line">    <span class="keyword">const</span> INTPTR2 p6 = &amp;var; <span class="comment">// 相当于 int * const p6; 指针常量，不可使 p6 再指向其他内容。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-inline作用及使用方法"><a href="#8-inline作用及使用方法" class="headerlink" title="8. inline作用及使用方法"></a>8. inline作用及使用方法</h3><ul><li>作用：inline是一个关键字，用来定义内联函数。内联函数能够像普通函数一样被调用，但是并不通过函数调用机制，而是直接在调用点展开，这样可以减少由函数调用带来的开销，从而提高程序的运行效率。</li><li>使用方法：<ol><li>类内定义成员函数默认是内联函数</li><li>类外定义成员函数，若想定义为内联函数，需用关键字声明</li></ol></li></ul><h3 id="9-define和inline的区别"><a href="#9-define和inline的区别" class="headerlink" title="9. define和inline的区别"></a>9. define和inline的区别</h3><ul><li>编译阶段： define是在预处理阶段展开，inline是在编译时展开。</li><li>安全性：宏只是简单的文本替换，不会对参数的类型、语句等能否进行正常编译进行检查。而内联函数是真正的函数，会进行检查。</li><li>内联函数式真正的函数，避免了函数参数的压栈操作，减少调用的开销。宏定义编写较为复杂，常需要括号来避免歧义</li></ul><h3 id="10-new、delete和malloc、free的区别"><a href="#10-new、delete和malloc、free的区别" class="headerlink" title="10. new、delete和malloc、free的区别"></a>10. new、delete和malloc、free的区别</h3><p>new和delete搭配使用，malloc和free搭配使用</p><ul><li>malloc、free式库函数，new和delete是关键字</li><li>申请空间大小：new申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算。malloc在申请空间时，需要确定所申请空间的大小。</li><li>返回类型：new申请空间时，返回的类型是对象的指针类型，无需强制类型转换，类型安全；malloc返回void*类型，需要进行强制类型转换。</li><li>错误类型：new申请失败时，会抛出bad_alloc异常，malloc返回空指针。</li><li>自定义类型：new先调用operator new() 函数申请空间，然后调用构造函数初始化，最后返回自定义类型的指针。delete先调用析构函数，在调用operator delete() 释放空间。malloc、free无法进行自定义类型的构造和析构。</li><li>new从自由存储区上为对象动态分配内存，malloc函数从堆上动态分配内存。</li></ul><blockquote><p>附：指针的作用，指示指向对象的地址和长度，类型代表长度，值代表地址。不能对void*进行解引用操作。</p><p>如果函数的参数可以是任意类型的指针，可以将其声明为void*。</p><p>void类型指针可以指向任意类型的数据，即可以用任意数据类型的指针对void指针赋值。</p></blockquote><h3 id="11-struct和union的区别"><a href="#11-struct和union的区别" class="headerlink" title="11. struct和union的区别"></a>11. struct和union的区别</h3><p>struct是结构体，union是联合体</p><p>区别：</p><ol><li>struct和union都是由若干个数据类型不同的成员组成的。使用时联合体只有一个有效的成员，而结构体所有成员有效。</li><li>对联合体的成员赋值，会覆盖其他成员的值。结构体成员互不影响</li><li>联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小。结构体的大小遵循内存对齐原则</li></ol><h3 id="12-class和struct的异同"><a href="#12-class和struct的异同" class="headerlink" title="12. class和struct的异同"></a>12. class和struct的异同</h3><ul><li>class和struct都可以定义数据类型，支持继承操作</li><li>struct中默认访问级别是public，继承级别也是public。class的都是private</li><li>class可以用于定义模板参数，struct不能</li></ul><h3 id="13-volatile"><a href="#13-volatile" class="headerlink" title="13. volatile"></a>13. volatile</h3><p>对象的值可能在程序的控制或检测之外被改动时，应定义为volatile。告知编译器不对其优化。</p><p>每次都去内存中读取，而不用上次的寄存器的内容。</p><h2 id="五、类相关"><a href="#五、类相关" class="headerlink" title="五、类相关"></a>五、类相关</h2><h3 id="1-什么是虚函数？什么是纯虚函数？"><a href="#1-什么是虚函数？什么是纯虚函数？" class="headerlink" title="1. 什么是虚函数？什么是纯虚函数？"></a>1. 什么是虚函数？什么是纯虚函数？</h3><ul><li>虚函数：用virtual关键字修饰的成员函数</li><li>纯虚函数：纯虚函数在类中声明时加上=0；含有纯虚函数的类叫做抽象类，类中只有接口，没有实现；派生类如果没有完全实现基类中的纯虚函数依然是抽象类。</li><li>抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；可以声明抽象类指针、引用；</li></ul><h3 id="2-虚函数的实现机制"><a href="#2-虚函数的实现机制" class="headerlink" title="2. 虚函数的实现机制"></a>2. 虚函数的实现机制</h3><p>虚函数通过虚函数表实现。虚函数的地址保存在虚函数表中，类的对象中有虚表指针。通过虚表指针可找到虚函数表，进而遍历找到要调用的函数。</p><p>在编译阶段建立虚函数表，虚表指针放在对象的内存空间中最前面的位置，以保证正确取到虚函数的偏移量。</p><h3 id="3-多继承下的虚函数表"><a href="#3-多继承下的虚函数表" class="headerlink" title="3. 多继承下的虚函数表"></a>3. 多继承下的虚函数表</h3><ol><li>在多继承下，有多少个虚函数的基类就有多少个虚表指针</li><li>当子类有多出来的虚函数时，添加在第一个虚表中，父类指针不能调用。</li><li>当有多个虚函数表时，虚函数表的结果是0代表没有下一个虚函数表。其他位置看实现方式。</li></ol><h3 id="4-构造函数、析构函数是否需要定义成虚函数？"><a href="#4-构造函数、析构函数是否需要定义成虚函数？" class="headerlink" title="4. 构造函数、析构函数是否需要定义成虚函数？"></a>4. 构造函数、析构函数是否需要定义成虚函数？</h3><ul><li>构造函数不定义为虚函数<ul><li>存储空间：对象还没构造，找不到虚表指针。</li><li>类型：创建对象时需要明确类型。</li></ul></li><li>析构函数一般定义为虚函数：防止内存泄漏，当基类的指针或引用指向派生类的对象时，如果未定义成虚函数，会调用基类的析构函数，派生类中特有的成员变量就不会被释放。</li></ul><h3 id="5-多重继承容易出现的问题及解决方法"><a href="#5-多重继承容易出现的问题及解决方法" class="headerlink" title="5. 多重继承容易出现的问题及解决方法"></a>5. 多重继承容易出现的问题及解决方法</h3><p>命名冲突和数据冗余</p><p>命名冲突可以使用B::a，这样指出变量归属的方式来解决</p><p>数据冗余使用虚继承解决。</p><h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><p><a href="https://blog.csdn.net/longlovefilm/article/details/80558879">https://blog.csdn.net/longlovefilm/article/details/80558879</a></p><p><a href="https://blog.csdn.net/chengonghao/article/details/51701290">https://blog.csdn.net/chengonghao/article/details/51701290</a></p><p>在继承方式前面加上virtual关键字。使派生类中不会保留同一基类的多份拷贝。</p><h4 id="虚继承的实现机制"><a href="#虚继承的实现机制" class="headerlink" title="虚继承的实现机制"></a>虚继承的实现机制</h4><p>虚基类表：记录虚基类与本类的偏移量。通过偏移量找到虚基类成员。这样避免多份拷贝（不同类的偏移量不同）</p><p>虚基类指针：在对象中，指向虚基类表</p><p>多重继承时，会继承多个虚基类指针。</p><h3 id="6-空类占多少字节？编译器会自动给空类生成哪些函数？"><a href="#6-空类占多少字节？编译器会自动给空类生成哪些函数？" class="headerlink" title="6. 空类占多少字节？编译器会自动给空类生成哪些函数？"></a>6. 空类占多少字节？编译器会自动给空类生成哪些函数？</h3><p>空类声明时编译器不会生成任何成员函数。只会生成一个字节的占位符。</p><p>空类定义是编译器会自动生成6个成员函数。缺省的构造函数、拷贝构造函数、析构运算函数、复制运算符和两个取地址运算符。</p><h3 id="7-拷贝构造函数必须为引用？"><a href="#7-拷贝构造函数必须为引用？" class="headerlink" title="7. 拷贝构造函数必须为引用？"></a>7. 拷贝构造函数必须为引用？</h3><p>避免无限制的递归，最终导致栈溢出。</p><h3 id="8-C-类对象的初始化顺序"><a href="#8-C-类对象的初始化顺序" class="headerlink" title="8. C++类对象的初始化顺序"></a>8. C++类对象的初始化顺序</h3><ul><li>构造函数调用顺序：<ol><li>按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数</li><li>按照派生类中成员变量的声明顺序，依次调用派生类中成员变量所属类的构造函数</li><li>执行派生类自身的构造函数</li></ol></li><li>类对象的初始化顺序：基类构造函数-&gt;派生类成员变量的构造函数-&gt;自身的构造函数</li><li>注意：<ul><li>基类构造函数的调用顺序与派生类的派生列表中的顺序有关。</li><li>成员变量的初始化顺序与声明顺序有关。</li><li>析构顺序与构造顺序相反。</li></ul></li></ul><h3 id="9-为什么使用成员初始化列表会快"><a href="#9-为什么使用成员初始化列表会快" class="headerlink" title="9. 为什么使用成员初始化列表会快"></a>9. 为什么使用成员初始化列表会快</h3><p>数据类型可分为内置类型和用户自定义类型（类类型），对于用户自定义类型，利用成员初始化列表效率高。</p><p>用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，因为 C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，那么在执行构造函数的函数体之前首先调用默认的构造函数为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。因此，使用列表初始化会减少调用默认的构造函数的过程，效率高。</p><h3 id="10-实例化一个对象需要哪几个阶段"><a href="#10-实例化一个对象需要哪几个阶段" class="headerlink" title="10. 实例化一个对象需要哪几个阶段"></a>10. 实例化一个对象需要哪几个阶段</h3><ol><li>分配空间：创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象，静态对象，分配在栈区域内的对象，在编译阶段进行内存分配。存储在堆空间的对象是在运行阶段进行内存分配。</li><li>初始化：初始化发生在赋值之前，赋值是在对象初始化好后，为其赋上相应的值。初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程。</li><li>赋值：对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。</li></ol><p>注意：对于拥有虚函数的类的对象，还需要给虚表指针赋值。</p><ul><li>没有继承关系的类，分配完内存后，首先给虚表指针赋值，然后在进行初始化和赋值操作。</li><li>有继承关系的类，分配完内存后，先执行基类的构造，再给虚表指针赋值，最后进行初始化和赋值操作。</li></ul><h3 id="11-友元的作用及使用场景"><a href="#11-友元的作用及使用场景" class="headerlink" title="11. 友元的作用及使用场景"></a>11. 友元的作用及使用场景</h3><p>友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享机制。通过友元，一个不同函数或另一个类的成员函数能够访问到类中的私有成员和保护成员</p><h3 id="12-静态绑定和动态绑定"><a href="#12-静态绑定和动态绑定" class="headerlink" title="12. 静态绑定和动态绑定"></a>12. 静态绑定和动态绑定</h3><ul><li><p>静态类型：变量在声明时的类型，是在编译阶段确定的。静态类型不能更改。</p></li><li><p>动态类型：目前所知对象的类型，在运行阶段确定的。动态类型可以更改。</p></li><li><p>静态绑定：程序在编译阶段确定对象的类型</p></li><li><p>动态绑定：程序在运行阶段确定对象的类型</p></li></ul><p>对于类的成员函数，只有虚函数是动态绑定，其他都是静态绑定。</p><h3 id="13-深拷贝与浅拷贝"><a href="#13-深拷贝与浅拷贝" class="headerlink" title="13. 深拷贝与浅拷贝"></a>13. 深拷贝与浅拷贝</h3><p>如果一个类拥有资源，该类的对象进行复制时，如果资源重新分配就是深拷贝，否则就是浅拷贝。</p><ul><li>深拷贝：该对象和原对象占用不同的内存空间，既拷贝存储在栈中的内容，又拷贝存储在堆中的内容。</li><li>浅拷贝：该对象和原对象占用同一块内存空间，只拷贝存储在栈中的内容</li></ul><h3 id="14-编译时多态和运行时多态"><a href="#14-编译时多态和运行时多态" class="headerlink" title="14. 编译时多态和运行时多态"></a>14. 编译时多态和运行时多态</h3><ul><li>编译时多态：在程序编译过程中出现，发生在模板和函数重载中（泛性编程）</li><li>运行时多态：在程序运行过程中出现，发生在继承体系中，指通过基类的指针访问派生类的虚函数</li></ul><h2 id="六、语言特性相关"><a href="#六、语言特性相关" class="headerlink" title="六、语言特性相关"></a>六、语言特性相关</h2><h3 id="1-左值和右值的区别？左值引用和右值引用的区别？"><a href="#1-左值和右值的区别？左值引用和右值引用的区别？" class="headerlink" title="1. 左值和右值的区别？左值引用和右值引用的区别？"></a>1. 左值和右值的区别？左值引用和右值引用的区别？</h3><ul><li><p>左值：表达式结束后依然存在的持久对象。</p></li><li><p>右值：表达式结束就不存在的临时对象。</p></li><li><p>区别：左值持久、右值短暂</p></li><li><p>左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式上但不能绑定到左值上。</p></li><li><p>右值引用必须绑定到右值上，通过&amp;&amp;获得。该对象将要销毁，可以自由的移动其资源。</p></li><li><p>使用std::move()可以将一个左值强制转化为右值。继而通过右值引用使用该值，用于移动语义。</p></li></ul><p>移动构造为浅拷贝</p><h3 id="2-什么是野指针和空悬指针？"><a href="#2-什么是野指针和空悬指针？" class="headerlink" title="2. 什么是野指针和空悬指针？"></a>2. 什么是野指针和空悬指针？</h3><p>空悬指针：指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存。这个指针就是悬空指针。</p><p>野指针：未初始化，指向不确定。</p><h3 id="3-指针和引用的区别"><a href="#3-指针和引用的区别" class="headerlink" title="3. 指针和引用的区别"></a>3. 指针和引用的区别</h3><p>可变、占用空间、为空、多级</p><ul><li>指针的指向可变，引用一旦绑定就不能再改变</li><li>指针本身在内存中占有空间，引用是变量的别名，不占空间</li><li>指针可以为空，引用必须绑定对象</li><li>指针可以多级，引用只有一级。</li></ul><h3 id="4-常量指针和指针常量的区别"><a href="#4-常量指针和指针常量的区别" class="headerlink" title="4. 常量指针和指针常量的区别"></a>4. 常量指针和指针常量的区别</h3><p>常量指针本质上是指针，只不过这个指针指向的对象是常量。const在*左侧。</p><p>指针常量本质上是常量，常量的值是指针。const在*右侧。</p><h3 id="5-函数指针和指针函数的区别"><a href="#5-函数指针和指针函数的区别" class="headerlink" title="5. 函数指针和指针函数的区别"></a>5. 函数指针和指针函数的区别</h3><p>指针函数本质是函数，返回类型是指针。</p><p>函数指针本质上是指针，指针指向函数。</p><h3 id="6-强制类型转换"><a href="#6-强制类型转换" class="headerlink" title="6. 强制类型转换"></a>6. 强制类型转换</h3><h4 id="6-1-static-cast"><a href="#6-1-static-cast" class="headerlink" title="6.1 static_cast"></a>6.1 static_cast</h4><p>用于数据的强制类型转换，将一种数据类型强制转换为另一种</p><ul><li>基本数据类型</li><li>基类和派生类的指针（上行安全，下行不安全，建议用dynamic_cast)</li><li>空指针转化成目标类型的空指针</li><li>将任意类型的表达式转换成void类型</li></ul><h4 id="6-2-const-cast"><a href="#6-2-const-cast" class="headerlink" title="6.2 const_cast"></a>6.2 const_cast</h4><p>强制去掉const属性，用于指针或引用。（适用于处理常量字符串const char*）</p><h4 id="6-3-reinterpret-cast"><a href="#6-3-reinterpret-cast" class="headerlink" title="6.3 reinterpret_cast"></a>6.3 reinterpret_cast</h4><p>处理无关类型之间的转换。指针与整数之间的转换，无关类型指针之间的转换。</p><h4 id="6-4-dynamic-cast"><a href="#6-4-dynamic-cast" class="headerlink" title="6.4 dynamic_cast"></a>6.4 dynamic_cast</h4><pre><code>1. 其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时进行类型检查。2. 只能用于带虚函数的基类和派生类的指针或引用对象之间的转换。失败返回null。3. 在进行上行转换时和static_cast效果一样4. 具有类型检查的功能（typeid）。下行转换时只有指针指向的对象的类型和转化以后的对象类型相同时才会转化成功。</code></pre><h3 id="7-如何判断结构体是否相等？能否用memcmp函数判断"><a href="#7-如何判断结构体是否相等？能否用memcmp函数判断" class="headerlink" title="7. 如何判断结构体是否相等？能否用memcmp函数判断"></a>7. 如何判断结构体是否相等？能否用memcmp函数判断</h3><p>需要重载==，不能使用memcmp函数，因为当有内存对齐时，补位的字节内容是随机的，而memcmp是逐个字节进行比较的。</p><h3 id="8-模板"><a href="#8-模板" class="headerlink" title="8. 模板"></a>8. 模板</h3><p>可以是类型，也可以是值</p><ul><li>特化template&lt;&gt;</li><li>偏特化 部分特化</li></ul><h2 id="七、STL"><a href="#七、STL" class="headerlink" title="七、STL"></a>七、STL</h2><h3 id="1-STL组件及其关系"><a href="#1-STL组件及其关系" class="headerlink" title="1. STL组件及其关系"></a>1. STL组件及其关系</h3><p>STL六大组件：空间配置器、容器、迭代器、适配器、算法、仿函数</p><ul><li>容器通过空间配置器取得数据存储空间</li><li>算法通过迭代器取得容器内容</li><li>仿函数可以协助算法完成不同的策略变化</li><li>适配器可以修饰或套接仿函数。</li></ul><h3 id="2-空间配置器简单介绍"><a href="#2-空间配置器简单介绍" class="headerlink" title="2. 空间配置器简单介绍"></a>2. 空间配置器简单介绍</h3><p>空间配置器为程序分配空间。</p><p>空间配置器分为两级，第一级配置器直接使用malloc()与free()。第二级配置器则视情况采用不同的策略；当配置空间大于128b时，采用第一级配置器。当需要分配的空间小于128b时，则采用内存池的方式。其目的是为了降低额外负担，减少内存碎片。</p><p>涉及到单例模式（一个进程只需要一个空间配置器），享元模式（小块内存统一由内存池进行管理）</p><h4 id="2-1-第一级配置器"><a href="#2-1-第一级配置器" class="headerlink" title="2.1 第一级配置器"></a>2.1 第一级配置器</h4><ul><li>直接用malloc和free申请和释放内存</li><li>使用new_handler机制处理内存不足的情况</li></ul><h4 id="2-2-第二级配置器"><a href="#2-2-第二级配置器" class="headerlink" title="2.2 第二级配置器"></a>2.2 第二级配置器</h4><p>二级空间配置器避免了太多额外的小区造成的内存碎片</p><p>allocate 和 deallocate</p><ul><li>allocate：如果用户需要的区块大于128B，则直接调用第一级空间适配器；如果用户需要的区块小于等于128b，则到自由链表中去找；如果自由链表有，则直接取走，不然需要装填自由链表（refill）</li><li>deallocate：如果区块大于128，则直接由第一级空间配置器收回。如果区块小于等于128，则由自由链表收回。</li></ul><h5 id="2-2-1-内存分配"><a href="#2-2-1-内存分配" class="headerlink" title="2.2.1 内存分配"></a>2.2.1 内存分配</h5><ol><li>free_list中有多余内存。如果申请3个字节的内存，则所需空间大小提升为8的倍数，然后去free_list中查找相应的链表，如果free_list[i]不为空，则返回第一个元素，然后把头指针往后移。</li><li>free_list中没有空余，但是内存池不为空。首先检验内存池中的大小是不是比申请的内存大，比如申请20*8的内存，如果足够，则分配相应内存，将其中一个分配给用户使用，其它的挂在相应的free_list中。如果内存池不够大，只够几个内存分配，则就分配这几个，把相应的数据返回。如果连一个都不够则执行第三种情况。</li><li>free_list中没有空余，内存池也不够。调用malloc重新分配内存。分配时会多分配一倍的内存，把相应的内存挂到free_list下，剩余的放到内存池中。</li><li>free_list中没有空余，内存池也不够。malloc也失败。调用一级空间配置器，里面会有循环处理，或抛出异常。</li></ol><h5 id="2-2-2-内存回收"><a href="#2-2-2-内存回收" class="headerlink" title="2.2.2 内存回收"></a>2.2.2 内存回收</h5><p>当用户从二级空间配置器中申请的内存被释放时，二级空间配置器将回收的内存插入到对应的free_list中</p><h5 id="2-2-3-问题"><a href="#2-2-3-问题" class="headerlink" title="2.2.3 问题"></a>2.2.3 问题</h5><ul><li>内存碎片问题：比如用户需要3字节，会分配8字节，导致内存碎片</li><li>内存回收会把不用的内存放在free_list中，导致其他进程无法使用</li></ul><h5 id="2-2-4-注意"><a href="#2-2-4-注意" class="headerlink" title="2.2.4 注意"></a>2.2.4 注意</h5><p>空间配置器中所有的函数都是静态的，为什么？？如果这些函数不是静态的，如果我们要申请空间，岂不是也要创建一个空间配置器的对象，由对象来调用里面的函数，进而申请空间，如果这样的话，那空间就跟随者空间配置器对象的生命周期，那这个岂不是很麻烦，每次都要额外创建对象。所以把所有的函数都设置为静态的，就不需要创建对象就能够调用函数申请空间，并且可以保证在程序结束的时候空间才会被回收。</p><h3 id="3-迭代器简单介绍"><a href="#3-迭代器简单介绍" class="headerlink" title="3. 迭代器简单介绍"></a>3. 迭代器简单介绍</h3><p>STL的中心思想在于，将数据容器和算法分开，彼此独立设计，最后再将他们撮合在一起，而迭代器就扮演了这个黏胶角色。</p><p>迭代器是一种行为类似指针的对象，而指针行为中最常见的内容是提领（dereference）和成员访问（member access）因此迭代器最重要的工作就是对opreator* 和 opreator-&gt; 进行重载工作。</p><h3 id="4-容器"><a href="#4-容器" class="headerlink" title="4. 容器"></a>4. 容器</h3><h4 id="4-1-容器分类"><a href="#4-1-容器分类" class="headerlink" title="4.1 容器分类"></a>4.1 容器分类</h4><ul><li>序列化容器：array，vector，heap，priority_queue, list，slist（非标准），deque，stack（适配器），queue（适配器）</li><li>关联型容器：set，map，multiset，multimap，hashtable（非标准），hash_set（非标准），hash_map（非标准），hash_multiset（非标准），hash_multimap（非标准）</li></ul><h4 id="4-2-衍生"><a href="#4-2-衍生" class="headerlink" title="4.2 衍生"></a>4.2 衍生</h4><p>这里的衍生不是派生，是内含</p><ul><li>heap内部包含vector</li><li>priority_queue内部包含一个heap</li><li>stack/queue都包含一个deque</li><li>set/map/multiset/multimap内含一个RB-tree</li><li>hash_x内含一个hashtable</li></ul><h4 id="4-3-vector"><a href="#4-3-vector" class="headerlink" title="4.3 vector"></a>4.3 vector</h4><h5 id="4-3-1-vector的扩容机制"><a href="#4-3-1-vector的扩容机制" class="headerlink" title="4.3.1 vector的扩容机制"></a>4.3.1 vector的扩容机制</h5><p>新增元素：vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，再插入新增的元素。</p><p>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了</p><p>初始时刻vector的capacity为0，插入第一个元素后capacity增加为1.</p><p>不同的编译器实现扩容的方式不一样，GCC以2倍扩容。有些选择1.5</p><ul><li>vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好。</li><li>为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用，因为更好。</li></ul><h4 id="4-4-红黑树"><a href="#4-4-红黑树" class="headerlink" title="4.4 红黑树"></a>4.4 红黑树</h4><h5 id="4-4-1-红黑树的特性"><a href="#4-4-1-红黑树的特性" class="headerlink" title="4.4.1 红黑树的特性"></a>4.4.1 红黑树的特性</h5><ol><li>它是一棵二叉排序树<ol><li>若左子树不为空，则左子树上所有节点的值都小于等于跟节点的值</li><li>若右子树不为空，则右子树上所有节点的值都大于等于跟节点的值</li><li>左右子树分别也是二叉排序树。</li></ol></li><li>红黑树的要求<ol><li>树中节点非黑即红</li><li>根结点必须为黑节点</li><li>每个叶节点必须为黑节点</li><li>红节点的字节点必须为黑</li><li>从根出发任何路径上的黑节点数量相同</li></ol></li><li>查找时间为O(logN)</li></ol><h4 id="4-4-2-与AVL树，BST树的区别"><a href="#4-4-2-与AVL树，BST树的区别" class="headerlink" title="4.4.2 与AVL树，BST树的区别"></a>4.4.2 与AVL树，BST树的区别</h4><ul><li>相比于AVL(平衡二叉查找树），红黑树的平衡性要差一些。不过创建红黑树时所需的旋转操作也会少很多。相比于最简单的BST（二叉搜索树），BST最差情况下的查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn).所以说红黑树之所以能够在STL及Linux内核中被广泛应用就是因为其折中了两种方案，既减少了树高，又减少了建树时旋转的次数。</li><li>从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列……最长路径不会大于2n，这里路径长就是树高.</li><li>AVL最坏情况下也是O(logN),但是为了满足平衡性，需要更多的旋转操作，所以红黑树的统计性能要比AVL高。<strong>此外，由于红黑树的设计，任何不平衡都会在三次旋转之内解决</strong>（插入两次、删除三次）,O(logN)次变色。</li></ul><h4 id="4-5-hashtable"><a href="#4-5-hashtable" class="headerlink" title="4.5 hashtable"></a>4.5 hashtable</h4><p><code>hashtable</code>被视为一种字典结构，提供对于任何有名项的存取操作和删除操作。</p><p>如何避免array过大？是用某种映射函数，使得元素映射至“大小可以接受的索引”，这个函数被称为散列函数。使用散列函数必然会带来一个问题：可能有不同的元素被映射到相同的位置，这便是所谓的碰撞问题。</p><p>碰撞问题一般有两种方案：拉链法、线性探测法。</p><h3 id="5-仿函数"><a href="#5-仿函数" class="headerlink" title="5. 仿函数"></a>5. 仿函数</h3><p>仿函数本质就是类重载了一个operator()，创建一个行为类似函数的对象。</p><p>仿函数对象仅仅占用1字节，因为内部没有数据成员，仅仅是一个重载的方法而已。实际上可以通过传递函数指针实现类似的功能，但是为了和STL内部配合使用，他提供了仿函数的特性。</p><h3 id="6-适配器"><a href="#6-适配器" class="headerlink" title="6. 适配器"></a>6. 适配器</h3><p>STL中的stack，queue通过双端队列deque适配实现</p><p>map，set通过RB-Tree适配实现。</p><p>涉及适配器模式。</p><h3 id="7-sort函数"><a href="#7-sort函数" class="headerlink" title="7. sort函数"></a>7. sort函数</h3><p>快排 + 插入排序</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考之前的笔记以及该&lt;a href=&quot;https://leetcode-cn.com/leetbook/read/cpp-interview-highlights&quot;&gt;leetbook&lt;/a&gt;整理。&lt;/p&gt;
&lt;h2 id=&quot;一、编译内存相关&quot;&gt;&lt;a href=&quot;#一、编译内存</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="c++" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c/"/>
    
    
    <category term="基础知识" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>多线程编程</title>
    <link href="http://yoursite.com/2021/01/02/C++/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2021/01/02/C++/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2021-01-02T04:28:12.000Z</published>
    <updated>2021-03-19T06:12:57.441Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><h2 id="1-线程的启动、结束"><a href="#1-线程的启动、结束" class="headerlink" title="1. 线程的启动、结束"></a>1. 线程的启动、结束</h2><h3 id="1-1-线程运行的开始和结束"><a href="#1-1-线程运行的开始和结束" class="headerlink" title="1.1 线程运行的开始和结束"></a>1.1 线程运行的开始和结束</h3><ul><li>程序运行起来，生成一个进程，该进程所属的主线程开始自动运行；当主线程从main（）函数返回，则整个进程执行完毕</li><li>主线程从main（）开始执行，那么我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，线程也结束运行</li><li>整个进程是否执行完毕的标志是：主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了，此时如果其他子线程还没有执行完，也会被强行终止【此条有例外，以后会解释】</li></ul><h3 id="1-2-创建一个线程"><a href="#1-2-创建一个线程" class="headerlink" title="1.2 创建一个线程"></a>1.2 创建一个线程</h3><ol><li>包含头文件thread</li><li>写初始函数</li><li>在main中创建thread</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;my thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1. 创建线程，线程执行入口是func；2. 执行线程</span></span><br><span class="line">  <span class="function">thread <span class="title">mytobj</span><span class="params">(func)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 阻塞主线程兵等待mytobj执行完。之后主线程继续向下执行</span></span><br><span class="line">  <span class="comment">// join意为加入，汇合，子线程与主线程在此处汇合。</span></span><br><span class="line">  mytobj.join();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mytobj.detach();</span></span><br><span class="line">  <span class="comment">// 分离，主线程不在与子线程汇合，不再等待子线程。分离后，子线程和主线程失去关联，驻留在后台，由C++运行时库接管。（守护线程）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// joinable()判断是否可以使用join()或者detach()</span></span><br><span class="line">  <span class="keyword">if</span>(mytobj.joinable()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;可以调用join()或者detach()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不能调用join()或者detach()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>线程类参数是一个可调用对象。</strong></p></li><li><p>一组可执行的语句称为可调用对象，c++中的可调用对象可以是函数、函数指针、lambda表达式、bind创建的对象或者重载了函数调用运算符的类对象。</p></li><li><p>主线程执行完毕后，局部变量被销毁，内存被回收，如果子线程detach后，仍在引用或指向其中的变量，则会发生不可预知的错误。</p></li><li><p>bind绑定： <a href="https://www.cnblogs.com/jialin0x7c9/p/12219239.html">https://www.cnblogs.com/jialin0x7c9/p/12219239.html</a></p></li></ul><h3 id="1-3-其他创建线程的方法"><a href="#1-3-其他创建线程的方法" class="headerlink" title="1.3 其他创建线程的方法"></a>1.3 其他创建线程的方法</h3><ol><li><p>仿函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;my thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="function">thread <span class="title">mytobj</span><span class="params">(a)</span></span>;</span><br><span class="line">  mytobj.join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>lambda表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> a = []() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;my thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">mytobj</span><span class="params">(a)</span></span>;</span><br><span class="line">  mytobj.join();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>成员函数做线程函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> _i) : i(_i) &#123;&#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a) &#123;<span class="keyword">this</span>-&gt;i = a.i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">thread_work</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;my thread. num : &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 生成类对象</span></span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">mytobj</span><span class="params">(&amp;A::thread_work, a, <span class="number">15</span>)</span></span>; <span class="comment">// 拷贝a到子进程</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// thread mytobj(&amp;A::thread_work, ref(a), 15); 引用a到子进程</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  mytobj.join();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-4-创建和等待多个线程"><a href="#1-4-创建和等待多个线程" class="headerlink" title="1.4 创建和等待多个线程"></a>1.4 创建和等待多个线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;thread&gt; mythreads;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    mythreads.push_back(thread(func, i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = mythreads.begin(); it != mythreads.end(); ++it) &#123;</span><br><span class="line">    it-&gt;join();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>把thread对象放入到容器中管理，看起来像个thread对象数组，对一次创建大量的线程并对大量线程进行管理有好处</li><li>多个线程执行顺序是乱的，跟操作系统内部对线程的运行调度机制有关</li></ul><h2 id="2-线程传参"><a href="#2-线程传参" class="headerlink" title="2 线程传参"></a>2 线程传参</h2><h3 id="2-1-传递临时对象做线程参数"><a href="#2-1-传递临时对象做线程参数" class="headerlink" title="2.1 传递临时对象做线程参数"></a>2.1 传递临时对象做线程参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span>* pmybuff)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; pmybuff &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> mybuff[] = <span class="string">&quot;This is my test!&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">mytobj</span><span class="params">(func, var, mybuff)</span></span>; <span class="comment">// 如果是detach，可能会出现mybuff已经释放，但是子进程还在用。如果func参数类型是string，则有可能在隐式转换前释放的可能。</span></span><br><span class="line">  mytobj.join();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传引用用std::ref(), 否则线程会值传递。</li><li>detach时，指针会有问题。（指向的内存是一个）。</li><li>const 引用，可以接收右值</li></ul><h3 id="2-2-线程id"><a href="#2-2-线程id" class="headerlink" title="2.2 线程id"></a>2.2 线程id</h3><ul><li>id是个数字，每个线程（不管是主线程还是子线程）实际上都对应着一个数字，而且每个线程对应的这个数字都不一样</li><li>线程id可以用C++标准库里的函数来获取。std::this_thread::get_id()来获取</li></ul><h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><ul><li>如果传递int这种简单类型，推荐使用值传递，不要用引用</li><li>如果传递类对象，避免使用隐式类型转换，全部都是创建线程这一行就创建出临时对象，然后在函数参数里，用引用来接，否则还会创建出一个对象</li><li>不建议使用detach。</li></ul><h3 id="2-4-传递类对象作为线程参数"><a href="#2-4-传递类对象作为线程参数" class="headerlink" title="2.4 传递类对象作为线程参数"></a>2.4 传递类对象作为线程参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pmn)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; *pmn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">myp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">mytobj</span><span class="params">(func, move(myp))</span></span>; <span class="comment">// 将指针控制权交给子进程。detach可能会出错，内存泄漏</span></span><br><span class="line"></span><br><span class="line">  mytobj.join();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; (myp == <span class="literal">nullptr</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-互斥量"><a href="#3-互斥量" class="headerlink" title="3 互斥量"></a>3 互斥量</h2><h3 id="3-1-互斥量的用法"><a href="#3-1-互斥量的用法" class="headerlink" title="3.1 互斥量的用法"></a>3.1 互斥量的用法</h3><h4 id="3-1-1-incldue"><a href="#3-1-1-incldue" class="headerlink" title="3.1.1 #incldue "></a>3.1.1 #incldue <mutex></h4><h4 id="3-1-2-lock-unlock"><a href="#3-1-2-lock-unlock" class="headerlink" title="3.1.2 lock(), unlock()"></a>3.1.2 lock(), unlock()</h4><ul><li>lock(), 操作共享数据， unlock()</li><li>lock() 和 unlock() 成对使用。</li></ul><h3 id="3-1-3-lock-guard类模版"><a href="#3-1-3-lock-guard类模版" class="headerlink" title="3.1.3 lock_guard类模版"></a>3.1.3 lock_guard类模版</h3><ul><li>lock_guard<mutex> sbguard(myMutex); 取代lock() 和unlock()</li><li>lock_guard 构造函数执行了mutex::lock(), 在作用域结束时，调用析构函数，执行mutex::unlock()</li></ul><h3 id="3-2-死锁"><a href="#3-2-死锁" class="headerlink" title="3.2 死锁"></a>3.2 死锁</h3><p>只要保证多个互斥量上锁的顺序一样就不会造成死锁。</p><h4 id="3-2-1-std-lock-函数模板"><a href="#3-2-1-std-lock-函数模板" class="headerlink" title="3.2.1 std::lock()函数模板"></a>3.2.1 std::lock()函数模板</h4><ul><li>std::lock(mutex1, mutex2, …); 一次锁定多个互斥量，用于处理多个互斥量。</li><li>如果互斥量中有一个没锁住，他就会等待至所有互斥量都锁住才继续执行。如果一个没锁住就会把已经锁住的释放掉（要么都锁住，要么都没锁，防止死锁）</li></ul><h4 id="3-2-2-std-lock-guard-的std-adapt-lock参数"><a href="#3-2-2-std-lock-guard-的std-adapt-lock参数" class="headerlink" title="3.2.2 std::lock_guard()的std::adapt_lock参数"></a>3.2.2 std::lock_guard()的std::adapt_lock参数</h4><ul><li><pre><code>std::lock_guard&lt;std::mutex&gt; my_guard(my_mutex, std::adopt_lock);//加入adopt_lock后，在调用lock_guard的构造函数时，不会在进行lock()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ adopt_guard为结构体对象，起一个标记作用，表示这个互斥量已经lock()，不需要在lock()</span><br><span class="line"></span><br><span class="line">## 4 unique_lock</span><br><span class="line"></span><br><span class="line">### 4.1 unique_lock取代lock_guard</span><br><span class="line"></span><br><span class="line">unique_lock比lock_guard灵活很多（多出来很多用法），效率差一点</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">unique_lock&lt;mutex&gt; myUniLock(myMutex);</span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="4-2-unique-lock的第二个参数"><a href="#4-2-unique-lock的第二个参数" class="headerlink" title="4.2 unique_lock的第二个参数"></a>4.2 unique_lock的第二个参数</h3><h4 id="4-2-1-std-adopt-lock"><a href="#4-2-1-std-adopt-lock" class="headerlink" title="4.2.1 std::adopt_lock:"></a>4.2.1 std::adopt_lock:</h4><ul><li>表示这个互斥量已经被lock(),即不需要在构造函数中lock这个互斥量了。</li><li>前提：必须提前lock</li><li>lock_guard中也可以用这个参数</li></ul><h4 id="4-2-2-std-try-to-lock"><a href="#4-2-2-std-try-to-lock" class="headerlink" title="4.2.2 std::try_to_lock:"></a>4.2.2 std::try_to_lock:</h4><ul><li>尝试用mutex的lock()去锁定这个mutex，如果没有锁定成功，立即返回，不会阻塞</li><li>使用try_to_lock的原因是防止其他的线程锁定mutex太长时间，导致本线程一直阻塞在lock这个地方</li><li>前提：不能提前lock();</li><li>owns_locks()方法判断是否拿到锁，如拿到返回true</li></ul><h4 id="4-2-3-std-defer-lock"><a href="#4-2-3-std-defer-lock" class="headerlink" title="4.2.3 std::defer_lock:"></a>4.2.3 std::defer_lock:</h4><ul><li>如果没有第二个参数就对mutex进行加锁，加上defer_lock是始化了一个没有加锁的mutex</li><li>不给它加锁的目的是以后可以调用unique_lock的一些方法</li><li>前提：不能提前lock</li></ul><h3 id="4-3-unique-lock的成员函数（前三个与std-defer-lock联合使用）"><a href="#4-3-unique-lock的成员函数（前三个与std-defer-lock联合使用）" class="headerlink" title="4.3 unique_lock的成员函数（前三个与std::defer_lock联合使用）"></a>4.3 unique_lock的成员函数（前三个与std::defer_lock联合使用）</h3><h4 id="4-3-1-lock-加锁"><a href="#4-3-1-lock-加锁" class="headerlink" title="4.3.1 lock() 加锁"></a>4.3.1 lock() 加锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_lock&lt;mutex&gt; myUniLock(myMutex， defer_lock);</span><br><span class="line">myUniLock.lock();</span><br></pre></td></tr></table></figure><p>不用自己unlock()</p><h4 id="4-3-2-unlock-解锁"><a href="#4-3-2-unlock-解锁" class="headerlink" title="4.3.2 unlock() 解锁"></a>4.3.2 unlock() 解锁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock</span><span class="params">(myMutex， defer_lock)</span></span>;</span><br><span class="line">myUniLock.lock();</span><br><span class="line"><span class="comment">//处理一些共享代码</span></span><br><span class="line">myUniLock.unlock();</span><br><span class="line"><span class="comment">//处理一些非共享代码</span></span><br><span class="line">myUniLock.lock();</span><br><span class="line"><span class="comment">//处理一些共享代码</span></span><br></pre></td></tr></table></figure><p>因为一些非共享代码要处理，可以暂时先unlock()，用其他线程把它们处理了，处理完后再lock()。</p><h4 id="4-3-3-try-lock-尝试给互斥量加锁"><a href="#4-3-3-try-lock-尝试给互斥量加锁" class="headerlink" title="4.3.3 try_lock() : 尝试给互斥量加锁"></a>4.3.3 try_lock() : 尝试给互斥量加锁</h4><p>如果拿不到锁，返回false，否则返回true。</p><h4 id="4-3-4-release"><a href="#4-3-4-release" class="headerlink" title="4.3.4 release():"></a>4.3.4 release():</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock</span><span class="params">(myMutex)</span></span>;</span><br></pre></td></tr></table></figure><p>相当于把myMutex和myUniLock绑定在了一起，release()就是解除绑定，返回他所管理的mutex对象的指针，并释放所有权。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex* ptx = myUniLock.release();</span><br></pre></td></tr></table></figure><p>所有权由ptx接管，如果原来mutex对象处理加锁状态，就需要ptx在以后进行解锁了</p><p>lock的代码段越少，执行越快，整个程序的运行效率越高。</p><ol><li>锁住的代码少，叫做粒度细，执行效率高；</li><li>锁住的代码多，叫做粒度粗，执行效率低；</li></ol><h3 id="4-4-unique-lock所有权的传递"><a href="#4-4-unique-lock所有权的传递" class="headerlink" title="4.4 unique_lock所有权的传递"></a>4.4 unique_lock所有权的传递</h3><ol><li><p>使用move转移</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_lock <span class="title">myUniLock2</span><span class="params">(<span class="built_in">std</span>::move(myUniLock))</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在函数中return一个临时变量，即可实现转移</p></li><li><pre><code class="c++"><span class="function">unique_lock&lt;mutex&gt; <span class="title">aFunction</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock</span><span class="params">(myMutex)</span></span>;    <span class="comment">//移动构造函数那里讲从函数返回一个局部的unique_lock对象是可以的</span>    <span class="comment">//返回这种局部对象会导致系统生成临时的unique_lock对象，并调用unique_lock的移动构造函数</span>    <span class="keyword">return</span> myUniLock;&#125;&lt;!--code￼<span class="number">13</span>--&gt;</code></pre></li></ol><h2 id="6-条件变量"><a href="#6-条件变量" class="headerlink" title="6 条件变量"></a>6 条件变量</h2><h3 id="6-1-condition-variable"><a href="#6-1-condition-variable" class="headerlink" title="6.1 condition_variable"></a>6.1 condition_variable</h3><ul><li><p>std::condition_variable实际上是一个类，是一个和条件相关的类，说白了就是等待一个条件达成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mymutex1;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">sbguard1</span><span class="params">(mymutex1)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::condition_variable condition;</span><br><span class="line">condition.wait(sbguard1, [<span class="keyword">this</span>] &#123;<span class="keyword">if</span> (!msgRecvQueue.empty())</span><br><span class="line">                                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                                &#125;);</span><br><span class="line"> </span><br><span class="line">condition.wait(sbguard1);</span><br></pre></td></tr></table></figure></li><li><p>wait()用来等一个东西</p><ul><li>如果第二个参数的lambda表达式返回值是false，那么wait()将<strong>解锁互斥量，并阻塞到本行</strong></li><li>如果第二个参数的lambda表达式返回值是true，那么wait()直接返回并继续执行。</li><li>阻塞到什么时候为止呢？阻塞到其他某个线程调用notify_one()成员函数为止</li><li>如果没有第二个参数，那么效果跟第二个参数lambda表达式返回false效果一样</li><li>wait()将解锁互斥量，并阻塞到本行，阻塞到其他某个线程调用notify_one()成员函数为止。</li><li>当其他线程用notify_one()将本线程wait()唤醒后，这个wait恢复后<ol><li>wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待获取，如果获取到了，那么wait()就继续执行，获取到了锁</li><li>如果wait有第二个参数就判断这个lambda表达式。<ol><li>如果表达式为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify_one()唤醒</li><li>如果lambda表达式为true，则wait返回，流程可以继续执行（此时互斥量已被锁住）。</li></ol></li><li>如果wait没有第二个参数，则wait返回，流程走下去。</li></ol></li><li>流程只要走到了wait()下面则互斥量一定被锁住了。</li></ul></li><li><p>notify_one()：通知一个线程的wait()</p></li><li><p>notify_all()：通知所有线程的wait()</p></li></ul><h3 id="6-2-虚假唤醒"><a href="#6-2-虚假唤醒" class="headerlink" title="6.2 虚假唤醒"></a>6.2 虚假唤醒</h3><p>notify_one或者notify_all唤醒wait()后，实际有些线程可能不满足唤醒的条件，就会造成虚假唤醒，可以在wait中再次进行判断解决虚假唤醒。<br>解决：wait中要有第二个参数（lambda），并且这个lambda中要正确判断所处理的公共数据是否存在</p><h2 id="7-std-atomic-原子操作"><a href="#7-std-atomic-原子操作" class="headerlink" title="7 std::atomic 原子操作"></a>7 std::atomic 原子操作</h2><h3 id="7-1-互斥"><a href="#7-1-互斥" class="headerlink" title="7.1 互斥"></a>7.1 互斥</h3><ul><li>互斥量：多线程编程中 用于保护共享数据：先锁住， 操作共享数据， 解锁。</li><li>有两个线程，对一个变量进行操作，一个线程读这个变量的值，一个线程往这个变量中写值。即使是一个简单变量的读取和写入操作，如果不加锁，也有可能会导致读写值混乱（一条C语句会被拆成3、4条汇编语句来执行，所以仍然有可能混乱）</li></ul><h3 id="7-2-std-atomic"><a href="#7-2-std-atomic" class="headerlink" title="7.2 std::atomic"></a>7.2 std::atomic</h3><ul><li>大家可以把原子操作理解成一种：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。</li><li>原子操作：在多线程中不会被打断的程序执行片段。</li><li>从效率上来说，原子操作要比互斥量的方式效率要高。</li><li>互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是一个变量。</li><li>原子操作，一般都是指“不可分割的操作”；也就是说这种操作状态要么是完成的，要么是没完成的，不可能出现半完成状态。</li><li>std::atomic来代表原子操作，是个类模板。其实std::atomic是用来封装某个类型的值的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">atomic&lt;<span class="keyword">int</span>&gt; <span class="title">g_count</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">    ++g_count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(mythread)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(mythread)</span></span>;</span><br><span class="line">  t1.join();</span><br><span class="line">  t2.join();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; g_count &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 20000</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原子操作一般用于计数或者统计（如累计发送多少个数据包，累计接收到了多少个数据包），多个线程一起统计，这种情况如果不使用原子操作会导致统计发生混乱。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">atomic&lt;<span class="keyword">int</span>&gt; <span class="title">g_count</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">    g_count = g_count + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(mythread)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(mythread)</span></span>;</span><br><span class="line">  t1.join();</span><br><span class="line">  t2.join(); </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; g_count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般atomic原子操作，针对++，–，+=，-=，&amp;=，|=，^=是支持的，其他操作不一定支持。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; atm = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; atm &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>这里只有读取atm是原子操作，但是整个这一行代码 cout &lt;&lt; atm &lt;&lt; endl; 并不是原子操作，导致最终显示在屏幕上的值是一个“曾经值”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; atm = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> atm2 = atm; </span><br></pre></td></tr></table></figure><p>不可以拷贝初始化</p><p>load()：以原子方式读取atomic对象的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">atomic&lt;<span class="keyword">int</span>&gt; <span class="title">atm2</span><span class="params">(atm.load())</span></span>;</span><br><span class="line">atm2.store(<span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>原子操作实质上是：不允许在进行原子对象操作时进行CPU的上下文切换。</p><h2 id="8-chrono"><a href="#8-chrono" class="headerlink" title="8 chrono"></a>8 chrono</h2><p><a href="https://www.cnblogs.com/zlshmily/p/10058427.html">https://www.cnblogs.com/zlshmily/p/10058427.html</a></p><h3 id="8-1-std-chrono-duration"><a href="#8-1-std-chrono-duration" class="headerlink" title="8.1 std::chrono::duration"></a>8.1 std::chrono::duration</h3><p>一段时间</p><h3 id="8-2-std-chrono-time-point"><a href="#8-2-std-chrono-time-point" class="headerlink" title="8.2 std::chrono::time_point"></a>8.2 std::chrono::time_point</h3><h3 id="8-3-1-std-chrono-system-clock"><a href="#8-3-1-std-chrono-system-clock" class="headerlink" title="8.3.1 std::chrono::system_clock"></a>8.3.1 std::chrono::system_clock</h3><p>它表示当前的系统时钟，系统中运行的所有进程使用now()得到的时间是一致的。</p><h3 id="8-3-2-std-chrono-steady-clock"><a href="#8-3-2-std-chrono-steady-clock" class="headerlink" title="8.3.2 std::chrono::steady_clock"></a>8.3.2 std::chrono::steady_clock</h3><p>为了表示稳定的时间间隔，后一次调用now()得到的时间总是比前一次的值大（这句话的意思其实是，如果中途修改了系统时间，也不影响now()的结果），每次tick都保证过了稳定的时间间隔。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 介绍&lt;chrono&gt; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-- 一个精确中立的时间和日期库</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 时钟:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * std::chrono::system_clock:  依据系统的当前时间 (不稳定)</span></span><br><span class="line"><span class="comment"> * std::chrono::steady_clock:  以统一的速率运行(不能被调整)</span></span><br><span class="line"><span class="comment"> * std::chrono::high_resolution_clock: 提供最小可能的滴答周期</span></span><br><span class="line"><span class="comment"> *                   (可能是steady_clock或者system_clock的typedef)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * std:ratio&lt;&gt;表示时钟周期，即时间的计量单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ratio&lt;<span class="number">1</span>,<span class="number">10</span>&gt;  r; <span class="comment">// </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; r.num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; r.den &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; chrono::system_clock::period::num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; chrono::system_clock::period::den &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; chrono::steady_clock::period::num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; chrono::steady_clock::period::den &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; chrono::high_resolution_clock::period::num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; chrono::high_resolution_clock::period::den &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * std:chrono::duration&lt;&gt;:  表示持续的时间</span></span><br><span class="line"><span class="comment"> *    duration&lt;int, ratio&lt;1,1&gt;&gt; --  秒数存储在一个int中 (默认)</span></span><br><span class="line"><span class="comment"> *    duration&lt;double, ration&lt;60,1&gt;&gt; -- 分钟数储存在一个double中</span></span><br><span class="line"><span class="comment"> *    库中定义了如下方便的duration:</span></span><br><span class="line"><span class="comment"> *    nanoseconds, microseconds, milliseconds, seconds, minutes, hours</span></span><br><span class="line"><span class="comment"> * system_clock::duration  -- duration&lt;T, system_clock::period&gt;</span></span><br><span class="line"><span class="comment"> *                                 T是一个有符号的算术类型, 可以是int或long或其他</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">chrono::microseconds <span class="title">mi</span><span class="params">(<span class="number">2745</span>)</span></span>;</span><br><span class="line">chrono::nanoseconds na = mi;</span><br><span class="line">chrono::milliseconds mill = chrono::duration_cast&lt;chrono::milliseconds&gt;(mi);  <span class="comment">// 当可能发生信息丢失的时候，要显式地转换</span></span><br><span class="line">  <span class="comment">// 直接截断，而不是四舍五入</span></span><br><span class="line">mi = mill + mi;  <span class="comment">// 2000 + 2745 = 4745</span></span><br><span class="line">mill = chrono::duration_cast&lt;chrono::milliseconds&gt;(mill + mi);  <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; na.count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mill.count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mi.count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;min: &quot;</span> &lt;&lt; chrono::system_clock::duration::min().count() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;max: &quot;</span> &lt;&lt; chrono::system_clock::duration::max().count() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* std::chrono::time_point&lt;&gt;: 表示一个时间点</span></span><br><span class="line"><span class="comment"> *       -- 自从一个指定的时间点开始的过去的时间长度: </span></span><br><span class="line"><span class="comment"> *          00:00 January 1, 1970 (Corordinated Universal Time - UTC)  -- 时钟的纪元</span></span><br><span class="line"><span class="comment"> * time_point&lt;system_clock, milliseconds&gt;:  依据system_clock, 自从纪元开始经过的毫秒数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * typdefs</span></span><br><span class="line"><span class="comment">  system_clock::time_point  -- time_point&lt;system_clock, system_clock::duration&gt;</span></span><br><span class="line"><span class="comment">  steady_clock::time_point  -- time_point&lt;steady_clock, steady_clock::duration&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 使用系统时间</span></span><br><span class="line">chrono::system_clock::time_point tp = chrono::system_clock::now();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tp.time_since_epoch().count() &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">tp = tp + seconds(<span class="number">2</span>);  <span class="comment">// 因为tp精度高，不需要转换</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tp.time_since_epoch().count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算时间间隔最好用steady_clock</span></span><br><span class="line">chrono::steady_clock::time_point start = chrono::steady_clock::now();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am bored&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">chrono::steady_clock::time_point end = chrono::steady_clock::now();</span><br><span class="line">chrono::steady_clock::duration d = end - start;</span><br><span class="line"><span class="keyword">if</span> (d == chrono::steady_clock::duration::zero())    <span class="comment">//0时间长度的表示</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no time elapsed&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; duration_cast&lt;microseconds&gt;(d).count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="comment">// 使用system_clock可能得到不正确的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程编程&quot;&gt;&lt;a href=&quot;#多线程编程&quot; class=&quot;headerlink&quot; title=&quot;多线程编程&quot;&gt;&lt;/a&gt;多线程编程&lt;/h1&gt;&lt;h2 id=&quot;1-线程的启动、结束&quot;&gt;&lt;a href=&quot;#1-线程的启动、结束&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="c++" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c/"/>
    
    
    <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
    <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>buttfly主题</title>
    <link href="http://yoursite.com/2020/10/29/butterfly%E4%B8%BB%E9%A2%98/"/>
    <id>http://yoursite.com/2020/10/29/butterfly%E4%B8%BB%E9%A2%98/</id>
    <published>2020-10-29T08:06:54.000Z</published>
    <updated>2021-03-19T06:12:57.441Z</updated>
    
    <content type="html"><![CDATA[<p>官方网站</p><p><a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asdf</span><br></pre></td></tr></table></figure><p>$S_a$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;官方网站&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://butterfly.js.org/&quot;&gt;https://butterfly.js.org/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g</summary>
      
    
    
    
    <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/03/05/hello-world/"/>
    <id>http://yoursite.com/2020/03/05/hello-world/</id>
    <published>2020-03-05T03:15:45.000Z</published>
    <updated>2021-03-19T06:12:57.441Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>markdown syntax</title>
    <link href="http://yoursite.com/2020/03/03/markdown-syntax/"/>
    <id>http://yoursite.com/2020/03/03/markdown-syntax/</id>
    <published>2020-03-03T12:17:35.000Z</published>
    <updated>2021-03-19T06:12:57.441Z</updated>
    
    <content type="html"><![CDATA[<p>$A$</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a1 = n1.split(<span class="string">&#x27;&#x27;</span>).reverse();</span><br><span class="line">  <span class="keyword">const</span> a2 = n2.split(<span class="string">&#x27;&#x27;</span>).reverse();</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">Math</span>.max(a1.length, a2.length); i &lt; l; i++) &#123;</span><br><span class="line">    result[i] = (result[i] || <span class="number">0</span>) + <span class="built_in">parseInt</span>(a1[i] || <span class="number">0</span>) + <span class="built_in">parseInt</span>(a2[i] || <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (result[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      result[i] -= <span class="number">10</span>;</span><br><span class="line">      result[i + <span class="number">1</span>] = (result[i + <span class="number">1</span>] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><strong>加粗</strong><br><em>倾斜</em><br><strong><em>加粗倾斜</em></strong><br><del>加删除线</del></p><blockquote><p>引用的内容（可以嵌套）</p></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><p><img src="http://file.koolearn.com/20161207/14810957953513.png" alt="图片 alt" title="网上随便找的"></p><p><a href="超链接地址" title="超链接title">超链接名</a></p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第二行分割表头和内容</span><br><span class="line">-有一个就行</span><br><span class="line">文字默认居左</span><br><span class="line">--两边加:表示文字居中</span><br><span class="line">--右边加:表示文字居右</span><br><span class="line">原生的语法两边都要用|包起来，此处原作者省略。</span><br></pre></td></tr></table></figure><p>单行代码:代码之间分别用一个反引号包起来<br><code>代码内容</code></p><p>代码块:代码之间分别用三个反引号包起来，且两边的反引号独占一行</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始 </span><br><span class="line">op&#x3D;&gt;operation: My Operation </span><br><span class="line">cond&#x3D;&gt;condition: Yes or No? </span><br><span class="line">e&#x3D;&gt;end: 结束 </span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond </span><br><span class="line">cond(yes)-&gt;e </span><br><span class="line">cond(no)-&gt;op </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;$A$&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;sp</summary>
      
    
    
    
    <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
