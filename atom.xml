<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yqzzxlj</title>
  
  <subtitle>hello world</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2021-02-26T11:41:21.888Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yqzzxlj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>C++知识点复习整理</title>
    <link href="http://yoursite.com/2021/02/26/C++/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/"/>
    <id>http://yoursite.com/2021/02/26/C++/C++%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%8D%E4%B9%A0%E6%95%B4%E7%90%86/</id>
    <published>2021-02-26T06:29:12.000Z</published>
    <updated>2021-02-26T11:41:21.888Z</updated>
    
    <content type="html"><![CDATA[<p>参考之前的笔记以及该<a href="https://leetcode-cn.com/leetbook/read/cpp-interview-highlights">leetbook</a>整理。</p><h2 id="一、编译内存相关"><a href="#一、编译内存相关" class="headerlink" title="一、编译内存相关"></a>一、编译内存相关</h2><h3 id="1-C-程序编译过程"><a href="#1-C-程序编译过程" class="headerlink" title="1. C++程序编译过程"></a>1. C++程序编译过程</h3><p>四个过程：预处理、编译、汇编、链接</p><ol><li>预处理：处理以#开头的指令（#define展开， #include递归包含， #if等条件编译指令，过滤注释，添加行号、文件标识名，#pragma保留）</li><li>编译：生成汇编代码（词法分析、语法分析、语义分析、源代码优化、代码生成、目标代码优化）</li><li>汇编：生成机器指令</li><li>链接：把每个模块的源代码独立编译，然后组装起来。（把一些指令对其他符号地址的引用加以修正，包括地址和空间分配、符号决议、和重定位等步骤）。每个目标文件除了拥有自己的数据和二进制代码以外，还提供了3个符号表。未解决符号表、导出符号表、地址重定向表。extern、static、普通变量和函数。<ul><li>静态链接：编译时期完成，将代码从静态链接库copy到最终的程序中。在程序执行时，这些代码会被装入该进程的虚拟地址空间中。</li><li>动态链接：对库函数的链接推迟到运行期。代码被放入动态链接库中，链接程序只是在最终的程序中记录了共享对象的名字等信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进程的地址空间中。</li><li>优缺点：静态链接浪费空间，更新困难，执行时运行速度快。动态链接节省内存，更新方便，但每次执行都需要链接，会有性能损失。</li></ul></li></ol><h3 id="2-C-内存管理"><a href="#2-C-内存管理" class="headerlink" title="2. C++ 内存管理"></a>2. C++ 内存管理</h3><p>c++内存分区：栈、堆、静态存储区、常量存储区和代码区</p><ul><li>栈：存放局部变量、函数参数、返回地址等。由编译器自动分配和释放</li><li>堆：动态申请的内存空间。malloc和free控制内存的分配和释放。如果程序执行结束还没有释放，则操作系统自动回收。</li><li>静态存储区：存放全局变量和静态变量。程序运行结束操作系统自动释放</li><li>常量存储区：存放常量，不允许修改，程序运行结束自动释放</li><li>代码区：存放代码，不允许修改，程序运行结束自动释放</li></ul><p>static const 常量应该存在常量区或代码区，编译器会在编译期间进行值替换，所以不能对其进行取地址操作。</p><h3 id="3-堆和栈的区别"><a href="#3-堆和栈的区别" class="headerlink" title="3. 堆和栈的区别"></a>3. 堆和栈的区别</h3><p>申请方式（效率）、内存连续性、存放内容、访问效率</p><ol><li>申请方式：栈是系统自动分配，剩余空间大于申请空间即申请成功，否则申请失败栈溢出，申请效率高。堆是人为申请，堆分配时沿空闲内存地址链表寻找第一个大于申请空间的节点分配给程序。再将其从链表中删除，之后将剩余空闲节点链接到连表上，申请效率低。</li><li>内存连续：栈在内存中是一段连续的地址空间（向低地址扩展），最大容量由系统设置好；堆在内存中的空间不连续（向高地址扩展）。受限于计算机系统中有效的虚拟内存，比较大。</li><li>存放内容：栈存放的是局部变量、函数参数、返回地址等。堆人为控制。</li><li>访问效率：访问堆的一个具体单元需要两次访问内存，一次取得指针，二次取得内容。栈只需要一次。此外，堆的内容被操作系统交换到外存的概率较大。</li></ol><h3 id="4-变量的区别"><a href="#4-变量的区别" class="headerlink" title="4. 变量的区别"></a>4. 变量的区别</h3><p>全局变量、局部变量、静态全局变量、静态局部变量的区别</p><p>C++变量根据定义的位置的不同，具有不同的作用域：全局作用域、局部作用域、语句作用域、类作用域、命名空间作用域和文件作用域。</p><p>从作用域看：</p><ul><li>全局变量：具有全局作用域。全局变量只需要在一个源文件中定义，就可以作用于所有的源文件。其他不包含全局变量定义的源文件需要用extern关键字再次声明该全局变量</li><li>静态全局变量：具有文件作用域。它与全局变量的区别在于如果程序包含多个源文件的话，它作用于定义它的源文件中，不能作用到其他源文件中。即使两个不同的源文件都定义了相同名字的静态全局变量，也是不同变量。</li><li>局部变量：具有局部作用域。在程序运行期间不是一直存在，只有在函数执行期间存在，执行完被销毁。</li><li>静态局部变量：具有局部作用域。只被初始化一次，之后一直存在到程序运行结束。</li></ul><p>从内存空间看：</p><ul><li>静态存储区：全局变量、静态全局变量、静态局部变量</li><li>栈：局部变量。</li></ul><p>附：</p><ul><li>静态变量和全局变量的区别：静态变量用static告知编译器，自己仅在变量的作用范围内可见。</li><li>静态变量和栈变量、堆变量的区别：静态变量存储在静态存储区，下次调用时仍是原来的值，而栈变量和堆变量不能保证。</li></ul><h3 id="5-对象创建限制在堆或栈"><a href="#5-对象创建限制在堆或栈" class="headerlink" title="5. 对象创建限制在堆或栈"></a>5. 对象创建限制在堆或栈</h3><p>C++类的对象的建立分为两种：静态建立和动态建立。</p><ul><li>静态建立：由编译器为对象在栈空间上分配空间，直接调用类的构造函数创造对象。</li><li>动态建立：使用new关键字在堆空间上创建对象。底层首先调用operator new()函数，在堆空间上寻找合适的内存并分配；然后调用类的构造函数创建对象。</li></ul><h4 id="5-1-限制对象只能创建在堆上"><a href="#5-1-限制对象只能创建在堆上" class="headerlink" title="5.1 限制对象只能创建在堆上"></a>5.1 限制对象只能创建在堆上</h4><p>构造函数设为protected，并提供一个public的静态函数来完成构造。</p><h4 id="5-2-限制对象只能创建在栈上"><a href="#5-2-限制对象只能创建在栈上" class="headerlink" title="5.2 限制对象只能创建在栈上"></a>5.2 限制对象只能创建在栈上</h4><p>将operator new()函数设置为私有。</p><h3 id="6-内存对齐"><a href="#6-内存对齐" class="headerlink" title="6. 内存对齐"></a>6. 内存对齐</h3><p>什么是内存对齐？对齐的原则？原因？优点？</p><h4 id="6-1-什么是内存对齐"><a href="#6-1-什么是内存对齐" class="headerlink" title="6.1 什么是内存对齐"></a>6.1 什么是内存对齐</h4><p>编译器将程序中的每个数据单元安排在字的整数倍的地址指向的内存空间之中。</p><h4 id="6-2-内存对齐的原则"><a href="#6-2-内存对齐的原则" class="headerlink" title="6.2 内存对齐的原则"></a>6.2 内存对齐的原则</h4><blockquote><ol><li>结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；</li><li>结构体每个成员相对于结构体首地址的偏移量 （offset） 都是该成员大小与对齐基数中的较小者的整数倍，如有需要 编译器会在成员之间加上填充字节 （internal padding）；</li><li>结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。</li></ol></blockquote><h4 id="6-3-内存对齐的原因"><a href="#6-3-内存对齐的原因" class="headerlink" title="6.3 内存对齐的原因"></a>6.3 内存对齐的原因</h4><ol><li>会对CPU的存取效率产生影响：比如有些平台CPU从内存中偶数地址开始读取地址，如果数据其实位置正好为偶数，则1个读取周期就可以读出一个int类型的值，而如果数据地址为奇数，那我们就需要两个读取周期独处数据，并对高地址和低地址进行拼凑，这在读取效率上显然已经落后很多了。</li><li>还有其他硬件设备的原因。</li></ol><h3 id="7-类的大小"><a href="#7-类的大小" class="headerlink" title="7. 类的大小"></a>7. 类的大小</h3><p>类的大小指类的实例化对象的大小。用sizeof对类型名操作时，结果是该类型的对象的大小。</p><p>计算原则：</p><ul><li>结构体的内存对齐原则</li><li>与普通成员变量有关，与成员函数和静态成员变量无关，因为它们被类的对象共享，不属于那个具体的对象。</li><li>虚函数对类的大小有影响，因为虚函数表指针。</li><li>虚继承对类的大小有影响，因为虚基表指针。</li><li>空类的大小为1，保证不同对象具有不同地址。</li></ul><h3 id="8-内存泄漏"><a href="#8-内存泄漏" class="headerlink" title="8. 内存泄漏"></a>8. 内存泄漏</h3><p>由于疏忽或错误导致程序未能释放已不再使用的内存。包括堆内存泄漏和系统资源泄露（scoket，bitmap…)</p><p>指针重新复制，类定义不规范。（释放对象数组、基类的析构函数应为虚函数。。。）</p><h3 id="9-防止内存泄露的方法"><a href="#9-防止内存泄露的方法" class="headerlink" title="9. 防止内存泄露的方法"></a>9. 防止内存泄露的方法</h3><p>内部封装+智能指针</p><p>内存检测工具：建立两个全局表，valid-value和valid-address，检测每个字节对应的值或地址是有有效。</p><h3 id="10-智能指针"><a href="#10-智能指针" class="headerlink" title="10 智能指针"></a>10 智能指针</h3><p>解决动态内存分配时带来的内存泄露以及多次释放同一内存空间提出来的。<memory></p><ul><li>shared_ptr:多个指针可以指向同一个对象，当最后一个指针对象离开作用域时，内存自动释放。use_count()查看引用个数，release()释放所有权。</li><li>unique_ptr:资源只能被一个指针占有，该指针不能拷贝构造和赋值，但可以进行移动构造和移动赋值构造。move()</li><li>weak_ptr:指shared_ptr指向的对象，解决循环引用问题。</li></ul><h4 id="10-1-智能指针的实现"><a href="#10-1-智能指针的实现" class="headerlink" title="10.1 智能指针的实现"></a>10.1 智能指针的实现</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmartPtr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span> : </span><br><span class="line">T *_ptr;</span><br><span class="line"><span class="keyword">size_t</span> *_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">SmartPtr(T *ptr = <span class="literal">nullptr</span>) : _ptr(ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (_ptr)</span><br><span class="line">&#123;</span><br><span class="line">_count = <span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">_count = <span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~SmartPtr()</span><br><span class="line">&#123;</span><br><span class="line">(*<span class="keyword">this</span>-&gt;_count)--;</span><br><span class="line"><span class="keyword">if</span> (*<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SmartPtr(<span class="keyword">const</span> SmartPtr &amp;ptr) <span class="comment">// 拷贝构造：计数 +1</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span> != &amp;ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line"><span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">(*<span class="keyword">this</span>-&gt;_count)++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SmartPtr &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> SmartPtr &amp;ptr) <span class="comment">// 赋值运算符重载 </span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr == ptr._ptr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_ptr) <span class="comment">// 将当前的 ptr 指向的原来的空间的计数 -1</span></span><br><span class="line">&#123;</span><br><span class="line">(*<span class="keyword">this</span>-&gt;_count)--;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;_count == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;_count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;_ptr = ptr._ptr;</span><br><span class="line"><span class="keyword">this</span>-&gt;_count = ptr._count;</span><br><span class="line">(*<span class="keyword">this</span>-&gt;_count)++; <span class="comment">// 此时 ptr 指向了新赋值的空间，该空间的计数 +1</span></span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T &amp;<span class="keyword">operator</span>*()</span><br><span class="line">&#123;</span><br><span class="line">assert(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">return</span> *(<span class="keyword">this</span>-&gt;_ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">T *<span class="keyword">operator</span>-&gt;()</span><br><span class="line">&#123;</span><br><span class="line">assert(<span class="keyword">this</span>-&gt;_ptr == <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;_ptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">use_count</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>-&gt;count;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="11-循环引用"><a href="#11-循环引用" class="headerlink" title="11. 循环引用"></a>11. 循环引用</h3><p>两个类中分别定义另一个类的共享指针，两个指针会互相指向对方的内存空间，导致内存无法释放。</p><p>使用weak_ptr解决问题。weak_ptr具有非拥有性，使用前先转化为shared_ptr.(项目1中httpdata与timernode)</p><h2 id="二、语言对比"><a href="#二、语言对比" class="headerlink" title="二、语言对比"></a>二、语言对比</h2><h3 id="1-c-11新特性"><a href="#1-c-11新特性" class="headerlink" title="1. c++11新特性"></a>1. c++11新特性</h3><h4 id="1-1-auto类型推导"><a href="#1-1-auto类型推导" class="headerlink" title="1.1 auto类型推导"></a>1.1 auto类型推导</h4><p>自动类型推导，编译器在<strong>编译期间</strong>通过<strong>初始值</strong>推导出变量的类型，通过auto定义的变量必须有初始值。</p><h4 id="1-2-decltype类型推导"><a href="#1-2-decltype类型推导" class="headerlink" title="1.2 decltype类型推导"></a>1.2 decltype类型推导</h4><p>declare type的缩写，和auto一样，在编译期间进行类型推导。从表达式中推断出要定义的变量的类型。</p><p>区别：</p><ol><li>auto根据=右边的初始值推断出变量的类型，decltype根据表达式推断变量的类型，变量的初始值与表达式的值无关</li><li>auto要求变量必须初始化</li></ol><h4 id="1-3-lambda表达式（匿名函数）"><a href="#1-3-lambda表达式（匿名函数）" class="headerlink" title="1.3 lambda表达式（匿名函数）"></a>1.3 lambda表达式（匿名函数）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>](parameter <span class="built_in">list</span>) -&gt; <span class="keyword">return</span> type &#123;</span><br><span class="line">function body;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-4-范围for语句"><a href="#1-4-范围for语句" class="headerlink" title="1.4 范围for语句"></a>1.4 范围for语句</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (delaration : expression) &#123;</span><br><span class="line">statement;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>expression 必须是一个序列。拥有能返回迭代器的begin，end成员</li><li>delaration 定义一个变量，序列中每一个元素都能转化成该变量的类型。常用auto</li></ul><h4 id="1-5-右值引用"><a href="#1-5-右值引用" class="headerlink" title="1.5 右值引用"></a>1.5 右值引用</h4><p>右值引用：绑定到右值的引用，用&amp;&amp;来获得右值引用，右值引用智能绑定到要销毁的对象。</p><h4 id="1-6-标准库move函数"><a href="#1-6-标准库move函数" class="headerlink" title="1.6 标准库move函数"></a>1.6 标准库move函数</h4><p>通过该函数获得绑定到左值上的右值引用。</p><h4 id="1-7-智能指针"><a href="#1-7-智能指针" class="headerlink" title="1.7 智能指针"></a>1.7 智能指针</h4><h4 id="1-8-delete函数和default函数"><a href="#1-8-delete函数和default函数" class="headerlink" title="1.8 delete函数和default函数"></a>1.8 delete函数和default函数</h4><ul><li>=delete表示该函数不能被调用</li><li>=default表示编译器默认生成的函数</li></ul><h3 id="2-C和C-的区别"><a href="#2-C和C-的区别" class="headerlink" title="2. C和C++的区别"></a>2. C和C++的区别</h3><ul><li>面向过程：分析解决分析需要的步骤，并用函数将这些步骤实现。</li><li>面向对象：把构成问题的事物分解成各个对象，建立对象的目的不是完成一个步骤，而是描述某个事物在解决问题时的行为。</li></ul><p>区别和联系</p><ol><li>c语言是面向过程的编程。通过main函数来调用各个子函数，程序的执行顺序都是实现决定好的。C++面向对象编程，类是它的主要特点，过程的概念被淡化。以类驱动程序运行，将数据及操作封装在类中，以事件或消息来驱动对象执行处理。</li><li>应用领域：c语言主要应用于嵌入式领域、驱动开发等与硬件直接打交道的领域。C++可以用于应用层开发，用户界面开发等与操作系统打交道的领域。</li><li>C++既继承了c强大的底层操作特性，又被赋予了面向对象机制。特性繁多，多继承，值传递和引用传递的区分以及const关键字等等</li><li>C++对c语言的增强表现在：类型检查更为严格，增加了面向对象的机制、泛性编程的机制。异常处理、运算符重载，STL、命名空间等。</li></ol><h3 id="3-JAVA和C-的区别"><a href="#3-JAVA和C-的区别" class="headerlink" title="3. JAVA和C++的区别"></a>3. JAVA和C++的区别</h3><ul><li>语言特性<ul><li>指针。c++可以直接操作指针。</li><li>多重继承。C++支持多重继承。</li><li>数据类型和类。java完全面向对象，所有变量和函数必须是类的一部分。而C++允许将函数和变量定义成全局的。</li></ul></li><li>垃圾回收<ul><li>java具备垃圾回收机制，有效防止内存泄露</li></ul></li><li>应用场景<ul><li>java运行在虚拟机上，和开发平台无关。C++直接编译成可执行文件，是否跨平台在于用到的编译器是否有多平台的支持。</li><li>C++直接编译成可执行文件，运行效率比java高</li><li>java主要用来开发web应用，c++用在网络、并发编程等方面</li></ul></li></ul><h3 id="4-python和C-的区别"><a href="#4-python和C-的区别" class="headerlink" title="4. python和C++的区别"></a>4. python和C++的区别</h3><ul><li>语言<ul><li>python为脚本语言，解释执行，不需要经过编译。</li><li>C++是一种编译型语言，在特定的机器上编译后执行。</li></ul></li><li>运行效率<ul><li>c++运行效率高，安全稳定。直接编译成机器指令，其中还有优化。</li><li>python解释执行，和cpu之间多了解释器，</li></ul></li><li>开发效率<ul><li>python开发效率高，语法格式灵活。</li></ul></li></ul><h2 id="三、面向对象"><a href="#三、面向对象" class="headerlink" title="三、面向对象"></a>三、面向对象</h2><h3 id="1-什么是面向对象，面向对象的特性"><a href="#1-什么是面向对象，面向对象的特性" class="headerlink" title="1. 什么是面向对象，面向对象的特性"></a>1. 什么是面向对象，面向对象的特性</h3><p>面向对象：对象指的是某一事物，这些事物的抽象就是类，类中包含成员数据和成员方法。</p><p>面向对象的特性：</p><ul><li>封装：将具体的实现过程和数据封装成类，只能通过接口访问，降低耦合性。</li><li>继承：子类继承父类的特征和行为。子类有父类的非private方法或成员变量，子类可以对父类的方法进行重写，增加耦合性。被关键字final修饰的类不能被继承，成员不能被重写或修改</li><li>多态：不同继承类的对象，对同一消息能够做出不同反应。</li></ul><h3 id="2-重载、重写和隐藏的区别"><a href="#2-重载、重写和隐藏的区别" class="headerlink" title="2. 重载、重写和隐藏的区别"></a>2. 重载、重写和隐藏的区别</h3><ul><li>重载：同一可访问区内被声明几个具有不同参数列表（类型，数量，顺序）的同名函数，根据参数列表确定调用哪个函数，重载函数不关心返回类型</li><li>隐藏：指派生类的函数屏蔽了与其同名的基类函数。只要是同名函数，不管参数列表是否相同，基类函数都会被隐藏</li><li>重写：指派生类存在重新定义的函数。函数名、参数列表、返回类型都必须与基类函数相同，只有函数体不同，且基类函数有virtual关键字修饰</li></ul><h3 id="3-多态极其实现"><a href="#3-多态极其实现" class="headerlink" title="3. 多态极其实现"></a>3. 多态极其实现</h3><p>多态就是不同继承类的对象，对同一消息作出不同反应。</p><p>基类的指针指向派生类的对象，使得基类指针呈现不同的表现方式。</p><p>在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时会根据对象的实际类型来调用相应的函数。</p><h4 id="3-1-实现方法"><a href="#3-1-实现方法" class="headerlink" title="3.1 实现方法"></a>3.1 实现方法</h4><p>通过虚函数实现，虚函数的地址保存在虚函数表中，虚函数表的地址保存在虚函数的类的实例对象的内存空间中。</p><h4 id="3-2-实现过程"><a href="#3-2-实现过程" class="headerlink" title="3.2 实现过程"></a>3.2 实现过程</h4><ol><li>在类中用virtual关键字声明虚函数</li><li>存在虚函数的类都存在一个虚函数表，当创建一个类的对象时，该对象有一个指向该虚函数表的虚表指针。</li><li>当基类指针指向派生类对象，调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的函数。</li></ol><h2 id="四、关键字和库函数"><a href="#四、关键字和库函数" class="headerlink" title="四、关键字和库函数"></a>四、关键字和库函数</h2><h3 id="1-strlen-和sizeof的区别"><a href="#1-strlen-和sizeof的区别" class="headerlink" title="1. strlen 和sizeof的区别"></a>1. strlen 和sizeof的区别</h3><ol><li><p>strlen是头文件<cstring>中的库函数，sizeof是c++的运算符。</p></li><li><p>strlen测量的是字符串的实际长度，以’\0’结束，sizeof测量的是字符数组的分配大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> arr[<span class="number">10</span>] = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">strlen</span>(arr) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(arr) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 10</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>若字符数组作为函数的形参，sizeof(arr)被当作字符指针来处理，strlen(arr)中arr依然是字符数组。</p></li><li><p>strlen是库函数，在运行时确定长度。sizeof是运算符，在编译时计算长度。</p></li><li><p>sizeof的参数可以是类型，也可以是变量。strlen的参数必须是char*类型的变量。</p></li></ol><h3 id="2-explict的作用"><a href="#2-explict的作用" class="headerlink" title="2. explict的作用"></a>2. explict的作用</h3><p>用来声明类的构造函数是显式调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可以用来修饰<strong>单参构造函数</strong>。</p><h3 id="3-static的作用"><a href="#3-static的作用" class="headerlink" title="3. static的作用"></a>3. static的作用</h3><p>static用来修饰静态变量和静态函数</p><ul><li>保持变量内容持久：static修饰局部变量时，改变了其声明周期，使得该变量存在于定义后知道程序结束运行的时间内。</li><li>隐藏：static修饰全局变量和函数时，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用。</li><li>static作用于类的成员变量和成员函数时，使得类变量或者类成员函数和类有关。不用定义类的对象就可以通过类访问这些静态成员。注意类的静态成员函数中只能访问静态成员变量和静态成员函数，不能将类的静态成员函数定义为虚函数。继承时父类子类的static变量是同一个。</li></ul><h3 id="4-static在类中的使用"><a href="#4-static在类中的使用" class="headerlink" title="4. static在类中的使用"></a>4. static在类中的使用</h3><ul><li>static静态成员变量<ol><li>静态成员变量是在类内进行声明，类外进行定义和初始化。在类外定义和初始化时不能出现static、private等关键字</li><li>静态成员变量被类的所有对象共享，<strong>包括派生类的对象</strong></li><li>静态成员变量可以作为成员函数的参数。</li><li>静态成员变量的类型可以是所属类的类型。普通的只能是指针或引用。</li></ol></li><li>static静态成员函数<ol><li>静态成员函数不能调用非静态成员变量或非静态成员函数，因为静态成员函数没有this指针。静态成员函数作为类作用域的全局函数</li><li>静态成员函数不能声明为虚函数virtual，const函数和volatile函数</li></ol></li></ul><h3 id="5-const作用及用法"><a href="#5-const作用及用法" class="headerlink" title="5. const作用及用法"></a>5. const作用及用法</h3><ul><li>作用<ol><li>const修饰成员变量，定义成const常量，相较于宏常量，可进行类型检查、节省内存空间、提高效率。</li><li>const修饰函数参数，使得传递过来的函数参数的值不能被改变。</li><li>const修饰成员函数，使得成员函数不能修改任何类型的成员变量，<strong>mutable修饰的成员变量除外</strong>，也不能调用非const成员函数。</li></ol></li><li>用法<ol><li>const成员变量<ol><li>const成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。</li><li>const成员变量只在某个对象的生命周期内是是常量，对于整个类而言是可变的，所以不能在类声明中初始化const成员变量</li></ol></li><li>const成员函数<ol><li>不能修改成员变量的值，除非有mutable修饰，只能访问成员变量。</li><li>不能调用非const成员函数</li></ol></li></ol></li></ul><h3 id="6-define和const的区别"><a href="#6-define和const的区别" class="headerlink" title="6. define和const的区别"></a>6. define和const的区别</h3><ul><li>编译阶段：define是在预处理阶段进程替换，const是在编译阶段确定其值。</li><li>安全性：define定义的宏常量没有数据类型，只是进行简单的替换，不会进行安全检查。const是有类型的，类型检查能避免一些简单的错误。</li><li>内存占用：define定义的宏常量在程序中使用多少次就会发生多少次替换，内存中就会有多少次备份，占用代码段的空间；const定义的常量存储在静态存储区，运行过程中只有一份</li><li>调试：define定义的宏常量不能调试，因为在预处理阶段就已经替换了，const定义的常量可以进行调试。</li></ul><h3 id="7-define和typedef的区别"><a href="#7-define和typedef的区别" class="headerlink" title="7. define和typedef的区别"></a>7. define和typedef的区别</h3><ul><li><p>原理：#define作为预处理指令，在预处理阶段进行替换，不做正确性检查，只有在编译被展开的源程序时才会发现可能的错误并报错。typedef是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型起别名，但不能在一个函数定义里面使用typedef。</p></li><li><p>功能：typedef用来定义类型的别名，方便使用。#define不仅可以为类型取别名，还可以定义常量、变量、编译开关等</p></li><li><p>指针操作：在处理指针是完全不一样</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INTPTR1 int *</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> * INTPTR2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    INTPTR1 p1, p2; <span class="comment">// p1: int *; p2: int</span></span><br><span class="line">    INTPTR2 p3, p4; <span class="comment">// p3: int *; p4: int *</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">const</span> INTPTR1 p5 = &amp;var; <span class="comment">// 相当于 const int * p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。</span></span><br><span class="line">    <span class="keyword">const</span> INTPTR2 p6 = &amp;var; <span class="comment">// 相当于 int * const p6; 指针常量，不可使 p6 再指向其他内容。</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="8-inline作用及使用方法"><a href="#8-inline作用及使用方法" class="headerlink" title="8. inline作用及使用方法"></a>8. inline作用及使用方法</h3><ul><li>作用：inline是一个关键字，用来定义内联函数。内联函数能够像普通函数一样被调用，但是并不通过函数调用机制，而是直接在调用点展开，这样可以减少由函数调用带来的开销，从而提高程序的运行效率。</li><li>使用方法：<ol><li>类内定义成员函数默认是内联函数</li><li>类外定义成员函数，若想定义为内联函数，需用关键字声明</li></ol></li></ul><h3 id="9-define和inline的区别"><a href="#9-define和inline的区别" class="headerlink" title="9. define和inline的区别"></a>9. define和inline的区别</h3><ul><li>编译阶段： define是在预处理阶段展开，inline是在编译时展开。</li><li>安全性：宏只是简单的文本替换，不会对参数的类型、语句等能否进行正常编译进行检查。而内联函数是真正的函数，会进行检查。</li><li>内联函数式真正的函数，避免了函数参数的压栈操作，减少调用的开销。宏定义编写较为复杂，常需要括号来避免歧义</li></ul><h3 id="10-new、delete和malloc、free的区别"><a href="#10-new、delete和malloc、free的区别" class="headerlink" title="10. new、delete和malloc、free的区别"></a>10. new、delete和malloc、free的区别</h3><p>new和delete搭配使用，malloc和free搭配使用</p><ul><li>malloc、free式库函数，new和delete是关键字</li><li>申请空间大小：new申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算。malloc在申请空间时，需要确定所申请空间的大小。</li><li>返回类型：new申请空间时，返回的类型是对象的指针类型，无需强制类型转换，类型安全；malloc返回void*类型，需要进行强制类型转换。</li><li>错误类型：new申请失败时，会抛出bad_alloc异常，malloc返回空指针。</li><li>自定义类型：new先调用operator new() 函数申请空间，然后调用构造函数初始化，最后返回自定义类型的指针。delete先调用析构函数，在调用operator delete() 释放空间。malloc、free无法进行自定义类型的构造和析构。</li><li>new从自由存储区上为对象动态分配内存，malloc函数从堆上动态分配内存。</li></ul><blockquote><p>附：指针的作用，指示指向对象的地址和长度，类型代表长度，值代表地址。不能对void*进行解引用操作。</p><p>如果函数的参数可以是任意类型的指针，可以将其声明为void*。</p><p>void类型指针可以指向任意类型的数据，即可以用任意数据类型的指针对void指针赋值。</p></blockquote><h3 id="11-struct和union的区别"><a href="#11-struct和union的区别" class="headerlink" title="11. struct和union的区别"></a>11. struct和union的区别</h3><p>struct是结构体，union是联合体</p><p>区别：</p><ol><li>struct和union都是由若干个数据类型不同的成员组成的。使用时联合体只有一个有效的成员，而结构体所有成员有效。</li><li>对联合体的成员赋值，会覆盖其他成员的值。结构体成员互不影响</li><li>联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小。结构体的大小遵循内存对齐原则</li></ol><h3 id="12-class和struct的异同"><a href="#12-class和struct的异同" class="headerlink" title="12. class和struct的异同"></a>12. class和struct的异同</h3><ul><li>class和struct都可以定义数据类型，支持继承操作</li><li>struct中默认访问级别是public，继承级别也是public。class的都是private</li><li>class可以用于定义模板参数，struct不能</li></ul><h3 id="13-volatile"><a href="#13-volatile" class="headerlink" title="13. volatile"></a>13. volatile</h3><p>对象的值可能在程序的控制或检测之外被改动时，应定义为volatile。告知编译器不对其优化。</p><p>每次都去内存中读取，而不用上次的寄存器的内容。</p><h2 id="五、类相关"><a href="#五、类相关" class="headerlink" title="五、类相关"></a>五、类相关</h2><h3 id="1-什么是虚函数？什么是纯虚函数？"><a href="#1-什么是虚函数？什么是纯虚函数？" class="headerlink" title="1. 什么是虚函数？什么是纯虚函数？"></a>1. 什么是虚函数？什么是纯虚函数？</h3><ul><li>虚函数：用virtual关键字修饰的成员函数</li><li>纯虚函数：纯虚函数在类中声明时加上=0；含有纯虚函数的类叫做抽象类，类中只有接口，没有实现；派生类如果没有完全实现基类中的纯虚函数依然是抽象类。</li><li>抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；可以声明抽象类指针、引用；</li></ul><h3 id="2-虚函数的实现机制"><a href="#2-虚函数的实现机制" class="headerlink" title="2. 虚函数的实现机制"></a>2. 虚函数的实现机制</h3><p>虚函数通过虚函数表实现。虚函数的地址保存在虚函数表中，类的对象中有虚表指针。通过虚表指针可找到虚函数表，进而遍历找到要调用的函数。</p><p>在编译阶段建立虚函数表，虚表指针放在对象的内存空间中最前面的位置，以保证正确取到虚函数的偏移量。</p><h3 id="3-多继承下的虚函数表"><a href="#3-多继承下的虚函数表" class="headerlink" title="3. 多继承下的虚函数表"></a>3. 多继承下的虚函数表</h3><ol><li>在多继承下，有多少个虚函数的基类就有多少个虚表指针</li><li>当子类有多出来的虚函数时，添加在第一个虚表中，父类指针不能调用。</li><li>当有多个虚函数表时，虚函数表的结果是0代表没有下一个虚函数表。其他位置看实现方式。</li></ol><h3 id="4-构造函数、析构函数是否需要定义成虚函数？"><a href="#4-构造函数、析构函数是否需要定义成虚函数？" class="headerlink" title="4. 构造函数、析构函数是否需要定义成虚函数？"></a>4. 构造函数、析构函数是否需要定义成虚函数？</h3><ul><li>构造函数不定义为虚函数<ul><li>存储空间：对象还没构造，找不到虚表指针。</li><li>类型：创建对象时需要明确类型。</li></ul></li><li>析构函数一般定义为虚函数：防止内存泄漏，当基类的指针或引用指向派生类的对象时，如果未定义成虚函数，会调用基类的析构函数，派生类中特有的成员变量就不会被释放。</li></ul><h3 id="5-多重继承容易出现的问题及解决方法"><a href="#5-多重继承容易出现的问题及解决方法" class="headerlink" title="5. 多重继承容易出现的问题及解决方法"></a>5. 多重继承容易出现的问题及解决方法</h3><p>命名冲突和数据冗余</p><p>命名冲突可以使用B::a，这样指出变量归属的方式来解决</p><p>数据冗余使用虚继承解决。</p><h4 id="虚继承"><a href="#虚继承" class="headerlink" title="虚继承"></a>虚继承</h4><p><a href="https://blog.csdn.net/longlovefilm/article/details/80558879">https://blog.csdn.net/longlovefilm/article/details/80558879</a></p><p><a href="https://blog.csdn.net/chengonghao/article/details/51701290">https://blog.csdn.net/chengonghao/article/details/51701290</a></p><p>在继承方式前面加上virtual关键字。使派生类中不会保留同一基类的多份拷贝。</p><h4 id="虚继承的实现机制"><a href="#虚继承的实现机制" class="headerlink" title="虚继承的实现机制"></a>虚继承的实现机制</h4><p>虚基类表：记录虚基类与本类的偏移量。通过偏移量找到虚基类成员。这样避免多份拷贝（不同类的偏移量不同）</p><p>虚基类指针：在对象中，指向虚基类表</p><p>多重继承时，会继承多个虚基类指针。</p><h3 id="6-空类占多少字节？编译器会自动给空类生成哪些函数？"><a href="#6-空类占多少字节？编译器会自动给空类生成哪些函数？" class="headerlink" title="6. 空类占多少字节？编译器会自动给空类生成哪些函数？"></a>6. 空类占多少字节？编译器会自动给空类生成哪些函数？</h3><p>空类声明时编译器不会生成任何成员函数。只会生成一个字节的占位符。</p><p>空类定义是编译器会自动生成6个成员函数。缺省的构造函数、拷贝构造函数、析构运算函数、复制运算符和两个取地址运算符。</p><h3 id="7-拷贝构造函数必须为引用？"><a href="#7-拷贝构造函数必须为引用？" class="headerlink" title="7. 拷贝构造函数必须为引用？"></a>7. 拷贝构造函数必须为引用？</h3><p>避免无限制的递归，最终导致栈溢出。</p><h3 id="8-C-类对象的初始化顺序"><a href="#8-C-类对象的初始化顺序" class="headerlink" title="8. C++类对象的初始化顺序"></a>8. C++类对象的初始化顺序</h3><ul><li>构造函数调用顺序：<ol><li>按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数</li><li>按照派生类中成员变量的声明顺序，依次调用派生类中成员变量所属类的构造函数</li><li>执行派生类自身的构造函数</li></ol></li><li>类对象的初始化顺序：基类构造函数-&gt;派生类成员变量的构造函数-&gt;自身的构造函数</li><li>注意：<ul><li>基类构造函数的调用顺序与派生类的派生列表中的顺序有关。</li><li>成员变量的初始化顺序与声明顺序有关。</li><li>析构顺序与构造顺序相反。</li></ul></li></ul><h3 id="9-为什么使用成员初始化列表会快"><a href="#9-为什么使用成员初始化列表会快" class="headerlink" title="9. 为什么使用成员初始化列表会快"></a>9. 为什么使用成员初始化列表会快</h3><p>数据类型可分为内置类型和用户自定义类型（类类型），对于用户自定义类型，利用成员初始化列表效率高。</p><p>用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，因为 C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，那么在执行构造函数的函数体之前首先调用默认的构造函数为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。因此，使用列表初始化会减少调用默认的构造函数的过程，效率高。</p><h3 id="10-实例化一个对象需要哪几个阶段"><a href="#10-实例化一个对象需要哪几个阶段" class="headerlink" title="10. 实例化一个对象需要哪几个阶段"></a>10. 实例化一个对象需要哪几个阶段</h3><ol><li>分配空间：创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象，静态对象，分配在栈区域内的对象，在编译阶段进行内存分配。存储在堆空间的对象是在运行阶段进行内存分配。</li><li>初始化：初始化发生在赋值之前，赋值是在对象初始化好后，为其赋上相应的值。初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程。</li><li>赋值：对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。</li></ol><p>注意：对于拥有虚函数的类的对象，还需要给虚表指针赋值。</p><ul><li>没有继承关系的类，分配完内存后，首先给虚表指针赋值，然后在进行初始化和赋值操作。</li><li>有继承关系的类，分配完内存后，先执行基类的构造，再给虚表指针赋值，最后进行初始化和赋值操作。</li></ul><h3 id="11-友元的作用及使用场景"><a href="#11-友元的作用及使用场景" class="headerlink" title="11. 友元的作用及使用场景"></a>11. 友元的作用及使用场景</h3><p>友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享机制。通过友元，一个不同函数或另一个类的成员函数能够访问到类中的私有成员和保护成员</p><h3 id="12-静态绑定和动态绑定"><a href="#12-静态绑定和动态绑定" class="headerlink" title="12. 静态绑定和动态绑定"></a>12. 静态绑定和动态绑定</h3><ul><li><p>静态类型：变量在声明时的类型，是在编译阶段确定的。静态类型不能更改。</p></li><li><p>动态类型：目前所知对象的类型，在运行阶段确定的。动态类型可以更改。</p></li><li><p>静态绑定：程序在编译阶段确定对象的类型</p></li><li><p>动态绑定：程序在运行阶段确定对象的类型</p></li></ul><p>对于类的成员函数，只有虚函数是动态绑定，其他都是静态绑定。</p><h3 id="13-深拷贝与浅拷贝"><a href="#13-深拷贝与浅拷贝" class="headerlink" title="13. 深拷贝与浅拷贝"></a>13. 深拷贝与浅拷贝</h3><p>如果一个类拥有资源，该类的对象进行复制时，如果资源重新分配就是深拷贝，否则就是浅拷贝。</p><ul><li>深拷贝：该对象和原对象占用不同的内存空间，既拷贝存储在栈中的内容，又拷贝存储在堆中的内容。</li><li>浅拷贝：该对象和原对象占用同一块内存空间，只拷贝存储在栈中的内容</li></ul><h3 id="14-编译时多态和运行时多态"><a href="#14-编译时多态和运行时多态" class="headerlink" title="14. 编译时多态和运行时多态"></a>14. 编译时多态和运行时多态</h3><ul><li>编译时多态：在程序编译过程中出现，发生在模板和函数重载中（泛性编程）</li><li>运行时多态：在程序运行过程中出现，发生在继承体系中，指通过基类的指针访问派生类的虚函数</li></ul><h2 id="六、语言特性相关"><a href="#六、语言特性相关" class="headerlink" title="六、语言特性相关"></a>六、语言特性相关</h2><h3 id="1-左值和右值的区别？左值引用和右值引用的区别？"><a href="#1-左值和右值的区别？左值引用和右值引用的区别？" class="headerlink" title="1. 左值和右值的区别？左值引用和右值引用的区别？"></a>1. 左值和右值的区别？左值引用和右值引用的区别？</h3><ul><li><p>左值：表达式结束后依然存在的持久对象。</p></li><li><p>右值：表达式结束就不存在的临时对象。</p></li><li><p>区别：左值持久、右值短暂</p></li><li><p>左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式上但不能绑定到左值上。</p></li><li><p>右值引用必须绑定到右值上，通过&amp;&amp;获得。该对象将要销毁，可以自由的移动其资源。</p></li><li><p>使用std::move()可以将一个左值强制转化为右值。继而通过右值引用使用该值，用于移动语义。</p></li></ul><p>移动构造为浅拷贝</p><h3 id="2-什么是野指针和空悬指针？"><a href="#2-什么是野指针和空悬指针？" class="headerlink" title="2. 什么是野指针和空悬指针？"></a>2. 什么是野指针和空悬指针？</h3><p>空悬指针：指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存。这个指针就是悬空指针。</p><p>野指针：未初始化，指向不确定。</p><h3 id="3-指针和引用的区别"><a href="#3-指针和引用的区别" class="headerlink" title="3. 指针和引用的区别"></a>3. 指针和引用的区别</h3><p>可变、占用空间、为空、多级</p><ul><li>指针的指向可变，引用一旦绑定就不能再改变</li><li>指针本身在内存中占有空间，引用是变量的别名，不占空间</li><li>指针可以为空，引用必须绑定对象</li><li>指针可以多级，引用只有一级。</li></ul><h3 id="4-常量指针和指针常量的区别"><a href="#4-常量指针和指针常量的区别" class="headerlink" title="4. 常量指针和指针常量的区别"></a>4. 常量指针和指针常量的区别</h3><p>常量指针本质上是指针，只不过这个指针指向的对象是常量。const在*左侧。</p><p>指针常量本质上是常量，常量的值是指针。const在*右侧。</p><h3 id="5-函数指针和指针函数的区别"><a href="#5-函数指针和指针函数的区别" class="headerlink" title="5. 函数指针和指针函数的区别"></a>5. 函数指针和指针函数的区别</h3><p>指针函数本质是函数，返回类型是指针。</p><p>函数指针本质上是指针，指针指向函数。</p><h3 id="6-强制类型转换"><a href="#6-强制类型转换" class="headerlink" title="6. 强制类型转换"></a>6. 强制类型转换</h3><h4 id="6-1-static-cast"><a href="#6-1-static-cast" class="headerlink" title="6.1 static_cast"></a>6.1 static_cast</h4><p>用于数据的强制类型转换，将一种数据类型强制转换为另一种</p><ul><li>基本数据类型</li><li>基类和派生类的指针（上行安全，下行不安全，建议用dynamic_cast)</li><li>空指针转化成目标类型的空指针</li><li>将任意类型的表达式转换成void类型</li></ul><h4 id="6-2-const-cast"><a href="#6-2-const-cast" class="headerlink" title="6.2 const_cast"></a>6.2 const_cast</h4><p>强制去掉const属性，用于指针或引用。（适用于处理常量字符串const char*）</p><h4 id="6-3-reinterpret-cast"><a href="#6-3-reinterpret-cast" class="headerlink" title="6.3 reinterpret_cast"></a>6.3 reinterpret_cast</h4><p>处理无关类型之间的转换。指针与整数之间的转换，无关类型指针之间的转换。</p><h4 id="6-4-dynamic-cast"><a href="#6-4-dynamic-cast" class="headerlink" title="6.4 dynamic_cast"></a>6.4 dynamic_cast</h4><pre><code>1. 其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时进行类型检查。 2. 只能用于带虚函数的基类和派生类的指针或引用对象之间的转换。失败返回null。 3. 在进行上行转换时和static_cast效果一样 4. 具有类型检查的功能（typeid）。下行转换时只有指针指向的对象的类型和转化以后的对象类型相同时才会转化成功。</code></pre><h3 id="7-如何判断结构体是否相等？能否用memcmp函数判断"><a href="#7-如何判断结构体是否相等？能否用memcmp函数判断" class="headerlink" title="7. 如何判断结构体是否相等？能否用memcmp函数判断"></a>7. 如何判断结构体是否相等？能否用memcmp函数判断</h3><p>需要重载==，不能使用memcmp函数，因为当有内存对齐时，补位的字节内容是随机的，而memcmp是逐个字节进行比较的。</p><h2 id="七、STL"><a href="#七、STL" class="headerlink" title="七、STL"></a>七、STL</h2><h3 id="1-STL组件及其关系"><a href="#1-STL组件及其关系" class="headerlink" title="1. STL组件及其关系"></a>1. STL组件及其关系</h3><p>STL六大组件：空间配置器、容器、迭代器、适配器、算法、仿函数</p><ul><li>容器通过空间配置器取得数据存储空间</li><li>算法通过迭代器取得容器内容</li><li>仿函数可以协助算法完成不同的策略变化</li><li>适配器可以修饰或套接仿函数。</li></ul><h3 id="2-空间配置器简单介绍"><a href="#2-空间配置器简单介绍" class="headerlink" title="2. 空间配置器简单介绍"></a>2. 空间配置器简单介绍</h3><p>空间配置器为程序分配空间。</p><p>空间配置器分为两级，第一级配置器直接使用malloc()与free()。第二级配置器则视情况采用不同的策略；当配置空间大于128b时，采用第一级配置器。当需要分配的空间小于128b时，则采用内存池的方式。其目的是为了降低额外负担，减少内存碎片。</p><p>涉及到单例模式（一个进程只需要一个空间配置器），享元模式（小块内存统一由内存池进行管理）</p><h4 id="2-1-第一级配置器"><a href="#2-1-第一级配置器" class="headerlink" title="2.1 第一级配置器"></a>2.1 第一级配置器</h4><ul><li>直接用malloc和free申请和释放内存</li><li>使用new_handler机制处理内存不足的情况</li></ul><h4 id="2-2-第二级配置器"><a href="#2-2-第二级配置器" class="headerlink" title="2.2 第二级配置器"></a>2.2 第二级配置器</h4><p>二级空间配置器避免了太多额外的小区造成的内存碎片</p><p>allocate 和 deallocate</p><ul><li>allocate：如果用户需要的区块大于128B，则直接调用第一级空间适配器；如果用户需要的区块小于等于128b，则到自由链表中去找；如果自由链表有，则直接取走，不然需要装填自由链表（refill）</li><li>deallocate：如果区块大于128，则直接由第一级空间配置器收回。如果区块小于等于128，则由自由链表收回。</li></ul><h5 id="2-2-1-内存分配"><a href="#2-2-1-内存分配" class="headerlink" title="2.2.1 内存分配"></a>2.2.1 内存分配</h5><ol><li>free_list中有多余内存。如果申请3个字节的内存，则所需空间大小提升为8的倍数，然后去free_list中查找相应的链表，如果free_list[i]不为空，则返回第一个元素，然后把头指针往后移。</li><li>free_list中没有空余，但是内存池不为空。首先检验内存池中的大小是不是比申请的内存大，比如申请20*8的内存，如果足够，则分配相应内存，将其中一个分配给用户使用，其它的挂在相应的free_list中。如果内存池不够大，只够几个内存分配，则就分配这几个，把相应的数据返回。如果连一个都不够则执行第三种情况。</li><li>free_list中没有空余，内存池也不够。调用malloc重新分配内存。分配时会多分配一倍的内存，把相应的内存挂到free_list下，剩余的放到内存池中。</li><li>free_list中没有空余，内存池也不够。malloc也失败。调用一级空间配置器，里面会有循环处理，或抛出异常。</li></ol><h5 id="2-2-2-内存回收"><a href="#2-2-2-内存回收" class="headerlink" title="2.2.2 内存回收"></a>2.2.2 内存回收</h5><p>当用户从二级空间配置器中申请的内存被释放时，二级空间配置器将回收的内存插入到对应的free_list中</p><h5 id="2-2-3-问题"><a href="#2-2-3-问题" class="headerlink" title="2.2.3 问题"></a>2.2.3 问题</h5><ul><li>内存碎片问题：比如用户需要3字节，会分配8字节，导致内存碎片</li><li>内存回收会把不用的内存放在free_list中，导致其他进程无法使用</li></ul><h5 id="2-2-4-注意"><a href="#2-2-4-注意" class="headerlink" title="2.2.4 注意"></a>2.2.4 注意</h5><p>空间配置器中所有的函数都是静态的，为什么？？如果这些函数不是静态的，如果我们要申请空间，岂不是也要创建一个空间配置器的对象，由对象来调用里面的函数，进而申请空间，如果这样的话，那空间就跟随者空间配置器对象的生命周期，那这个岂不是很麻烦，每次都要额外创建对象。所以把所有的函数都设置为静态的，就不需要创建对象就能够调用函数申请空间，并且可以保证在程序结束的时候空间才会被回收。</p><h3 id="3-迭代器简单介绍"><a href="#3-迭代器简单介绍" class="headerlink" title="3. 迭代器简单介绍"></a>3. 迭代器简单介绍</h3><p>STL的中心思想在于，将数据容器和算法分开，彼此独立设计，最后再将他们撮合在一起，而迭代器就扮演了这个黏胶角色。</p><p>迭代器是一种行为类似指针的对象，而指针行为中最常见的内容是提领（dereference）和成员访问（member access）因此迭代器最重要的工作就是对opreator* 和 opreator-&gt; 进行重载工作。</p><h3 id="4-容器"><a href="#4-容器" class="headerlink" title="4. 容器"></a>4. 容器</h3><h4 id="4-1-容器分类"><a href="#4-1-容器分类" class="headerlink" title="4.1 容器分类"></a>4.1 容器分类</h4><ul><li>序列化容器：array，vector，heap，priority_queue, list，slist（非标准），deque，stack（适配器），queue（适配器）</li><li>关联型容器：set，map，multiset，multimap，hashtable（非标准），hash_set（非标准），hash_map（非标准），hash_multiset（非标准），hash_multimap（非标准）</li></ul><h4 id="4-2-衍生"><a href="#4-2-衍生" class="headerlink" title="4.2 衍生"></a>4.2 衍生</h4><p>这里的衍生不是派生，是内含</p><ul><li>heap内部包含vector</li><li>priority_queue内部包含一个heap</li><li>stack/queue都包含一个deque</li><li>set/map/multiset/multimap内含一个RB-tree</li><li>hash_x内含一个hashtable</li></ul><h4 id="4-3-vector"><a href="#4-3-vector" class="headerlink" title="4.3 vector"></a>4.3 vector</h4><h5 id="4-3-1-vector的扩容机制"><a href="#4-3-1-vector的扩容机制" class="headerlink" title="4.3.1 vector的扩容机制"></a>4.3.1 vector的扩容机制</h5><p>新增元素：vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，再插入新增的元素。</p><p>对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了</p><p>初始时刻vector的capacity为0，插入第一个元素后capacity增加为1.</p><p>不同的编译器实现扩容的方式不一样，GCC以2倍扩容。有些选择1.5</p><ul><li>vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好。</li><li>为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用，因为更好。</li></ul><h4 id="4-4-红黑树"><a href="#4-4-红黑树" class="headerlink" title="4.4 红黑树"></a>4.4 红黑树</h4><h5 id="4-4-1-红黑树的特性"><a href="#4-4-1-红黑树的特性" class="headerlink" title="4.4.1 红黑树的特性"></a>4.4.1 红黑树的特性</h5><ol><li>它是一棵二叉排序树<ol><li>若左子树不为空，则左子树上所有节点的值都小于等于跟节点的值</li><li>若右子树不为空，则右子树上所有节点的值都大于等于跟节点的值</li><li>左右子树分别也是二叉排序树。</li></ol></li><li>红黑树的要求<ol><li>树中节点非黑即红</li><li>根结点必须为黑节点</li><li>每个叶节点必须为黑节点</li><li>红节点的字节点必须为黑</li><li>从根出发任何路径上的黑节点数量相同</li></ol></li><li>查找时间为O(logN)</li></ol><h4 id="4-4-2-与AVL树，BST树的区别"><a href="#4-4-2-与AVL树，BST树的区别" class="headerlink" title="4.4.2 与AVL树，BST树的区别"></a>4.4.2 与AVL树，BST树的区别</h4><ul><li>相比于AVL(平衡二叉查找树），红黑树的平衡性要差一些。不过创建红黑树时所需的旋转操作也会少很多。相比于最简单的BST（二叉搜索树），BST最差情况下的查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn).所以说红黑树之所以能够在STL及Linux内核中被广泛应用就是因为其折中了两种方案，既减少了树高，又减少了建树时旋转的次数。</li><li>从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列……最长路径不会大于2n，这里路径长就是树高.</li><li>AVL最坏情况下也是O(logN),但是为了满足平衡性，需要更多的旋转操作，所以红黑树的统计性能要比AVL高。<strong>此外，由于红黑树的设计，任何不平衡都会在三次旋转之内解决</strong>（插入两次、删除三次）,O(logN)次变色。</li></ul><h4 id="4-5-hashtable"><a href="#4-5-hashtable" class="headerlink" title="4.5 hashtable"></a>4.5 hashtable</h4><p><code>hashtable</code>被视为一种字典结构，提供对于任何有名项的存取操作和删除操作。</p><p>如何避免array过大？是用某种映射函数，使得元素映射至“大小可以接受的索引”，这个函数被称为散列函数。使用散列函数必然会带来一个问题：可能有不同的元素被映射到相同的位置，这便是所谓的碰撞问题。</p><p>碰撞问题一般有两种方案：拉链法、线性探测法。</p><h3 id="5-仿函数"><a href="#5-仿函数" class="headerlink" title="5. 仿函数"></a>5. 仿函数</h3><p>仿函数本质就是类重载了一个operator()，创建一个行为类似函数的对象。</p><p>仿函数对象仅仅占用1字节，因为内部没有数据成员，仅仅是一个重载的方法而已。实际上可以通过传递函数指针实现类似的功能，但是为了和STL内部配合使用，他提供了仿函数的特性。</p><h3 id="6-适配器"><a href="#6-适配器" class="headerlink" title="6. 适配器"></a>6. 适配器</h3><p>STL中的stack，queue通过双端队列deque适配实现</p><p>map，set通过RB-Tree适配实现。</p><p>涉及适配器模式。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;参考之前的笔记以及该&lt;a href=&quot;https://leetcode-cn.com/leetbook/read/cpp-interview-highlights&quot;&gt;leetbook&lt;/a&gt;整理。&lt;/p&gt;
&lt;h2 id=&quot;一、编译内存相关&quot;&gt;&lt;a href=&quot;#一、编译内存</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="c++" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c/"/>
    
    
    <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
    <category term="基础知识" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>多线程编程</title>
    <link href="http://yoursite.com/2021/01/02/C++/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2021/01/02/C++/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B/</id>
    <published>2021-01-02T04:28:12.000Z</published>
    <updated>2021-02-26T11:41:21.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程编程"><a href="#多线程编程" class="headerlink" title="多线程编程"></a>多线程编程</h1><h2 id="1-线程的启动、结束"><a href="#1-线程的启动、结束" class="headerlink" title="1. 线程的启动、结束"></a>1. 线程的启动、结束</h2><h3 id="1-1-线程运行的开始和结束"><a href="#1-1-线程运行的开始和结束" class="headerlink" title="1.1 线程运行的开始和结束"></a>1.1 线程运行的开始和结束</h3><ul><li>程序运行起来，生成一个进程，该进程所属的主线程开始自动运行；当主线程从main（）函数返回，则整个进程执行完毕</li><li>主线程从main（）开始执行，那么我们自己创建的线程，也需要从一个函数开始运行（初始函数），一旦这个函数运行完毕，线程也结束运行</li><li>整个进程是否执行完毕的标志是：主线程是否执行完，如果主线程执行完毕了，就代表整个进程执行完毕了，此时如果其他子线程还没有执行完，也会被强行终止【此条有例外，以后会解释】</li></ul><h3 id="1-2-创建一个线程"><a href="#1-2-创建一个线程" class="headerlink" title="1.2 创建一个线程"></a>1.2 创建一个线程</h3><ol><li>包含头文件thread</li><li>写初始函数</li><li>在main中创建thread</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;my thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 1. 创建线程，线程执行入口是func；2. 执行线程</span></span><br><span class="line">  <span class="function">thread <span class="title">mytobj</span><span class="params">(func)</span></span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 阻塞主线程兵等待mytobj执行完。之后主线程继续向下执行</span></span><br><span class="line">  <span class="comment">// join意为加入，汇合，子线程与主线程在此处汇合。</span></span><br><span class="line">  mytobj.join();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// mytobj.detach();</span></span><br><span class="line">  <span class="comment">// 分离，主线程不在与子线程汇合，不再等待子线程。分离后，子线程和主线程失去关联，驻留在后台，由C++运行时库接管。（守护线程）</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// joinable()判断是否可以使用join()或者detach()</span></span><br><span class="line">  <span class="keyword">if</span>(mytobj.joinable()) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;可以调用join()或者detach()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不能调用join()或者detach()&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>线程类参数是一个可调用对象。</strong></p></li><li><p>一组可执行的语句称为可调用对象，c++中的可调用对象可以是函数、函数指针、lambda表达式、bind创建的对象或者重载了函数调用运算符的类对象。</p></li><li><p>主线程执行完毕后，局部变量被销毁，内存被回收，如果子线程detach后，仍在引用或指向其中的变量，则会发生不可预知的错误。</p></li><li><p>bind绑定： <a href="https://www.cnblogs.com/jialin0x7c9/p/12219239.html">https://www.cnblogs.com/jialin0x7c9/p/12219239.html</a></p></li></ul><h3 id="1-3-其他创建线程的方法"><a href="#1-3-其他创建线程的方法" class="headerlink" title="1.3 其他创建线程的方法"></a>1.3 其他创建线程的方法</h3><ol><li><p>仿函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;my thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  A a;</span><br><span class="line">  <span class="function">thread <span class="title">mytobj</span><span class="params">(a)</span></span>;</span><br><span class="line">  mytobj.join();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>lambda表达式</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">auto</span> a = []() &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;my thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">mytobj</span><span class="params">(a)</span></span>;</span><br><span class="line">  mytobj.join();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>成员函数做线程函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    A(<span class="keyword">int</span> _i) : i(_i) &#123;&#125;</span><br><span class="line">    A(<span class="keyword">const</span> A&amp; a) &#123;<span class="keyword">this</span>-&gt;i = a.i;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">thread_work</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;my thread. num : &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">      <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;i: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">A <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 生成类对象</span></span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">mytobj</span><span class="params">(&amp;A::thread_work, a, <span class="number">15</span>)</span></span>; <span class="comment">// 拷贝a到子进程</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// thread mytobj(&amp;A::thread_work, ref(a), 15); 引用a到子进程</span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  mytobj.join();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="1-4-创建和等待多个线程"><a href="#1-4-创建和等待多个线程" class="headerlink" title="1.4 创建和等待多个线程"></a>1.4 创建和等待多个线程</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;mythread &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">vector</span>&lt;thread&gt; mythreads;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    mythreads.push_back(thread(func, i));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span> it = mythreads.begin(); it != mythreads.end(); ++it) &#123;</span><br><span class="line">    it-&gt;join();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>把thread对象放入到容器中管理，看起来像个thread对象数组，对一次创建大量的线程并对大量线程进行管理有好处</li><li>多个线程执行顺序是乱的，跟操作系统内部对线程的运行调度机制有关</li></ul><h2 id="2-线程传参"><a href="#2-线程传参" class="headerlink" title="2 线程传参"></a>2 线程传参</h2><h3 id="2-1-传递临时对象做线程参数"><a href="#2-1-传递临时对象做线程参数" class="headerlink" title="2.1 传递临时对象做线程参数"></a>2.1 传递临时对象做线程参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">char</span>* pmybuff)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; pmybuff &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> var = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">char</span> mybuff[] = <span class="string">&quot;This is my test!&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">mytobj</span><span class="params">(func, var, mybuff)</span></span>; <span class="comment">// 如果是detach，可能会出现mybuff已经释放，但是子进程还在用。如果func参数类型是string，则有可能在隐式转换前释放的可能。</span></span><br><span class="line">  mytobj.join();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>传引用用std::ref(), 否则线程会值传递。</li><li>detach时，指针会有问题。（指向的内存是一个）。</li><li>const 引用，可以接收右值</li></ul><h3 id="2-2-线程id"><a href="#2-2-线程id" class="headerlink" title="2.2 线程id"></a>2.2 线程id</h3><ul><li>id是个数字，每个线程（不管是主线程还是子线程）实际上都对应着一个数字，而且每个线程对应的这个数字都不一样</li><li>线程id可以用C++标准库里的函数来获取。std::this_thread::get_id()来获取</li></ul><h3 id="2-3-总结"><a href="#2-3-总结" class="headerlink" title="2.3 总结"></a>2.3 总结</h3><ul><li>如果传递int这种简单类型，推荐使用值传递，不要用引用</li><li>如果传递类对象，避免使用隐式类型转换，全部都是创建线程这一行就创建出临时对象，然后在函数参数里，用引用来接，否则还会创建出一个对象</li><li>不建议使用detach。</li></ul><h3 id="2-4-传递类对象作为线程参数"><a href="#2-4-传递类对象作为线程参数" class="headerlink" title="2.4 传递类对象作为线程参数"></a>2.4 传递类对象作为线程参数</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pmn)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; *pmn &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">myp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">100</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">thread <span class="title">mytobj</span><span class="params">(func, move(myp))</span></span>; <span class="comment">// 将指针控制权交给子进程。detach可能会出错，内存泄漏</span></span><br><span class="line"></span><br><span class="line">  mytobj.join();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; (myp == <span class="literal">nullptr</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;main thread.&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-互斥量"><a href="#3-互斥量" class="headerlink" title="3 互斥量"></a>3 互斥量</h2><h3 id="3-1-互斥量的用法"><a href="#3-1-互斥量的用法" class="headerlink" title="3.1 互斥量的用法"></a>3.1 互斥量的用法</h3><h4 id="3-1-1-incldue"><a href="#3-1-1-incldue" class="headerlink" title="3.1.1 #incldue "></a>3.1.1 #incldue <mutex></h4><h4 id="3-1-2-lock-unlock"><a href="#3-1-2-lock-unlock" class="headerlink" title="3.1.2 lock(), unlock()"></a>3.1.2 lock(), unlock()</h4><ul><li>lock(), 操作共享数据， unlock()</li><li>lock() 和 unlock() 成对使用。</li></ul><h3 id="3-1-3-lock-guard类模版"><a href="#3-1-3-lock-guard类模版" class="headerlink" title="3.1.3 lock_guard类模版"></a>3.1.3 lock_guard类模版</h3><ul><li>lock_guard<mutex> sbguard(myMutex); 取代lock() 和unlock()</li><li>lock_guard 构造函数执行了mutex::lock(), 在作用域结束时，调用析构函数，执行mutex::unlock()</li></ul><h3 id="3-2-死锁"><a href="#3-2-死锁" class="headerlink" title="3.2 死锁"></a>3.2 死锁</h3><p>只要保证多个互斥量上锁的顺序一样就不会造成死锁。</p><h4 id="3-2-1-std-lock-函数模板"><a href="#3-2-1-std-lock-函数模板" class="headerlink" title="3.2.1 std::lock()函数模板"></a>3.2.1 std::lock()函数模板</h4><ul><li>std::lock(mutex1, mutex2, …); 一次锁定多个互斥量，用于处理多个互斥量。</li><li>如果互斥量中有一个没锁住，他就会等待至所有互斥量都锁住才继续执行。如果一个没锁住就会把已经锁住的释放掉（要么都锁住，要么都没锁，防止死锁）</li></ul><h4 id="3-2-2-std-lock-guard-的std-adapt-lock参数"><a href="#3-2-2-std-lock-guard-的std-adapt-lock参数" class="headerlink" title="3.2.2 std::lock_guard()的std::adapt_lock参数"></a>3.2.2 std::lock_guard()的std::adapt_lock参数</h4><ul><li><pre><code>std::lock_guard&lt;std::mutex&gt; my_guard(my_mutex, std::adopt_lock);//加入adopt_lock后，在调用lock_guard的构造函数时，不会在进行lock()<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">+ adopt_guard为结构体对象，起一个标记作用，表示这个互斥量已经lock()，不需要在lock()</span><br><span class="line"></span><br><span class="line">## 4 unique_lock</span><br><span class="line"></span><br><span class="line">### 4.1 unique_lock取代lock_guard</span><br><span class="line"></span><br><span class="line">unique_lock比lock_guard灵活很多（多出来很多用法），效率差一点</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c++</span><br><span class="line">unique_lock&lt;mutex&gt; myUniLock(myMutex);</span><br></pre></td></tr></table></figure></code></pre></li></ul><h3 id="4-2-unique-lock的第二个参数"><a href="#4-2-unique-lock的第二个参数" class="headerlink" title="4.2 unique_lock的第二个参数"></a>4.2 unique_lock的第二个参数</h3><h4 id="4-2-1-std-adopt-lock"><a href="#4-2-1-std-adopt-lock" class="headerlink" title="4.2.1 std::adopt_lock:"></a>4.2.1 std::adopt_lock:</h4><ul><li>表示这个互斥量已经被lock(),即不需要在构造函数中lock这个互斥量了。</li><li>前提：必须提前lock</li><li>lock_guard中也可以用这个参数</li></ul><h4 id="4-2-2-std-try-to-lock"><a href="#4-2-2-std-try-to-lock" class="headerlink" title="4.2.2 std::try_to_lock:"></a>4.2.2 std::try_to_lock:</h4><ul><li>尝试用mutex的lock()去锁定这个mutex，如果没有锁定成功，立即返回，不会阻塞</li><li>使用try_to_lock的原因是防止其他的线程锁定mutex太长时间，导致本线程一直阻塞在lock这个地方</li><li>前提：不能提前lock();</li><li>owns_locks()方法判断是否拿到锁，如拿到返回true</li></ul><h4 id="4-2-3-std-defer-lock"><a href="#4-2-3-std-defer-lock" class="headerlink" title="4.2.3 std::defer_lock:"></a>4.2.3 std::defer_lock:</h4><ul><li>如果没有第二个参数就对mutex进行加锁，加上defer_lock是始化了一个没有加锁的mutex</li><li>不给它加锁的目的是以后可以调用unique_lock的一些方法</li><li>前提：不能提前lock</li></ul><h3 id="4-3-unique-lock的成员函数（前三个与std-defer-lock联合使用）"><a href="#4-3-unique-lock的成员函数（前三个与std-defer-lock联合使用）" class="headerlink" title="4.3 unique_lock的成员函数（前三个与std::defer_lock联合使用）"></a>4.3 unique_lock的成员函数（前三个与std::defer_lock联合使用）</h3><h4 id="4-3-1-lock-加锁"><a href="#4-3-1-lock-加锁" class="headerlink" title="4.3.1 lock() 加锁"></a>4.3.1 lock() 加锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">unique_lock&lt;mutex&gt; myUniLock(myMutex， defer_lock);</span><br><span class="line">myUniLock.lock();</span><br></pre></td></tr></table></figure><p>不用自己unlock()</p><h4 id="4-3-2-unlock-解锁"><a href="#4-3-2-unlock-解锁" class="headerlink" title="4.3.2 unlock() 解锁"></a>4.3.2 unlock() 解锁</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock</span><span class="params">(myMutex， defer_lock)</span></span>;</span><br><span class="line">myUniLock.lock();</span><br><span class="line"><span class="comment">//处理一些共享代码</span></span><br><span class="line">myUniLock.unlock();</span><br><span class="line"><span class="comment">//处理一些非共享代码</span></span><br><span class="line">myUniLock.lock();</span><br><span class="line"><span class="comment">//处理一些共享代码</span></span><br></pre></td></tr></table></figure><p>因为一些非共享代码要处理，可以暂时先unlock()，用其他线程把它们处理了，处理完后再lock()。</p><h4 id="4-3-3-try-lock-尝试给互斥量加锁"><a href="#4-3-3-try-lock-尝试给互斥量加锁" class="headerlink" title="4.3.3 try_lock() : 尝试给互斥量加锁"></a>4.3.3 try_lock() : 尝试给互斥量加锁</h4><p>如果拿不到锁，返回false，否则返回true。</p><h4 id="4-3-4-release"><a href="#4-3-4-release" class="headerlink" title="4.3.4 release():"></a>4.3.4 release():</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock</span><span class="params">(myMutex)</span></span>;</span><br></pre></td></tr></table></figure><p>相当于把myMutex和myUniLock绑定在了一起，release()就是解除绑定，返回他所管理的mutex对象的指针，并释放所有权。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mutex* ptx = myUniLock.release();</span><br></pre></td></tr></table></figure><p>所有权由ptx接管，如果原来mutex对象处理加锁状态，就需要ptx在以后进行解锁了</p><p>lock的代码段越少，执行越快，整个程序的运行效率越高。</p><ol><li>锁住的代码少，叫做粒度细，执行效率高；</li><li>锁住的代码多，叫做粒度粗，执行效率低；</li></ol><h3 id="4-4-unique-lock所有权的传递"><a href="#4-4-unique-lock所有权的传递" class="headerlink" title="4.4 unique_lock所有权的传递"></a>4.4 unique_lock所有权的传递</h3><ol><li><p>使用move转移</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">unique_lock <span class="title">myUniLock2</span><span class="params">(<span class="built_in">std</span>::move(myUniLock))</span></span>;</span><br></pre></td></tr></table></figure></li><li><p>在函数中return一个临时变量，即可实现转移</p></li><li><pre><code class="c++"><span class="function">unique_lock&lt;mutex&gt; <span class="title">aFunction</span><span class="params">()</span></span><span class="function"></span>&#123;    <span class="function">unique_lock&lt;mutex&gt; <span class="title">myUniLock</span><span class="params">(myMutex)</span></span>;    <span class="comment">//移动构造函数那里讲从函数返回一个局部的unique_lock对象是可以的</span>    <span class="comment">//返回这种局部对象会导致系统生成临时的unique_lock对象，并调用unique_lock的移动构造函数</span>    <span class="keyword">return</span> myUniLock;&#125;&lt;!--code￼<span class="number">13</span>--&gt;</code></pre></li></ol><h2 id="6-条件变量"><a href="#6-条件变量" class="headerlink" title="6 条件变量"></a>6 条件变量</h2><h3 id="6-1-condition-variable"><a href="#6-1-condition-variable" class="headerlink" title="6.1 condition_variable"></a>6.1 condition_variable</h3><ul><li><p>std::condition_variable实际上是一个类，是一个和条件相关的类，说白了就是等待一个条件达成。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::mutex mymutex1;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::unique_lock&lt;<span class="built_in">std</span>::mutex&gt; <span class="title">sbguard1</span><span class="params">(mymutex1)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::condition_variable condition;</span><br><span class="line">condition.wait(sbguard1, [<span class="keyword">this</span>] &#123;<span class="keyword">if</span> (!msgRecvQueue.empty())</span><br><span class="line">                                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                                &#125;);</span><br><span class="line"> </span><br><span class="line">condition.wait(sbguard1);</span><br></pre></td></tr></table></figure></li><li><p>wait()用来等一个东西</p><ul><li>如果第二个参数的lambda表达式返回值是false，那么wait()将<strong>解锁互斥量，并阻塞到本行</strong></li><li>如果第二个参数的lambda表达式返回值是true，那么wait()直接返回并继续执行。</li><li>阻塞到什么时候为止呢？阻塞到其他某个线程调用notify_one()成员函数为止</li><li>如果没有第二个参数，那么效果跟第二个参数lambda表达式返回false效果一样</li><li>wait()将解锁互斥量，并阻塞到本行，阻塞到其他某个线程调用notify_one()成员函数为止。</li><li>当其他线程用notify_one()将本线程wait()唤醒后，这个wait恢复后<ol><li>wait()不断尝试获取互斥量锁，如果获取不到那么流程就卡在wait()这里等待获取，如果获取到了，那么wait()就继续执行，获取到了锁</li><li>如果wait有第二个参数就判断这个lambda表达式。<ol><li>如果表达式为false，那wait又对互斥量解锁，然后又休眠，等待再次被notify_one()唤醒</li><li>如果lambda表达式为true，则wait返回，流程可以继续执行（此时互斥量已被锁住）。</li></ol></li><li>如果wait没有第二个参数，则wait返回，流程走下去。</li></ol></li><li>流程只要走到了wait()下面则互斥量一定被锁住了。</li></ul></li><li><p>notify_one()：通知一个线程的wait()</p></li><li><p>notify_all()：通知所有线程的wait()</p></li></ul><h3 id="6-2-虚假唤醒"><a href="#6-2-虚假唤醒" class="headerlink" title="6.2 虚假唤醒"></a>6.2 虚假唤醒</h3><p>notify_one或者notify_all唤醒wait()后，实际有些线程可能不满足唤醒的条件，就会造成虚假唤醒，可以在wait中再次进行判断解决虚假唤醒。<br>解决：wait中要有第二个参数（lambda），并且这个lambda中要正确判断所处理的公共数据是否存在</p><h2 id="7-std-atomic-原子操作"><a href="#7-std-atomic-原子操作" class="headerlink" title="7 std::atomic 原子操作"></a>7 std::atomic 原子操作</h2><h3 id="7-1-互斥"><a href="#7-1-互斥" class="headerlink" title="7.1 互斥"></a>7.1 互斥</h3><ul><li>互斥量：多线程编程中 用于保护共享数据：先锁住， 操作共享数据， 解锁。</li><li>有两个线程，对一个变量进行操作，一个线程读这个变量的值，一个线程往这个变量中写值。即使是一个简单变量的读取和写入操作，如果不加锁，也有可能会导致读写值混乱（一条C语句会被拆成3、4条汇编语句来执行，所以仍然有可能混乱）</li></ul><h3 id="7-2-std-atomic"><a href="#7-2-std-atomic" class="headerlink" title="7.2 std::atomic"></a>7.2 std::atomic</h3><ul><li>大家可以把原子操作理解成一种：不需要用到互斥量加锁（无锁）技术的多线程并发编程方式。</li><li>原子操作：在多线程中不会被打断的程序执行片段。</li><li>从效率上来说，原子操作要比互斥量的方式效率要高。</li><li>互斥量的加锁一般是针对一个代码段，而原子操作针对的一般都是一个变量。</li><li>原子操作，一般都是指“不可分割的操作”；也就是说这种操作状态要么是完成的，要么是没完成的，不可能出现半完成状态。</li><li>std::atomic来代表原子操作，是个类模板。其实std::atomic是用来封装某个类型的值的</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">atomic&lt;<span class="keyword">int</span>&gt; <span class="title">g_count</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">    ++g_count;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(mythread)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(mythread)</span></span>;</span><br><span class="line">  t1.join();</span><br><span class="line">  t2.join();</span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; g_count &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 20000</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>原子操作一般用于计数或者统计（如累计发送多少个数据包，累计接收到了多少个数据包），多个线程一起统计，这种情况如果不使用原子操作会导致统计发生混乱。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">atomic&lt;<span class="keyword">int</span>&gt; <span class="title">g_count</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mythread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">    g_count = g_count + <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(mythread)</span></span>;</span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(mythread)</span></span>;</span><br><span class="line">  t1.join();</span><br><span class="line">  t2.join(); </span><br><span class="line">  <span class="built_in">cout</span> &lt;&lt; g_count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般atomic原子操作，针对++，–，+=，-=，&amp;=，|=，^=是支持的，其他操作不一定支持。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; atm = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; atm &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>这里只有读取atm是原子操作，但是整个这一行代码 cout &lt;&lt; atm &lt;&lt; endl; 并不是原子操作，导致最终显示在屏幕上的值是一个“曾经值”。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">int</span>&gt; atm = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span> atm2 = atm; </span><br></pre></td></tr></table></figure><p>不可以拷贝初始化</p><p>load()：以原子方式读取atomic对象的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">atomic&lt;<span class="keyword">int</span>&gt; <span class="title">atm2</span><span class="params">(atm.load())</span></span>;</span><br><span class="line">atm2.store(<span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>原子操作实质上是：不允许在进行原子对象操作时进行CPU的上下文切换。</p><h2 id="8-chrono"><a href="#8-chrono" class="headerlink" title="8 chrono"></a>8 chrono</h2><p><a href="https://www.cnblogs.com/zlshmily/p/10058427.html">https://www.cnblogs.com/zlshmily/p/10058427.html</a></p><h3 id="8-1-std-chrono-duration"><a href="#8-1-std-chrono-duration" class="headerlink" title="8.1 std::chrono::duration"></a>8.1 std::chrono::duration</h3><p>一段时间</p><h3 id="8-2-std-chrono-time-point"><a href="#8-2-std-chrono-time-point" class="headerlink" title="8.2 std::chrono::time_point"></a>8.2 std::chrono::time_point</h3><h3 id="8-3-1-std-chrono-system-clock"><a href="#8-3-1-std-chrono-system-clock" class="headerlink" title="8.3.1 std::chrono::system_clock"></a>8.3.1 std::chrono::system_clock</h3><p>它表示当前的系统时钟，系统中运行的所有进程使用now()得到的时间是一致的。</p><h3 id="8-3-2-std-chrono-steady-clock"><a href="#8-3-2-std-chrono-steady-clock" class="headerlink" title="8.3.2 std::chrono::steady_clock"></a>8.3.2 std::chrono::steady_clock</h3><p>为了表示稳定的时间间隔，后一次调用now()得到的时间总是比前一次的值大（这句话的意思其实是，如果中途修改了系统时间，也不影响now()的结果），每次tick都保证过了稳定的时间间隔。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 介绍&lt;chrono&gt; </span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">-- 一个精确中立的时间和日期库</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * 时钟:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * std::chrono::system_clock:  依据系统的当前时间 (不稳定)</span></span><br><span class="line"><span class="comment"> * std::chrono::steady_clock:  以统一的速率运行(不能被调整)</span></span><br><span class="line"><span class="comment"> * std::chrono::high_resolution_clock: 提供最小可能的滴答周期</span></span><br><span class="line"><span class="comment"> *                   (可能是steady_clock或者system_clock的typedef)</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * std:ratio&lt;&gt;表示时钟周期，即时间的计量单位</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::ratio&lt;<span class="number">1</span>,<span class="number">10</span>&gt;  r; <span class="comment">// </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; r.num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; r.den &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; chrono::system_clock::period::num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; chrono::system_clock::period::den &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; chrono::steady_clock::period::num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; chrono::steady_clock::period::den &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; chrono::high_resolution_clock::period::num &lt;&lt; <span class="string">&quot;/&quot;</span> &lt;&lt; chrono::high_resolution_clock::period::den &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * std:chrono::duration&lt;&gt;:  表示持续的时间</span></span><br><span class="line"><span class="comment"> *    duration&lt;int, ratio&lt;1,1&gt;&gt; --  秒数存储在一个int中 (默认)</span></span><br><span class="line"><span class="comment"> *    duration&lt;double, ration&lt;60,1&gt;&gt; -- 分钟数储存在一个double中</span></span><br><span class="line"><span class="comment"> *    库中定义了如下方便的duration:</span></span><br><span class="line"><span class="comment"> *    nanoseconds, microseconds, milliseconds, seconds, minutes, hours</span></span><br><span class="line"><span class="comment"> * system_clock::duration  -- duration&lt;T, system_clock::period&gt;</span></span><br><span class="line"><span class="comment"> *                                 T是一个有符号的算术类型, 可以是int或long或其他</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">chrono::microseconds <span class="title">mi</span><span class="params">(<span class="number">2745</span>)</span></span>;</span><br><span class="line">chrono::nanoseconds na = mi;</span><br><span class="line">chrono::milliseconds mill = chrono::duration_cast&lt;chrono::milliseconds&gt;(mi);  <span class="comment">// 当可能发生信息丢失的时候，要显式地转换</span></span><br><span class="line">  <span class="comment">// 直接截断，而不是四舍五入</span></span><br><span class="line">mi = mill + mi;  <span class="comment">// 2000 + 2745 = 4745</span></span><br><span class="line">mill = chrono::duration_cast&lt;chrono::milliseconds&gt;(mill + mi);  <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; na.count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mill.count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; mi.count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;min: &quot;</span> &lt;&lt; chrono::system_clock::duration::min().count() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">   <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;max: &quot;</span> &lt;&lt; chrono::system_clock::duration::max().count() &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"> <span class="comment">/* std::chrono::time_point&lt;&gt;: 表示一个时间点</span></span><br><span class="line"><span class="comment"> *       -- 自从一个指定的时间点开始的过去的时间长度: </span></span><br><span class="line"><span class="comment"> *          00:00 January 1, 1970 (Corordinated Universal Time - UTC)  -- 时钟的纪元</span></span><br><span class="line"><span class="comment"> * time_point&lt;system_clock, milliseconds&gt;:  依据system_clock, 自从纪元开始经过的毫秒数</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * typdefs</span></span><br><span class="line"><span class="comment">  system_clock::time_point  -- time_point&lt;system_clock, system_clock::duration&gt;</span></span><br><span class="line"><span class="comment">  steady_clock::time_point  -- time_point&lt;steady_clock, steady_clock::duration&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 使用系统时间</span></span><br><span class="line">chrono::system_clock::time_point tp = chrono::system_clock::now();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tp.time_since_epoch().count() &lt;&lt; <span class="built_in">endl</span>;  </span><br><span class="line">tp = tp + seconds(<span class="number">2</span>);  <span class="comment">// 因为tp精度高，不需要转换</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tp.time_since_epoch().count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算时间间隔最好用steady_clock</span></span><br><span class="line">chrono::steady_clock::time_point start = chrono::steady_clock::now();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;I am bored&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">chrono::steady_clock::time_point end = chrono::steady_clock::now();</span><br><span class="line">chrono::steady_clock::duration d = end - start;</span><br><span class="line"><span class="keyword">if</span> (d == chrono::steady_clock::duration::zero())    <span class="comment">//0时间长度的表示</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;no time elapsed&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; duration_cast&lt;microseconds&gt;(d).count() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">   <span class="comment">// 使用system_clock可能得到不正确的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;多线程编程&quot;&gt;&lt;a href=&quot;#多线程编程&quot; class=&quot;headerlink&quot; title=&quot;多线程编程&quot;&gt;&lt;/a&gt;多线程编程&lt;/h1&gt;&lt;h2 id=&quot;1-线程的启动、结束&quot;&gt;&lt;a href=&quot;#1-线程的启动、结束&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="c++" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/c/"/>
    
    
    <category term="c++" scheme="http://yoursite.com/tags/c/"/>
    
    <category term="多线程" scheme="http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>buttfly主题</title>
    <link href="http://yoursite.com/2020/10/29/butterfly%E4%B8%BB%E9%A2%98/"/>
    <id>http://yoursite.com/2020/10/29/butterfly%E4%B8%BB%E9%A2%98/</id>
    <published>2020-10-29T08:06:54.000Z</published>
    <updated>2021-02-26T11:41:21.888Z</updated>
    
    <content type="html"><![CDATA[<p>官方网站</p><p><a href="https://butterfly.js.org/">https://butterfly.js.org/</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asdf</span><br></pre></td></tr></table></figure><p>$S_a$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;官方网站&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://butterfly.js.org/&quot;&gt;https://butterfly.js.org/&lt;/a&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;g</summary>
      
    
    
    
    <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/03/05/hello-world/"/>
    <id>http://yoursite.com/2020/03/05/hello-world/</id>
    <published>2020-03-05T03:15:45.000Z</published>
    <updated>2021-02-26T11:41:21.888Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>markdown syntax</title>
    <link href="http://yoursite.com/2020/03/03/markdown-syntax/"/>
    <id>http://yoursite.com/2020/03/03/markdown-syntax/</id>
    <published>2020-03-03T12:17:35.000Z</published>
    <updated>2021-02-26T11:41:21.888Z</updated>
    
    <content type="html"><![CDATA[<p>$A$</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a1 = n1.split(<span class="string">&#x27;&#x27;</span>).reverse();</span><br><span class="line">  <span class="keyword">const</span> a2 = n2.split(<span class="string">&#x27;&#x27;</span>).reverse();</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">Math</span>.max(a1.length, a2.length); i &lt; l; i++) &#123;</span><br><span class="line">    result[i] = (result[i] || <span class="number">0</span>) + <span class="built_in">parseInt</span>(a1[i] || <span class="number">0</span>) + <span class="built_in">parseInt</span>(a2[i] || <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (result[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      result[i] -= <span class="number">10</span>;</span><br><span class="line">      result[i + <span class="number">1</span>] = (result[i + <span class="number">1</span>] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><strong>加粗</strong><br><em>倾斜</em><br><strong><em>加粗倾斜</em></strong><br><del>加删除线</del></p><blockquote><p>引用的内容（可以嵌套）</p></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><p><img src="http://file.koolearn.com/20161207/14810957953513.png" alt="图片 alt" title="网上随便找的"></p><p><a href="超链接地址" title="超链接title">超链接名</a></p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第二行分割表头和内容</span><br><span class="line">-有一个就行</span><br><span class="line">文字默认居左</span><br><span class="line">--两边加:表示文字居中</span><br><span class="line">--右边加:表示文字居右</span><br><span class="line">原生的语法两边都要用|包起来，此处原作者省略。</span><br></pre></td></tr></table></figure><p>单行代码:代码之间分别用一个反引号包起来<br><code>代码内容</code></p><p>代码块:代码之间分别用三个反引号包起来，且两边的反引号独占一行</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始 </span><br><span class="line">op&#x3D;&gt;operation: My Operation </span><br><span class="line">cond&#x3D;&gt;condition: Yes or No? </span><br><span class="line">e&#x3D;&gt;end: 结束 </span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond </span><br><span class="line">cond(yes)-&gt;e </span><br><span class="line">cond(no)-&gt;op </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;$A$&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;sp</summary>
      
    
    
    
    <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
