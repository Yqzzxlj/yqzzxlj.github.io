<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Yqzzxlj</title>
  
  <subtitle>hello world</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-29T12:38:37.741Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Yqzzxlj</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计算机网络（六）网络安全</title>
    <link href="http://yoursite.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%85%AD%EF%BC%89%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    <id>http://yoursite.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%85%AD%EF%BC%89%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/</id>
    <published>2020-10-29T12:34:18.000Z</published>
    <updated>2020-10-29T12:38:37.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安全通信"><a href="#安全通信" class="headerlink" title="安全通信"></a>安全通信</h2><ol><li>机密性（confidentiality） 因为窃听者可以截获报文，所以需要加密</li><li>报文完整性（message integrity） 确保没有被改动</li><li>端点鉴别（end-point authentication） 确定通信双方</li><li>运行安全性（operational security）  </li></ol><h2 id="密码学的原则"><a href="#密码学的原则" class="headerlink" title="密码学的原则"></a>密码学的原则</h2><p>明文（plaintext， clear text）<br>密文（cipher text）<br>密钥（key）<br>加密算法（encryption algorithm）<br>解密算法（decryption algorithm）</p><h3 id="对称密钥密码体制-（symmetric）"><a href="#对称密钥密码体制-（symmetric）" class="headerlink" title="对称密钥密码体制 （symmetric）"></a>对称密钥密码体制 （symmetric）</h3><p>对称性加密，也叫共享密钥密码。用相同的密钥进行加密和解密。</p><p>有很多优秀的对称加密算法。在算法上无懈可击，拥有巨大的密钥空间，基本无法暴力破解而且加密过程快速。</p><p>但是，一切对称加密算法的软肋在于密钥的配送。可以用密钥交换算法或非对称加密算法。</p><h4 id="Diffie-Hellman密钥交换算法"><a href="#Diffie-Hellman密钥交换算法" class="headerlink" title="Diffie-Hellman密钥交换算法"></a>Diffie-Hellman密钥交换算法</h4><ol><li>Alice 和 Bob 协商出两个数字 N 和 G 作为生成元</li><li>现在 Alice 和 Bob 心中各自想一个数字出来，分别称为 A 和 B</li><li>现在 Alice 将自己心里的这个数字 A 和 G 通过某些运算得出一个数 AG，然后发给 Bob；Bob 将自己心里的数 B 和 G 通过相同的运算得出一个数 BG，然后发给 Alice</li><li>Alice 可以通过 BG 和自己的 A 通过某些运算得到一个数 ABG，Bob 也可以通过 AG 和自己的 B 通过某些运算得到 ABG，这个数就是 Alice 和 Bob 共有的秘密</li></ol><h3 id="公开密钥加密"><a href="#公开密钥加密" class="headerlink" title="公开密钥加密"></a>公开密钥加密</h3><p>公钥用于加密，私钥用于解密。（RSA）</p><p>但是非对称加密算法无法确定通信双方的身份，会遭到中间人的攻击。比如 Hack 拦截 Bob 发出的公钥，然后冒充 Bob 的身份给 Alice 发送自己的公钥，那么不知情的 Alice 就会把私密数据用 Hack 的公钥加密，Hack 可以通过私钥解密窃取。</p><h3 id="报文完整性和数字签名"><a href="#报文完整性和数字签名" class="headerlink" title="报文完整性和数字签名"></a>报文完整性和数字签名</h3><h4 id="报文完整性"><a href="#报文完整性" class="headerlink" title="报文完整性"></a>报文完整性</h4><p>密码散列函数的附加性质：找到任意两个不同的报文x和y使得<code>$H(x)=H(y)$</code>,在计算上是不可能的。</p><p>报文鉴别码：</p><ol><li>Alice生成报文m并计算散列<code>$H(m)$</code></li><li>然后Alice将<code>$H(m)$</code>附加到报文m上，生成一个扩展报文（m, H(m)),并将该扩展报文发给Bob</li><li>Bob接收到一个扩展报文（m，h）并计算<code>$H(m)$</code>，如果<code>$H(m)=h$</code>,Bob会认为一切正常。</li></ol><p>缺陷： 其他人可以生成虚假报文（m’, H(m’)),Bob无法发现这种行为。</p><p>为解决这种缺陷，需要鉴别密钥（authentication key），共享秘密s。</p><ol><li>Alice生成报文m, 用s级联m以生成m+s，并计算散列<code>$H(m+s)$</code>。<code>$H(m+s)$</code>称为<strong>报文鉴别码</strong>（Message Authentication Code，MAC）</li><li>然后Alice将MAC附加到报文m上，生成一个扩展报文（m, H(m+s)),并将该扩展报文发给Bob</li><li>Bob接收到一个扩展报文（m，h）并计算<code>$H(m+s)$</code>，如果<code>$H(m+s)=h$</code>,Bob会认为一切正常。</li></ol><h4 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h4><p>数字签名是一种在数字领域表明身份的密码技术。</p><p>用私钥加密数据，然后把加密的数据公布出去，这就是数字签名。</p><h4 id="公钥认证"><a href="#公钥认证" class="headerlink" title="公钥认证"></a>公钥认证</h4><p>证书就是公钥+签名，由第三方认证机构颁发。<br>证书认证的流程：</p><ol><li>Bob去可信任的认证机构正是本人真实身份，并提供自己的公钥</li><li>Alice想和Bob通信时，先向认证机构请求Bob的公钥，认证机构会将一张证书（bob的公钥以及自己对其公钥的签名）发送给Alice</li><li>Alice检查签名，确定该公钥确实由这家认证机构发送，中途未被篡改。</li><li>Alice通过这个公钥加密数据，开始和Bob通信。</li></ol><p>正规浏览器中都预存了正规认证机构的证书（包含其公钥），用于确认机构身份。</p><h3 id="HTTPS是身披SSL外壳的HTTP"><a href="#HTTPS是身披SSL外壳的HTTP" class="headerlink" title="HTTPS是身披SSL外壳的HTTP"></a>HTTPS是身披SSL外壳的HTTP</h3><p>当HTTP加上加密处理和认证以及完整性保护后就是HTTPS。</p><p>HTTPS并非是应用层的一种新协议。只是HTTP通信接口部分用SSL（secure socket layer）和TLS（transport layer security）协议代替。</p><p>采用了SSL后，HTTP就有了HTTPS的加密、证书、和完整性保护这些功能。</p><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/HTTP%E5%92%8CHTTPS.png" alt=""></p><h2 id="使用TCP连接安全：SSL"><a href="#使用TCP连接安全：SSL" class="headerlink" title="使用TCP连接安全：SSL"></a>使用TCP连接安全：SSL</h2><p>安全套接字层（Secure Socket Layer）SSL<br>运输层安全性（Transport Layer Security） TLS</p><p>类SSL(和SSL)具有三个阶段：握手、密钥导出和数据传输。</p><h4 id="1-握手"><a href="#1-握手" class="headerlink" title="1.握手"></a>1.握手</h4><p>在握手阶段，Bob需要：<br>    1.  与Alice创建一条TCP连接<br>    2.  验证Alice是真实的Alice<br>    3.  发送给Alice一个主密钥（MS），Bob和Alice持用该主密钥生成SSL会话所需的所有对称密钥</p><h4 id="2-密钥导出"><a href="#2-密钥导出" class="headerlink" title="2.密钥导出"></a>2.密钥导出</h4><p>Alice和Bob用MS生成4个密钥：</p><ul><li><code>$E_B$</code>,用于从Bob发送到Alice的数据的会话加密密钥</li><li><code>$M_B$</code>,用于从Bob发送到Alice的数据的会话MAC密钥</li><li><code>$E_A$</code>,用于从Alice发送到Bob的数据的会话加密密钥</li><li><code>$M_A$</code>,用于从Alice发送到Bob的数据的会话MAC密钥</li></ul><h4 id="3-数据传输"><a href="#3-数据传输" class="headerlink" title="3.数据传输"></a>3.数据传输</h4><p>用密钥传输并维护一个序号计数器。防止被人乱序或删除报文。</p><h4 id="4-SSL记录"><a href="#4-SSL记录" class="headerlink" title="4.SSL记录"></a>4.SSL记录</h4><p>由类型字段、版本字段、长度字段、数据字段和MAC字段组成。前三个字段不加密。</p><p>类型字段用于指出该字段是握手报文还是包含应用数据的报文，也用于关闭SSL连接。、</p><p>在接受端的SSL使用长度字段从到达的TCP字节流中提取SSL记录。</p><p>版本字段是自解释的。</p><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/SSL%E8%AE%B0%E5%BD%95%E6%A0%BC%E5%BC%8F.png" alt=""></p><h2 id="常见网络攻击"><a href="#常见网络攻击" class="headerlink" title="常见网络攻击"></a>常见网络攻击</h2><h3 id="局域网ARP泛洪与欺骗"><a href="#局域网ARP泛洪与欺骗" class="headerlink" title="局域网ARP泛洪与欺骗"></a>局域网ARP泛洪与欺骗</h3><h4 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h4><p>地址解析协议，根据IP地址获取MAC地址的一个网络层协议。</p><ol><li>ARP首先会发起一个请求数据包，数据包的首部包含了目标主机的IP地址，然后这个数据包会在链路层进行再次包装，生成以太网数据包，最终由以太网广播给子网内的所有主机</li><li>每一台主机都会接收到这个数据包，并取出标头里的IP地址，然后和自己的IP地址进行比较，如果相同就返回自己的MAC地址，如果不同就丢弃该数据包</li><li>ARP接收返回消息，以此确定目标机的MAC地址，与此同时，ARP还会将返回的MAC地址与对应的IP地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</li></ol><p>正常的通信是除非一开始mac表中没有目标主机的mac和端口，这样才进行数据广播，只要mac表中有相应的绑定关系，之后两台主机间的通信，都是由交换机直接根据mac和端口绑定进行转发，其他的主机是获取不到这两台主机之间的数据的。</p><h4 id="泛洪"><a href="#泛洪" class="headerlink" title="泛洪"></a>泛洪</h4><p>主机A在自己的ARP缓存中没有找到主机B的IP地址，并且交换机中也没有主机B的信息。交换机会将数据报发送到A所在端口以外的所有端口，这就是泛洪。</p><h4 id="泛洪攻击的实现方法"><a href="#泛洪攻击的实现方法" class="headerlink" title="泛洪攻击的实现方法"></a>泛洪攻击的实现方法</h4><p>泛洪攻击的目标就是想获取主机之间的通信数据。要想达到这个目的，就需要强迫交换机进行数据广播，那就要实现mac表中没有目标主机的mac和端口绑定。</p><p>通过伪造大量的未知mac地址进行通信，交换机进行不断的学习，很快mac表就会被充满，这样正常的主机的mac地址在经过老化之后，就无法再添加到mac地址表中，导致之后的数据都变成了广播。</p><h4 id="欺骗方法"><a href="#欺骗方法" class="headerlink" title="欺骗方法"></a>欺骗方法</h4><p>然后抓取合法的计算机回复自己的mac地址，并将自己IP地址伪装成抓取到的IP地址。</p><p>ARP攻击主要在局域网中，因为ARP包不会跨网络传播。</p><h4 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h4><ol><li>进行MAC和IP地址进行绑定</li><li>杀毒软件开启arp防火墙</li></ol><h3 id="DDoS（Distributed-Denial-of-Service）"><a href="#DDoS（Distributed-Denial-of-Service）" class="headerlink" title="DDoS（Distributed Denial of Service）"></a>DDoS（Distributed Denial of Service）</h3><p>分布式拒绝服务。攻击者利用多台计算机对目标网站在较短的时间内发起大量请求，大规模消耗目标网站的主机资源，让它无法正常服务。</p><h4 id="应对方法"><a href="#应对方法" class="headerlink" title="应对方法"></a>应对方法</h4><ol><li>高防服务器</li><li>黑名单</li><li>DDos清洗，发现一直占用资源，清洗</li><li>CDN加速，隐藏真实IP，分流到各个节点。</li></ol><h3 id="TCP-SYN-Flood-（SYN-泛洪攻击）"><a href="#TCP-SYN-Flood-（SYN-泛洪攻击）" class="headerlink" title="TCP SYN Flood （SYN 泛洪攻击）"></a>TCP SYN Flood （SYN 泛洪攻击）</h3><p>经典的DOS攻击<br>攻击者发送大量的TCP SYN报文段，而不完成第三次握手的步骤。随着这种SYN报文段的到来，服务器不断为这些半开连接分配资源，导致服务器的连接资源被消耗殆尽。。</p><h4 id="防御系统"><a href="#防御系统" class="headerlink" title="防御系统"></a>防御系统</h4><p>SYN cookie</p><ol><li>当服务器接收到SYN报文段时，不分配资源。生成TCP序列号，与源和目的IP地址与端口号以及仅服务器知道的散列函数有关。称为cookie，但服务器不记忆该cookie和其他状态信息，发送回源主机。</li><li>收到ACK报文段后，通过cookie与ACK验证是否合法，生成连接。</li></ol><h3 id="XSS（Cross-Site-Scripting）-跨站脚本攻击"><a href="#XSS（Cross-Site-Scripting）-跨站脚本攻击" class="headerlink" title="XSS（Cross Site Scripting） 跨站脚本攻击"></a>XSS（Cross Site Scripting） 跨站脚本攻击</h3><p>是最普遍的Web应用安全漏洞。这类漏洞能够使得攻击者嵌入恶意脚本代码到正常用户会访问到的页面中，当正常用户访问该页面时，则可导致嵌入的恶意脚本代码的执行，从而达到恶意攻击用户的目的。</p><p>HTML是一种超文本标记语言，通过将一些字符特殊地对待来区别文本和标记，例如，小于符号（&lt;）被看作是HTML标签的开始，<title>与</title>之间的字符是页面的标题等等。当动态页面中插入的内容含有这些特殊字符（如&lt;）时，用户浏览器会将其误认为是插入了HTML标签，当这些HTML标签引入了一段JavaScript脚本时，这些脚本程序就将会在用户浏览器中执行。所以，当这些特殊字符不能被动态页面检查或检查出现失误时，就将会产生XSS漏洞。</p><p>常用的XSS攻击手段和目的有：</p><ol><li>盗用cookie，获取敏感信息。</li><li>利用植入Flash，通过crossdomain权限设置进一步获取更高权限；或者利用Java等得到类似的操作。</li><li>利用iframe、frame、XMLHttpRequest或上述Flash等方式，以（被攻击）用户的身份执行一些管理动作，或执行一些一般的如发微博、加好友、发私信等操作。</li><li>利用可被攻击的域受到其他域信任的特点，以受信任来源的身份请求一些平时不允许的操作，如进行不当的投票活动。</li><li>在访问量极大的一些页面上的XSS可以攻击一些小型网站，实现DDoS攻击的效果。</li><li>利用虚假输入表单骗取用户个人信息</li><li>显示伪造的文章或图片</li></ol><h3 id="SQL注入攻击"><a href="#SQL注入攻击" class="headerlink" title="SQL注入攻击"></a>SQL注入攻击</h3><h3 id="OS注入攻击"><a href="#OS注入攻击" class="headerlink" title="OS注入攻击"></a>OS注入攻击</h3><h2 id="Web的攻击技术"><a href="#Web的攻击技术" class="headerlink" title="Web的攻击技术"></a>Web的攻击技术</h2><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/%E9%92%88%E5%AF%B9Web%E7%9A%84%E6%94%BB%E5%87%BB%E6%8A%80%E6%9C%AF.png" alt=""><br><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/%E5%9B%A0%E8%BE%93%E5%87%BA%E5%80%BC%E8%BD%AC%E7%A7%BB%E4%B8%8D%E5%AE%8C%E5%85%A8%E5%BC%95%E5%8F%91%E7%9A%84%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E.png" alt=""><br><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/%E5%85%B6%E4%BB%96%E5%AE%89%E5%85%A8%E6%BC%8F%E6%B4%9E.png" alt=""></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;安全通信&quot;&gt;&lt;a href=&quot;#安全通信&quot; class=&quot;headerlink&quot; title=&quot;安全通信&quot;&gt;&lt;/a&gt;安全通信&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;机密性（confidentiality） 因为窃听者可以截获报文，所以需要加密&lt;/li&gt;
&lt;li&gt;报文完整性（m</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（五）数据链路层</title>
    <link href="http://yoursite.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%94%EF%BC%89%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/"/>
    <id>http://yoursite.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%94%EF%BC%89%E6%95%B0%E6%8D%AE%E9%93%BE%E8%B7%AF%E5%B1%82/</id>
    <published>2020-10-29T12:30:04.000Z</published>
    <updated>2020-10-29T12:38:37.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="数据链路的作用"><a href="#数据链路的作用" class="headerlink" title="数据链路的作用"></a>数据链路的作用</h2><p>数据链路层协议规定了通过信息通信媒介互联的设备之间传输的规范。0，1等计算机二进制 -&gt; 电压高低，光的闪灭以及电波强弱。</p><p>链路层的主体部分是在网络适配器（Network adapter）中实现的，网络适配器有时也称为网络接口卡（Network Interface Card， NIC）</p><h2 id="数据链路的相关技术"><a href="#数据链路的相关技术" class="headerlink" title="数据链路的相关技术"></a>数据链路的相关技术</h2><h3 id="MAC地址-（Medium-Access-Control）"><a href="#MAC地址-（Medium-Access-Control）" class="headerlink" title="MAC地址 （Medium Access Control）"></a>MAC地址 （Medium Access Control）</h3><p>用于识别数据链路中互连的节点。长48比特。不会重复。</p><h2 id="Web页面请求的历程"><a href="#Web页面请求的历程" class="headerlink" title="Web页面请求的历程"></a>Web页面请求的历程</h2><h3 id="DHCP、UDP、IP和以太网（找本机IP）"><a href="#DHCP、UDP、IP和以太网（找本机IP）" class="headerlink" title="DHCP、UDP、IP和以太网（找本机IP）"></a>DHCP、UDP、IP和以太网（找本机IP）</h3><p>DHCP四个步骤中仅有最后两个步骤是实际必要的。</p><ol><li>主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67（DHCP服务器）和源端口68（DHCP客户）的UDP报文段中。</li><li>该报文段被放入一个具有广播IP目的地址（255.255.255.255）和源IP地址（0.0.0.0)的IP数据报中，因为主机还没有一个IP地址。</li><li>该IP数据报被放置在以太网帧中，该MAC帧具有目的MAC地址（FF:FF:FF:FF:FF:FF),将该帧广播到交换机连接的所有设备(顺利的话也包括DHCP服务器)；该帧的源MAC地址时主机的MAC地址。</li><li>该帧是第一个由主机发送到以太网交换机中的帧。该交换机在所有的出端口广播入帧。</li><li>DHCP服务器的接口受到该帧，不断向上解析得到IP、UDP、DHCP报文，之后生成DHCP的ACK报文，该报文包括IP地址（CIDR分配策略），DNS服务器的IP地址、默认网关路由器的IP地址、子网掩码。将DHCP的ACK报文放入UDP报文段中，UDP报文段被放入IP数据报中，IP数据报在被放入一个以太网帧中。源MAC地址是服务器接口的MAC地址，目的MAC地址是主机MAC地址。</li><li>以太网帧发送到交换机中，由于交换机是自学习的（记录每个接口对应的MAC地址），并且受到过主机的以太网帧，所以交换机仅向主机接口转发该帧。</li><li>主机收到帧后，提取出IP数据报，取出UDP报文段，取出ACK报文。DHCP客户端记录下他的IP地址和他的DNS服务器的IP地址。并在<strong>IP转发表</strong>中安装默认网关的地址，主机会向网关发送目的地址为其子网以外的所有数据报。</li></ol><h3 id="DNS、ARP（找网关MAC地址"><a href="#DNS、ARP（找网关MAC地址" class="headerlink" title="DNS、ARP（找网关MAC地址)"></a>DNS、ARP（找网关MAC地址)</h3><ol start="8"><li>主机会通过浏览器生成一个TCP套接字，用于向网站发送HTTP请求，但是需要知道网站的IP地址。</li><li>主机的操作系统生成一个DNS查询报文，将网站的域名放入DNS报文的问题段中。将该报文放入一个目的端口号为53（DNS服务器）的UDP报文段中。该报文段被放入IP目的地址为DNS服务器，源地址为主机IP地址的IP数据报中。</li><li>数据报会放入到以太网帧中。该帧将发送到网关路由器。但是主机通过DHCP过程只知道网关路由器的IP地址，不知道网关路由器的MAC地址。为了获取网关的MAC地址，需要使用ARP协议。</li><li>主机生成一个具有目的IP地址为网关IP的ARP查询报文。放入到一个具有广播地址（FF:FF:FF:FF:FF:FF)的以太网帧中，并向交换机发送这个广播帧，交换机将帧发送给所有连接的设备，包括网关路由器。</li><li>网关在收到该帧后，发现目标IP与自己IP匹配，所以要发送一个ARP回答，指示自己的MAC地址对应自己的IP地址。将ARP回答放入以太网帧中，目的地址为主机的MAC地址，向交换机发送该帧，由交换机发送给主机。</li><li>主机收到该帧并抽取网关路由器的MAC地址，继续DNS解析过程。</li><li>将包含DNS查询报文的数据报放入目的地址为网关MAC地址的以太网帧中，通过交换机发送给网关路由器。主机报文的IP目的地址是DNS服务器，MAC目的地址是网关服务器。</li><li>网关接收到DNS查询的IP数据报后，根据IP数据报的目的地址选择转发给响应的路由器。</li><li>路由器收到IP数据报后，根据目的地址和转发表确定出接口，根据内部网关协议（RIP、OSPF）和外部网关协议（BGP）配置路由器到DNS的路由表项（路由选择）。</li><li>DNS服务器收到数据报后，抽取DNS查询报文。并在DNS库中查找域名。</li><li>找到包含对应域名的IP地址的DNS源记录后，向主机发送一个包含域名到IP地址映射的DNS回答报文，将该DNS回答报文放入UDP报文段、IP数据报中，通过路由器反转发给网关路由器，经过交换机到主机。</li><li>主机从报文中抽取服务器的IP地址。</li></ol><h3 id="TCP、HTTP"><a href="#TCP、HTTP" class="headerlink" title="TCP、HTTP"></a>TCP、HTTP</h3><ol start="20"><li>有了服务器的IP地址之后，便生成TCP套接字，用该套接字向服务器发送HTTP GET报文。</li><li>建立HTTP连接需要进行TCP连接，进行三次握手</li><li>建立连接后发送HTTP的GET报文，将报文放入TCP报文段的载荷中，然后生成IP数据报送往服务器。</li><li>服务器从TCP套接字中读取报文，生成HTTP响应报文，将页面内容放入HTTP响应体中，发送到主机。</li><li>浏览器收到HTTP响应报文后抽取Web页面内容进行渲染，显示web页面。</li></ol><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/web%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B.png" alt=""></p><h3 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h3><p>什么是DNS解析？当用户输入一个网址并按下回车键的时候，浏览器得到了一个域名。而在实际通信过程中，我们需要的是一个IP地址。因此我们需要先把域名转换成相应的IP地址，这个过程称作DNS解析。</p><ol><li>浏览器首先搜索浏览器自身缓存的DNS记录。</li><li>如果浏览器缓存中没有找到需要的记录或记录已经过期，则搜索hosts文件和操作系统缓存。</li><li>如果在hosts文件和操作系统缓存中没有找到需要的记录或记录已经过期，则向域名解析服务器发送解析请求。</li><li>如果域名解析服务器也没有该域名的记录，则开始递归+迭代解析。</li><li>获取域名对应的IP后，一步步向上返回，直到返回给浏览器。</li></ol><p>至此，浏览器就得到了url的IP地址。</p><h3 id="发起TCP请求"><a href="#发起TCP请求" class="headerlink" title="发起TCP请求"></a>发起TCP请求</h3><p>建立TCP连接的过程就是三次握手过程。</p><ol><li>客户端向服务器端发送连接请求的报文；</li><li>服务器端收到请求后，同意建立连接，向客户端发送确认报文；</li><li>客户端收到服务器端的确认报文后，再次向服务器端发出报文，确认已收到确认报文。</li></ol><p>至此，浏览器与服务器已经建立了TCP连接，开始进行通信。</p><h3 id="建立TCP连接后，浏览器向服务器发送HTTP请求"><a href="#建立TCP连接后，浏览器向服务器发送HTTP请求" class="headerlink" title="建立TCP连接后，浏览器向服务器发送HTTP请求"></a>建立TCP连接后，浏览器向服务器发送HTTP请求</h3><h3 id="负载均衡"><a href="#负载均衡" class="headerlink" title="负载均衡"></a>负载均衡</h3><p>什么是负载均衡？ 当一台服务器无法支持大量的用户访问时，将用户分摊到两个或多个服务器上的方法叫负载均衡。</p><ol><li>一般，如果我们的平台配备了负载均衡的话，前一步DNS解析获得的IP地址应该是我们Nginx负载均衡服务器的IP地址。所以我们的浏览器将我们的网页请求发送到了Nginx负载均衡服务器上。</li><li>Nginx根据我们设定的分配算法和规则，选择一台后端的真实Web服务器，与之建立TCP连接，并转发我们浏览器发出去的页面请求。</li><li>Web服务器收到请求，产生响应，并肩网页发送给Nginx负载均衡服务器。</li><li>Nginx负载均衡服务器将网页传递给filters链处理。之后发回给我们的浏览器。</li></ol><h3 id="服务器响应HTTP请求，将请求的指定资源发送给服务器"><a href="#服务器响应HTTP请求，将请求的指定资源发送给服务器" class="headerlink" title="服务器响应HTTP请求，将请求的指定资源发送给服务器"></a>服务器响应HTTP请求，将请求的指定资源发送给服务器</h3><h3 id="浏览器释放TCP连接"><a href="#浏览器释放TCP连接" class="headerlink" title="浏览器释放TCP连接"></a>浏览器释放TCP连接</h3><p>释放TCP连接的过程就是四次挥手的过程</p><ol><li>浏览器向服务器发送释放连接报文；</li><li>服务器收到释放报文后，发出确认报文，然后将服务器上未传送完的数据发送完；</li><li>服务器数据传输完成后，向浏览器发送释放连接请求；</li><li>浏览器收到报文后，发出确认，然后等待一段时间后，释放TCP连接。</li></ol><h3 id="浏览器渲染"><a href="#浏览器渲染" class="headerlink" title="浏览器渲染"></a>浏览器渲染</h3><ol><li>浏览器根据页面内容，生成DOM Tree。根据CSS内容，生成CSS Rule Tree(规则树)。调用JS执行引擎执行JS代码。</li><li>根据DOM Tree和CSS Rule Tree生成Render Tree(呈现树)</li><li>根据Render Tree渲染网页</li></ol><h2 id="相关问题"><a href="#相关问题" class="headerlink" title="相关问题"></a>相关问题</h2><h3 id="为什么有了-MAC-地址还要-IP-地址，IP-地址和-MAC-地址的区别是什么"><a href="#为什么有了-MAC-地址还要-IP-地址，IP-地址和-MAC-地址的区别是什么" class="headerlink" title="为什么有了 MAC 地址还要 IP 地址，IP 地址和 MAC 地址的区别是什么"></a>为什么有了 MAC 地址还要 IP 地址，IP 地址和 MAC 地址的区别是什么</h3><p>一. 整体与局部信息传递时候，需要知道的其实是两个地址：终点地址（Final destination address）下一跳的地址（Next hop address）IP地址本质上是终点地址，它在跳过路由器（hop）的时候不会改变，而MAC地址则是下一跳的地址，每跳过一次路由器都会改变。这就是为什么还要用MAC地址的原因之一，它起到了记录下一跳的信息的作用。注：一般来说IP地址经过路由器是不变的，不过NAT（Network address translation）例外，这也是有些人反对NAT而支持IPV6的原因之一。</p><p>二. 分层实现如果在IP包头（header）中增加了”下一跳IP地址“这个字段，在逻辑上来说，如果IP地址够用，交换机也支持根据IP地址转发（现在的二层交换机不支持这样做），其实MAC地址并不是必要的。但用MAC地址和IP地址两个地址，用于分别表示物理地址和逻辑地址是有好处的。这样分层可以使网络层与链路层的协议更灵活地替换，网络层不一定非要用『IP』协议，链路层也不一定非用『以太网』协议。这就像OSI七层模型，TCP/IP五层模型其实也不是必要的，用双层模型甚至单层模型实现网络也不是不可以的，只是那样做很蛋疼罢了。</p><p>三. 早期的『以太网』实现早期的以太网只有集线器（hub），没有交换机（switch），所以发出去的包能被以太网内的所有机器监听到，因此要附带上MAC地址，每个机器只需要接受与自己MAC地址相匹配的包。</p><p>MAC地址，意译为媒体访问控制，或称为物理地址、硬件地址，用来定义网络设备的位置。IP地址是IP协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p><p>IP地址和MAC地址区别：</p><p>1、MAC地址是物理地址，IP地址是逻辑地址。就是说MAC地址是不可改变的，IP地址是可以更改的；</p><p>2、MAC地址具有唯一性，每个硬件出厂时候的MAC地址是固定的；IP地址不具备唯一性，因此，很多应用软件是围绕MAC地址开发的。</p><p>3、工作层次不同</p><p>二层基于MAC地址转发数据帧，三层基于IP地址转发报文。二层交换机基于MAC地址表转发数据，路由器基于路由表（IP地址）转发数据。</p><p>4、长度定义</p><p>MAC地址是Ethernet网卡上带的地址，长度为48位；IP地址目前主流是32位长。IP地址和MAC地址通过ARP协议联系到一起。</p><h3 id="如何理解广播域和冲突域"><a href="#如何理解广播域和冲突域" class="headerlink" title="如何理解广播域和冲突域"></a>如何理解广播域和冲突域</h3><ul><li>1、冲突域：</li></ul><p>【定义】在同一个冲突域中的每一个节点都能收到所有被发送的帧。简单的说就是同一时间内只能有一台设备发送信息的范围。</p><p>【分层】基于OSI的第一层物理层</p><p>【设备】第二层设备能隔离冲突域，比如Switch。交换机能缩小冲突域的范围，交换接的每一个端口就是一个冲突域。</p><ul><li>2、广播域：</li></ul><p>【定义】网络中能接收任一设备发出的广播帧的所有设备的集合。简单的说如果站点发出一个广播信号，所有能接收收到这个信号的设备范围称为一个广播域。</p><p>【分层】基于OSI的第二层数据链路层</p><p>【设备】第三层设备才能隔离广播域，比如Router。路由器能隔离广播域，其每一个端口就是一个广播域。</p><h3 id="路由器和交换机有什么区别？"><a href="#路由器和交换机有什么区别？" class="headerlink" title="路由器和交换机有什么区别？"></a>路由器和交换机有什么区别？</h3><ul><li>工作层次不同：</li></ul><p>交换机主要工作在数据链路层（第二层）</p><p>路由器工作在网络层（第三层）。</p><ul><li>转发依据不同：</li></ul><p>交换机转发所依据的对象时：MAC地址。（物理地址）</p><p>路由转发所依据的对象是：IP地址。（网络地址）</p><ul><li>主要功能不同：</li></ul><p>交换机主要用于组建局域网，而路由主要功能是将由交换机组好的局域网相互连接起来，或者接入Internet。</p><p>交换机能做的，路由都能做。交换机不能分割广播域，路由可以。路由还可以提供防火墙的功能。路由配置比交换机复杂。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;数据链路的作用&quot;&gt;&lt;a href=&quot;#数据链路的作用&quot; class=&quot;headerlink&quot; title=&quot;数据链路的作用&quot;&gt;&lt;/a&gt;数据链路的作用&lt;/h2&gt;&lt;p&gt;数据链路层协议规定了通过信息通信媒介互联的设备之间传输的规范。0，1等计算机二进制 -&amp;gt; 电压</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（四）网络层</title>
    <link href="http://yoursite.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BD%91%E7%BB%9C%E5%B1%82/"/>
    <id>http://yoursite.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E5%9B%9B%EF%BC%89%E7%BD%91%E7%BB%9C%E5%B1%82/</id>
    <published>2020-10-29T12:26:49.000Z</published>
    <updated>2020-10-29T12:38:37.741Z</updated>
    
    <content type="html"><![CDATA[<h3 id="4-1-网络层概述"><a href="#4-1-网络层概述" class="headerlink" title="4.1 网络层概述"></a>4.1 网络层概述</h3><p>网络层能够被分解为两个相互作用的部分，即数据平面和控制平面<br>数据平面的主要作用是从其输入链路向其输出链路转发数据报；控制平面的主要作用是协调这些本地的路由器转发动作，使得数据报沿着源和目的地主机之间的路由器路径最终进行端到端传输。</p><h3 id="转发和路由选择：数据平面和控制平面"><a href="#转发和路由选择：数据平面和控制平面" class="headerlink" title="转发和路由选择：数据平面和控制平面"></a>转发和路由选择：数据平面和控制平面</h3><p><strong>转发</strong>是指将分组从一个输入链路接口转移到适当的输出链路接口的路由器本地动作。（硬件）</p><p><strong>路由选择</strong>是指确定分组从源到目的地所采取的端到端路径的网络范围处理过程。（软件）</p><h2 id="路由器工作原理"><a href="#路由器工作原理" class="headerlink" title="路由器工作原理"></a>路由器工作原理</h2><h2 id="网际协议：IPv4、寻址、IPv6及其他"><a href="#网际协议：IPv4、寻址、IPv6及其他" class="headerlink" title="网际协议：IPv4、寻址、IPv6及其他"></a>网际协议：IPv4、寻址、IPv6及其他</h2><p>IP地址属于网络层地址</p><p>IP属于面向无连接型</p><h3 id="IPv4-数据报格式"><a href="#IPv4-数据报格式" class="headerlink" title="IPv4 数据报格式"></a>IPv4 数据报格式</h3><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/IPv4%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt=""></p><ul><li><strong>版本号</strong>。由4比特构成，表示标识IP首部的版本号。字段值为4。</li><li><strong>首部长度</strong>。由4比特构成，表明IP首部的大小。因为IPv4包含一些可变数量的选项。</li><li><strong>服务类型</strong>。由8比特构成，表明服务质量。（优先级、时延、吞吐量）</li><li><strong>数据报长度</strong>。由16比特构成，表示IP数据报的总长度。</li><li><strong>标识</strong>。由16比特构成。用于分片重组。同一个分片的标识值相同，不同分片的标识值不同。</li><li><strong>标志</strong>。由3比特构成。表示包被分片的相关信息。</li><li><strong>片偏移</strong>。由13比特构成。用来表示被分片的每一个分段相对于原始数据的位置。</li><li><strong>生存时间（Time To Live，TTL）</strong>。由8比特构成。表示可以中转多少个路由器，每经过一个路由器，TTL会减少1，直到变成0则丢弃该包。</li><li><strong>上层协议</strong>。由8比特构成，表示IP数据报的数据部分应该交给哪个协议。</li><li><strong>首部检验和</strong>。由16比特构成，校验数据报的首部，不校验数据部分。用来确保IP数据报不被破坏。</li><li><strong>源地址</strong>。由32比特构成，表示发送端IP地址</li><li><strong>目标地址</strong>。由32比特构成，表示接受端IP地址</li><li><strong>可选项</strong>。 长度可变，在实验或诊断时使用，包括安全级别、源路径、路径记录、时间戳。</li><li><strong>数据</strong>。存入数据。包括IP上层协议的首部。</li></ul><h3 id="IPv4数据报分片"><a href="#IPv4数据报分片" class="headerlink" title="IPv4数据报分片"></a>IPv4数据报分片</h3><p>一个链路层帧能承载的最大数据量叫作最大传送单元（Maximun Transmission Unit， MTU）。每种数据链路的最大传输单元都不近相同。</p><p>路由器将IP数据报分片但不会进行重组，重组只能由目标主机进行。</p><h3 id="IPv4编址"><a href="#IPv4编址" class="headerlink" title="IPv4编址"></a>IPv4编址</h3><p>主机与物理链路之间的边界叫接口。一个IP地址与一个接口相关联，而不是与包括该接口的主机或路由器相关联。</p><p>IPv4地址由32位比特组成。每8位分成一组，分成4组，以”.”隔开，再将每组数转化为十进制数。</p><p>IPv4地址由网络标识（网络地址）和主机标识（主机地址）两部分组成。</p><p>子网掩码将原网络分为多个物理网络。</p><p>物件别域间路由选择（Classless Interdomain Routing， CIDR） 和<br>可变长子网掩码（Variable Length Subnet Mask， VLSM）技术采用任意长度分割IP地址的网络标识和主机标识。</p><p>广播地址。把IP地址中的主机地址部分全部设置为1，就成了广播地址。<br>在本网络内的广播叫本地广播，不同网络之间的广播叫直接广播。</p><p>多播。多播用于将包发送给特定组内的所有主机。</p><p>对于没有连接互联网的独立网络中的主机，只要保证在这个网络每地址唯一，可以不用考虑互联网即可配置响应的IP地址。私有网络的IP地址</p><ul><li>A类 10.0.0.0 ~ 10.255.255.255（10/8）</li><li>B类 172.16.0.0 ~ 172.31.255.255（172.16/12）</li><li>C类 192.168.0.0 ~ 192.168.255.255（192.168/16）<br>包含在这个范围内的IP地址都属于私有IP，在此之外的IP称为全局IP。</li></ul><h3 id="4-3-5-IPv6"><a href="#4-3-5-IPv6" class="headerlink" title="4.3.5 IPv6"></a>4.3.5 IPv6</h3><h4 id="1-IPv6数据报格式"><a href="#1-IPv6数据报格式" class="headerlink" title="1. IPv6数据报格式"></a>1. IPv6数据报格式</h4><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/IPv6%E6%95%B0%E6%8D%AE%E6%8A%A5%E6%A0%BC%E5%BC%8F.png" alt=""></p><p><strong>版本</strong>。 由4比特构成。6.</p><p><strong>流量类型</strong> 由8比特构成。与IPv4中TOS字段含义相似。</p><p><strong>流表签</strong> 由20比特构成。用于标识一条数据报的流。</p><p><strong>有效载荷长度</strong> 由16比特构成。有效载荷指包的数据部分。</p><p><strong>下一个首部</strong> 由8比特构成，相当于IPv4的协议字段</p><p><strong>跳限制</strong> 由8比特构成，相当于IPv4的TTL。</p><p><strong>源地址</strong> 由128比特构成。表示发送端IP地址</p><p><strong>目的地址</strong> 由128比特构成。表示接受端IP地址。</p><p>与IPv4数据报的几个字段不复存在：</p><ul><li>分片/重新组装： IPv6不允许在中间路由器上进行分片与重新组装。这种操作只能在源与目的地执行。</li><li>首部检验和： IP分组关注的重点是快速处理。减轻路由器负荷。</li><li>选项： 选项字段不再是首部的一部分，但他没有消失，可能出现在“下一个首部”指出的位置上。</li></ul><h4 id="IPv6的必要性"><a href="#IPv6的必要性" class="headerlink" title="IPv6的必要性"></a>IPv6的必要性</h4><ul><li>解决IPv4地址耗尽的问题</li><li>弥补IPv4中的大多数缺陷</li></ul><h4 id="IPv6的特点"><a href="#IPv6的特点" class="headerlink" title="IPv6的特点"></a>IPv6的特点</h4><ul><li>IP地址的扩大与路由控制表的聚合</li><li>性能提升：包首部采用固定的值（40字节），不再采用首部检验码，简化首部结构，减轻路由器负荷。路由器不再做分片处理。</li><li>支持即插即用功能：即使没有DHCP服务器也可以实现自动分配IP地址</li><li>采用认证与加密功能：应对伪造IP地址的网络安全功能以及防止线路窃听的功能（IPsec）</li><li>多播、MobileIP称为扩展功能</li></ul><h2 id="IP协议相关技术"><a href="#IP协议相关技术" class="headerlink" title="IP协议相关技术"></a>IP协议相关技术</h2><h3 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h3><p>主机名到IP地址转换的目录服务。 域名系统：（Domain Name System， DNS）</p><ul><li>主机向本地DNS服务器发送DNS查询报文，</li><li>本地DNS服务器将查询报文发送到根DNS服务器。</li><li>根服务器注意到edu前缀并向本地DNS服务器返回负责edu的TLD（Top-Level Domain， 顶级域）的IP地址列表。</li><li>本地DNS服务器在向这些TLD服务器之一发送查询报文。</li><li>TLD服务器注意到umass.edu前缀，并用权威DNS服务器的IP地址进行响应。</li><li>…</li></ul><h3 id="ARP"><a href="#ARP" class="headerlink" title="ARP"></a>ARP</h3><p>网络层地址（IP地址）和链路层地址（MAC地址）的转换。 地址解析协议（Address Resolution Protocol）</p><p>通过广播发送一个ARP请求包。<br>接受到包的主机发现目标IP与自己IP一致，就将自己的MAC地址返回。</p><h4 id="RARP-（Reverse-Address-Resolution-Protocol）"><a href="#RARP-（Reverse-Address-Resolution-Protocol）" class="headerlink" title="RARP （Reverse Address Resolution Protocol）"></a>RARP （Reverse Address Resolution Protocol）</h4><p>由MAC地址定位IP地址的协议</p><h3 id="ICMP-（Internet-Control-Message-Protocol）"><a href="#ICMP-（Internet-Control-Message-Protocol）" class="headerlink" title="ICMP （Internet Control Message Protocol）"></a>ICMP （Internet Control Message Protocol）</h3><p>因特网控制报文协议。被主机和路由器用来彼此沟通网络层的信息。（确认网络是否正常工作，遇到异常问题时进行诊断）</p><p>ICMP报文是IP的有效载荷。</p><h4 id="ICMP目标不可达消息（类型3）"><a href="#ICMP目标不可达消息（类型3）" class="headerlink" title="ICMP目标不可达消息（类型3）"></a>ICMP目标不可达消息（类型3）</h4><h4 id="ICMP重定向消息（类型5）"><a href="#ICMP重定向消息（类型5）" class="headerlink" title="ICMP重定向消息（类型5）"></a>ICMP重定向消息（类型5）</h4><h4 id="ICMP超时消息（类型11）"><a href="#ICMP超时消息（类型11）" class="headerlink" title="ICMP超时消息（类型11）"></a>ICMP超时消息（类型11）</h4><pre><code>TTL减为0时包被丢弃</code></pre><h4 id="ICMP回送消息（类型0、8）"><a href="#ICMP回送消息（类型0、8）" class="headerlink" title="ICMP回送消息（类型0、8）"></a>ICMP回送消息（类型0、8）</h4><pre><code>ping</code></pre><h4 id="ICMP原点抑制消息（类型4）"><a href="#ICMP原点抑制消息（类型4）" class="headerlink" title="ICMP原点抑制消息（类型4）"></a>ICMP原点抑制消息（类型4）</h4><pre><code>缓和网络拥堵</code></pre><h4 id="ICMP路由器探索消息（类型9、10）"><a href="#ICMP路由器探索消息（类型9、10）" class="headerlink" title="ICMP路由器探索消息（类型9、10）"></a>ICMP路由器探索消息（类型9、10）</h4><pre><code>发现与自己相连网络中的路由器。探索10，返回9.</code></pre><h4 id="ICMP地址掩码消息（类型17-18"><a href="#ICMP地址掩码消息（类型17-18" class="headerlink" title="ICMP地址掩码消息（类型17,18)"></a>ICMP地址掩码消息（类型17,18)</h4><pre><code>17发送、18返回。</code></pre><h3 id="DHCP（Dynamic-Host-Configuration）动态主机配置协议"><a href="#DHCP（Dynamic-Host-Configuration）动态主机配置协议" class="headerlink" title="DHCP（Dynamic Host Configuration）动态主机配置协议"></a>DHCP（Dynamic Host Configuration）动态主机配置协议</h3><p>实现自动设置IP地址、统一管理IP地址分配。实现即插即用。</p><ol><li>DHCP服务器发现：使用DHCP发现报文来寻找与其交互的DHCP服务器（广播目的地址255.255.255.255， 本机源IP地址0.0.0.0)</li><li>DHCP服务器提供：可能存在多个DHCP服务器。每台服务器提供的报文包含发现报文的事务ID、IP地址、网络掩码以及IP地址租用期。（广播目的地址255.255.255.255）</li><li>DHCP服务器请求：主机从一个或多个提供中选择一个，用DHCP请求报文进行响应。</li><li>DHCP ACK：服务器用DHCP ACK报文进行响应。交互完成。</li></ol><h3 id="NAT（Network-Address-Translation）-网络地址转换"><a href="#NAT（Network-Address-Translation）-网络地址转换" class="headerlink" title="NAT（Network Address Translation） 网络地址转换"></a>NAT（Network Address Translation） 网络地址转换</h3><p>在本地网络中使用私有地址，在连接互联网时使用全局IP地址的技术。除了转换IP地址外，还出现了可以转换TCP、UDP端口号的NAPT（Network Address Ports Translater）技术，由此可以实现一个全局IP地址与多个主机的通信。</p><p>NAT路由器上都有一张NAT转换表，包含了端口号及IP地址。</p><h3 id="IP隧道"><a href="#IP隧道" class="headerlink" title="IP隧道"></a>IP隧道</h3><p>两端的网络使用IPv6，中间的网络使用IPv4.</p><h3 id="其他IP相关技术"><a href="#其他IP相关技术" class="headerlink" title="其他IP相关技术"></a>其他IP相关技术</h3><h4 id="IP多播"><a href="#IP多播" class="headerlink" title="IP多播"></a>IP多播</h4><pre><code>多播用于将包发送给特定组内的所有主机。在采用多播功能之前，一直使用广播的方式，将数据发给所有主机再由IP之上的协议去判断是否接受。这样造成不必要的流量，且广播无法穿透路由。但是多播可以。</code></pre><h4 id="IP任播"><a href="#IP任播" class="headerlink" title="IP任播"></a>IP任播</h4><pre><code>像110或119一样，为提供同一种服务的服务器配置同一个IP地址，并与最近的服务器进行通信。</code></pre><h4 id="通信质量控制"><a href="#通信质量控制" class="headerlink" title="通信质量控制"></a>通信质量控制</h4><h4 id="显示拥塞通知"><a href="#显示拥塞通知" class="headerlink" title="显示拥塞通知"></a>显示拥塞通知</h4><h4 id="Mobile-IP"><a href="#Mobile-IP" class="headerlink" title="Mobile IP"></a>Mobile IP</h4><pre><code>移动设备每连接到不同的子网，都会由DHCP或手动的方式分配到不同的IP地址。无法进行TCP通信。</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;4-1-网络层概述&quot;&gt;&lt;a href=&quot;#4-1-网络层概述&quot; class=&quot;headerlink&quot; title=&quot;4.1 网络层概述&quot;&gt;&lt;/a&gt;4.1 网络层概述&lt;/h3&gt;&lt;p&gt;网络层能够被分解为两个相互作用的部分，即数据平面和控制平面&lt;br&gt;数据平面的主要作用</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（三）运输层</title>
    <link href="http://yoursite.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%90%E8%BE%93%E5%B1%82/"/>
    <id>http://yoursite.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%89%EF%BC%89%E8%BF%90%E8%BE%93%E5%B1%82/</id>
    <published>2020-10-29T12:23:54.000Z</published>
    <updated>2020-10-29T12:38:37.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>网络层提供了主机之间的逻辑通信，运输层协议为不同主机上的应用进程之间提供了逻辑通信。通过逻辑通信，运行不同进程的主机好像直相连一样。</p><p>运输层协议实在端系统而不是路由器中实现的。在发送端，运输层将从发送应用程序进程接受到的报文转换成运输层分组，称为<strong>报文段</strong>（segment）。</p><p><strong>UDP（User Datagram Protocol，用户数据报协议）</strong>为调用他的应用程序提供了一种不可靠、无连接的服务。</p><p><strong>TCP（Transmission Control Protocol， 传输控制协议）</strong> 为调用它的应用程序提供了一种可靠的、面向连接的服务。</p><p>IP的服务模型是尽力而为交付服务，不做任何确保。所以是<strong>不可靠服务</strong>。</p><p>将主机间交付拓展到进程间交付被称为运输层的<strong>多路复用（transport-layer multiplexing）</strong>与<strong>多路分解（demultiplexing）</strong></p><p>UDP流量是不可调节的，使用UDP的应用程序可以根据需要以其愿意的任何速率发送数据。</p><p>TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构。通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据从发送进程交付给接受进程。</p><p>TCP还提供<strong>拥塞控制（congestion control）</strong>。拥塞控制与其说是一种提供给调用它的应用程序的服务，不如说是一种提供给整个因特网的服务。TCP拥塞控制防止任何一条TCP连接用过多流量来淹没通信主机之间的链路和交换设备。TCP力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽。</p><h2 id="多路复用与多路分解"><a href="#多路复用与多路分解" class="headerlink" title="多路复用与多路分解"></a>多路复用与多路分解</h2><p>一个进程有一个或多个套接字（socket），它相当于从网络向进程传递数据和从进程向网络传递数据地门户。在接受主机地运输层实际上并没有将数据直接交付给进程，二是将数据交给一个中间地套接字。每个套接字都有一个标识符，标识符的格式取决于他是UDP还是TCP套接字。</p><p>将运输层报文段中地数据交付到正确地套接字（通过端口号）的工作称为<strong>多路分解（demultiplexing）</strong><br>在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层称为<strong>多路复用</strong>。</p><h2 id="UDP、无连接运输"><a href="#UDP、无连接运输" class="headerlink" title="UDP、无连接运输"></a>UDP、无连接运输</h2><p>UDP，常用在以下方面：</p><ul><li>包总量较少的通信（DNS，SNMP等）</li><li>视频、音频等多媒体通信（及时通信）</li><li>限定于LAN等特定网络中的应用通信</li><li>广播通信</li></ul><p>因为：</p><ul><li><p>关于发送什么数据以及何时发送的应用层控制更为精细：<br>  采用UDP时，只要应用进程将数据传递给UDP，UDP就会将此数据打包进UDP报文段并立即将其传递给网络层；TCP有拥塞控制机制，以便当源和目的主机间的一条或多条链路变得极度拥塞时来遏制TCP发送方。TCP仍将继续重新发送数据报文段直到目的主机收到此报文并加以确认，而不管可靠交付需要多长时间。</p><p>  而实时应用通常要求及时性，能够容忍一些数据丢失。</p></li><li><p>无需建立连接：<br>  TCP开始数据传输之前需要三次握手。UDP不需要任何准备即可进行数据传输。</p></li><li><p>无状态连接：<br>  TCP需要在端系统中维护连接状态。包括接受和发送缓存、拥塞控制参数以及序号与确认号的参数。UDP不维护连接状态，也不跟踪这些参数。</p></li><li><p>分组首部开销小 ：<br>  TCP40字节，UDP8字节。</p></li></ul><h3 id="UDP报文端结构"><a href="#UDP报文端结构" class="headerlink" title="UDP报文端结构"></a>UDP报文端结构</h3><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/UDP%E6%8A%A5%E6%96%87%E5%AD%97%E6%AE%B5.png" alt=""></p><p>端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程。</p><p>长度字段只是了UDP报文段中的字节数（首部＋数据)</p><h3 id="UDP检验和"><a href="#UDP检验和" class="headerlink" title="UDP检验和"></a>UDP检验和</h3><p>检验和提供了差错检测功能。因为不能保证源和目的之间的所有链路都提供差错检测。</p><p>虽然提供差错检测，但他对差错恢复无能为力。</p><h2 id="TCP-面向连接的运输"><a href="#TCP-面向连接的运输" class="headerlink" title="TCP 面向连接的运输"></a>TCP 面向连接的运输</h2><p>TCP提供<strong>全双工服务（full-duplex service）</strong>，点对点。</p><h3 id="TCP报文段结构"><a href="#TCP报文段结构" class="headerlink" title="TCP报文段结构"></a>TCP报文段结构</h3><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/TCP%E6%8A%A5%E6%96%87%E5%AD%97%E6%AE%B5.png" alt=""></p><p>20字节</p><ul><li><strong>源端口号</strong>和<strong>目的端口号</strong>用于多路复用与多路分解。16比特。</li><li>同UDP一样，TCP也包括<strong>检验和</strong>字段。16比特</li><li><strong>序号</strong>和<strong>确认号</strong>。32比特。用来实现可靠数据传输服务。</li><li><strong>接受窗口</strong>。16比特。用于流量控制，限制窗口大小到65535字节。</li><li><strong>首部长度</strong>。4比特。指示以32比特的字为单位的TCP首部长度，因为有<strong>选项字段</strong>，作为一个4比特的字节，TCP被限制为只能带60字节的头部。</li><li><strong>保留字段</strong>。4比特</li><li><strong>选项</strong>。可选与变长。在发送方与接收方协商最大报文段长度（MSS）时使用，或者在高速网络环境下用作窗口调节因子时使用、时间戳、ASCK（选择确认)。</li><li><strong>标志</strong> 8比特。<ol><li>ACK比特。指示确认字段中的值是有效的，即该报文段包括一个对已被成功接受报文段的确认</li><li>RST、SYN和FIN比特用于连接建立和拆除。</li><li>当PSH比特被置位，就指示接收方应立即将数据交给上层。</li><li>URG比特用来指示报文段里存在着被发送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由16比特的<strong>紧急数据指针字段（urgent data pointer field）</strong>指出，这个指针是一个必须要加到报文段的序列号字段上的正偏移。当紧急数据存在并给出指向紧急数据尾指针的时候，TCP必须通知接受端的上层实体。</li><li>CWR 拥塞窗口减（发送方降低它的发送速率）</li><li>ECE ECN回显（发送方接收到了一个更早的拥塞通告）<br>TCP包没有IP地址，这属于网络层，一个TCP连接需要4个元组（双方的IP端口）来保证是同一连接。</li></ol></li></ul><p>SequenceNumber来解决网络包乱序问题</p><p>ACK用于确认不丢包</p><p>RST 重置连接(连接取消，经常是因为错误)</p><p>Window是滑动窗口用来解决流控问题</p><h3 id="TCP连接管理"><a href="#TCP连接管理" class="headerlink" title="TCP连接管理"></a>TCP连接管理</h3><h4 id="连接创建：三次握手"><a href="#连接创建：三次握手" class="headerlink" title="连接创建：三次握手"></a>连接创建：三次握手</h4><ol><li>客户端发送SYN报文段（不包含应用层数据，SYN比特置为1）到服务器，指明想要连接的端口号。并随机选择一个初始序号（client_isn，Initial Sequence Number)，并将此编号放置于SYN报文段的序号字段中。并且进入SYN_SEND状态等待服务器确认</li><li>服务器收到SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户段TCP发送允许连接的报文段（也不包含应用层数据，SYN比特置为1）。其次，确认号字段被置为client_isn + 1.最后选择自己的初始序号（server_isn)放置到序号字段中。 服务器由LISTEN进入SYN_RECV状态。</li><li>客户端收到SYN+ACK报文段，为该连接分配TCP缓存和变量，并向服务器发送确认报文段（SYN比特置0，可以包含应用层数据）。将server_isn + 1 放进去确认字段。发送完毕客户端和服务器进入ESTABLISHED状态。</li></ol><h4 id="连接关闭：四次挥手"><a href="#连接关闭：四次挥手" class="headerlink" title="连接关闭：四次挥手"></a>连接关闭：四次挥手</h4><p>TCP有个特殊的概念叫半关闭，因为TCP连接是全双工连接，因此关闭连接必须关闭两个方向上的连接。</p><ol><li>客户端给服务器发送一个FIN报文段（FIN比特置为1）。并由ESTABLISHED状态进入FIN_WAIT_1状态，等待来自服务器的带有确认的TCP报文段。</li><li>服务器收到该报文段后，就向发送方回送一个确认报文段。由ESTABLISHED状态进入CLOSE_WAIT状态。客户端接收到确认后进入FIN_WAIT_2状态。</li><li>服务器发送自己的终止报文段（FIN比特置为1）。进入LAST_ACK状态。</li><li>客户端对终止报文段进行确认。客户端进入TIME_WAIT状态，等待30秒进入CLOSED状态。接受到报文后服务器进入CLOSED状态。</li></ol><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/tcp%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png" alt=""></p><p>当主机接收到TCP报文段与进行中的进程都不匹配的情况时，发送重置报文段。当主机发送一个重置报文段时，他告诉该源“我没有那个报文段的套接字，请不要发送该报文段了”。<br>当UDP套接字不匹配时，主机发送特殊的ICMP数据报。</p><p>在连接建立的时候，通信双方需要确认最大报文长度。一般这个SYN是MTU减去IP和TCP的首部长度，对于以太网一般可以达到1460字节，非本地IP只有536字节，中间传输的MSS更小的话这个值更小。</p><p>2MSL（Maximum Segment Lifetime）状态: 在图中有一个TIME_WAIT等待状态，这个状态又叫2MSL状态在 发送了最后一个ACK数据报以后，要进入TIME_WAIT状态，这个状态是防止最后一次握手的数据报没有传到对方那里而准备的，态保证了双方都可以正常结束。当一个连接处于2MSL状态时，任何延迟到达的报文段都将被丢弃。当TCP处于2MSL状态时，通信双方将该连接定义为不可重新使用。</p><p>这对于客户端无所谓，但是服务程序（httpd）总要用一个端口来服务。而这个2MSL时间内，可能会发生错误重新启动，重新建立连接，这样上一个连接延迟到达的数据会被认为是新连接中的数据。为了避免这个错误，服务器给出了平静时间的概念，虽然可以重新启动服务器，但是要平静的等待一个MSL才能进行下一次连接</p><p>FIN_WAIT_2 半关闭状态，还可以接受数据但不能发送数据。还有一种可能是客户端一直FIN_WAIT_2 服务器一直WAIT_CLOSE,直到应用层来决定关闭这个状态。</p><p>RST 重置连接(连接取消，经常是因为错误)。</p><p>初始序列号会随时间改变，因此没有个连接都拥有不同的初始序列号。初始序列号可被视为一个32位的计数器。该计数器的数值每4微秒加一。防止出现与其他连接的序列号重叠的情况，尤其对于同一连接的两个不同实例。一个TCP报文段只有同时具备连接的4元组与当前活动窗口的序列号，才会在通信过程中被对方认为是正确的。</p><h3 id="TCP超时重传"><a href="#TCP超时重传" class="headerlink" title="TCP超时重传"></a>TCP超时重传</h3><p>异常网络状况下，可能出现以下情况：</p><ol><li>数据顺利到达对端，对端顺利响应ACK</li><li>数据包中途丢失</li><li>数据包顺利到达，但ACK报文中途丢失</li><li>数据包顺利到达，但对端异常未响应ACK或被对端丢弃。</li></ol><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/%E7%BD%91%E7%BB%9C%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5.jpg" alt=""></p><p>出现异常情况时，TCP就会超时重传。TCP每发送一个报文段，就对这个报文段，就对这个报文段设一个计时器，如果确认的时间到了而没有收到确认，就会重传报文段。这就是超时重传。</p><p>客户端一直没有得到ACK报文，客户端会一直重传，影响重传效率的是RTO（Retransmission Timeout）。RTO指发送数据后，传送数据等待ACK的时间。RTO非常重要。</p><ol><li>设长了，重发慢，没有效率</li><li>设短了，重发快，网络拥塞。</li></ol><p>如果底层传输特性已知，则重传相对简单，但是TCP体层完全异构，所以必须适应适应时延差异。</p><p>经典的自适应算法：</p><p><code>$SRTT = \alpha * SRTT + (1 - \alpha) * RTT$</code></p><p><code>$RTO = min(UBOUND, max(LBOUND, \beta * SRTT)$</code></p><p>UBOUND是最大的timeout时间，上限值，LBOUND是最小的timeout<br>时间，下限值。但这样会因为ACK传输导致RTT多义性问题。</p><p>carn算法，忽略重传，不采样重传的RTT，一旦发生重传，就对现有的RTO翻倍。<br>当不发生重传时，才根据上式计算平均往返时间RTT和重传时间。</p><p>处理差错的两种主要方法是差错校正码和数据重传。</p><p>当RTT测量值小于连接地实际值，就可能发生伪重传。在这种情况下，若TCP地等待时间稍长，不必要地重传就可能不发生。</p><h3 id="TCP滑动窗口"><a href="#TCP滑动窗口" class="headerlink" title="TCP滑动窗口"></a>TCP滑动窗口</h3><p>TCP的滑动窗口主要有两个作用：一是提供TCP的可靠性；二是提供TCP的流控特性。同时滑动 窗口机制还体现了TCP面向字节流的设计思路。</p><p>对于TCP会话的的发送方，任何时候器缓存数据可以分为四类:</p><ol><li>已经发送并受到对方的ACK</li><li>已经发送但未收到ACK</li><li>未发送但对方允许发送</li><li>对方不允许发送</li></ol><p>其中，已经发送还未收到ACK和未发生但是对方允许发送的部分称为发送窗口<br><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.jpg" alt=""></p><p>当接收到ACK后续的确认字节时，窗口便会滑动</p><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%BB%91%E5%8A%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg" alt=""></p><p>对于TCP会话的接收方，缓存数据可以分为三类</p><ol><li>已接受</li><li>未接受准备接收</li><li>未准备接收</li></ol><p>其中未接受准备接收称为接收窗口。</p><p>TCP是双工的协议，会话的双方可以同时接收、发送数据。TCP会话双方都各自维护一个发送窗口和接收窗口。滑动窗口实现面向流的可靠性来源于“确认重传机制”，TCP滑动窗口的可靠性也来源与确认重传。发送窗口只有受到对方对于本段ACK的确认，才会移动左边界。前面还有字节未接收的情况下，窗口不会移动。</p><h4 id="延时确认"><a href="#延时确认" class="headerlink" title="延时确认"></a>延时确认</h4><p>在许多情况下，TCP并不对每个到来的数据包都反回ACK，利用TCP的累积ACK字段就能实现该功能。累积确认可以允许TCP延迟一段时间发送ACK，以便将ACK和相同方向上需要传的数据结合发送。这种捎带传输的方法经常用于批量数据传输。</p><h4 id="Nagle算法"><a href="#Nagle算法" class="headerlink" title="Nagle算法"></a>Nagle算法</h4><p>当一个TCP连接中有在传数据（已发送还未经确认的数据）时，小的报文段（长度小于SMSS）就不能被发送，直到所有的在传数据都收到ACK。在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送。</p><h4 id="零窗口与TCP持续计时器"><a href="#零窗口与TCP持续计时器" class="headerlink" title="零窗口与TCP持续计时器"></a>零窗口与TCP持续计时器</h4><p>TCP通过接受端的通告窗口来实现流量控制。通告窗口指示了接受端可接受的数据量。当窗口值变为0时，可以阻止发送端继续发送，直到窗口大小恢复非零值。</p><p>当接收端重新获得可用空间时，会给发送端传输一个<strong>窗口更新</strong>，告知其可以继续发送数据。这样的窗口更新不包含数据，且没有可靠性，如果丢失，双方就一直处于等待状态。</p><p>为防止这种死锁发生，发送方会采用一个<strong>持续计时器</strong>间歇性地查询接收端，看其窗口是否增长。持续计时器会触发<strong>窗口探测</strong>地传输，强制要求接受端返回ACK（包含窗口大小）。</p><h4 id="糊涂窗口综合征"><a href="#糊涂窗口综合征" class="headerlink" title="糊涂窗口综合征"></a>糊涂窗口综合征</h4><p>通告窗口较小时，发送端会立即发送数据填满该窗口，这样在连接中就会出现大量高耗费地小数据包。对发送端来说，通告窗口较小应该避免发送小数据包；接受端应该尽量避免通告小窗口。</p><h3 id="TCP拥塞控制"><a href="#TCP拥塞控制" class="headerlink" title="TCP拥塞控制"></a>TCP拥塞控制</h3><p>计算机网络中的带宽、交换节点中的缓存和处理机等都是网络的资源。某段时间，网络需求超过了可用部分，网络性能就会变坏，这被称为拥塞。拥塞控制就是防止过多的网络流量注入到网络中。TCP拥塞控制由四个核心算法组成：满开始、拥塞避免、快速重传和快速恢复。</p><h4 id="慢开始和拥塞避免"><a href="#慢开始和拥塞避免" class="headerlink" title="慢开始和拥塞避免"></a>慢开始和拥塞避免</h4><p>发送发维持一个拥塞窗口的状态变量，拥塞窗口取决于网络的拥塞程度。发送方让自己的发送窗口等于拥塞窗口。考虑到接收方的接受能力，发送窗口可能小于拥塞窗口</p><p>慢开始的思路就是一开始不发送大量的数据，先探测网络的拥塞程度。由小到大增加拥塞窗口。</p><ol><li>当主机发送数据时，如果将较大的发送窗口全部注入到网络中，可能引起拥塞</li><li>可以试探一下，由小到大增大拥塞窗口的数量</li><li>慢开始从1个MSS开始指数增长，为了防止其增长过大，设置一个门限ssthresh，当其达到门限时，变为拥塞避免算法。</li></ol><p>拥塞避免算法是使拥塞窗口缓慢增长，每经过一个RTT就将拥塞窗口加一。</p><ol><li>TCP连接初始化，拥塞窗口为1</li><li>执行慢开始算法，cwind指数增长，指导cwind=ssthresh时，开始拥塞避免算法</li><li>当网络拥塞时（超时的丢包事件）将ssthresh设为当前的一半，cwind设为1重新开始。</li></ol><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/TCP%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3.png" alt=""></p><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/TCP%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><h4 id="快重传和快恢复"><a href="#快重传和快恢复" class="headerlink" title="快重传和快恢复"></a>快重传和快恢复</h4><p>快重传要求接收方受到一个失序的报文段后立即发送重复确认（为使发送方尽早知道报文段为传到对方）。快重传规定只要一连收到3个重复确认就立即重传对方尚未收到的报文段，而不必继续等待。</p><p>快重传还配合有快恢复，主要思想包括：</p><ol><li>一旦受到三个重复确认，执行乘法减小，ssthresh门限减半，但是并不执行慢开始</li><li>将cwind设为ssthresh，执行拥塞避免算法。</li></ol><p>整体上，TCP拥塞窗口的原则时加法增大、乘法减小。可以看出TCP较好的保证了流之间的公平性，一旦丢包就减半退让。</p><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/TCP%E5%BF%AB%E9%87%8D%E4%BC%A0%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt=""></p><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/TCP%E5%BF%AB%E9%87%8D%E4%BC%A0%E8%BD%AC%E5%85%A5%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png" alt=""></p><p>ACK号与接收端缓存中的其他数据之间的间隔称为空缺。序列号高于空缺的数据称为失序数据，因为这些数据和之前接收的序列号不连续。合理采用SACK信息能更快地实现空缺填补，且能减少不必要地重传。</p><h4 id="为什么进行三次握手"><a href="#为什么进行三次握手" class="headerlink" title="为什么进行三次握手"></a>为什么进行三次握手</h4><p>本质上TCP协议的三次握手需要解决一个这样的问题：在不可靠的信道上（IP数据报尽最大努力交付）完成可靠的数据传输。而全双工的连接建立需要双方的连接请求和确认，这样最小需要三次握手才能建立连接。</p><p>至于为什么三次是最少，客户端服务器最少都需要向对方发送一个同步报文（SYN），但是如果只有这两次握手，服务器就只能接收连接，无法确认连接；设想如果服务器接收一个SYN报文就建立连接，那客户端因为阻塞原因重发了N个SYN同步报文，服务器每接收到一个就需要建立一次连接，这是不堪设想的。所以只有当服务器接收到客户端的第二次ack确认报文后才会建立连接。</p><h4 id="为什么进行四次挥手"><a href="#为什么进行四次挥手" class="headerlink" title="为什么进行四次挥手"></a>为什么进行四次挥手</h4><p>TCP是全双工的协议，通信中双方都需要知道对方的存在，而在结束时，双方也同时需要发送断开于确认对方断开的信息。当主机1发送FIN希望断开连接时，主机1已经没有要发送的数据了，但是其还是有可能接收主机2发送的数据，此时单方面的连接断开了，这是处于半连接状态。而只有主机2也向主机1发送断开请求并确认，双方才完全的断开。</p><h4 id="TCP的半打开状态"><a href="#TCP的半打开状态" class="headerlink" title="TCP的半打开状态"></a>TCP的半打开状态</h4><p>如果TCP连接中一方已经关闭或异常终止另一方还不知道，这样的连接称为半打开状态。任何一端的主机都可能检测到这一情况，如果双方没有在半打开的连接上传输数据，双发就无法获悉异常。</p><p>半打开的一个常见原因时一方程序的非正常结束（断电、断网），如果A已经没有向B发送的数据，则B永远无法获悉A是否已经消失了，而当一方获取到异常的数据连接后（比如重启）直接进行复位（RST）处理。</p><h4 id="同时打开与同时关闭"><a href="#同时打开与同时关闭" class="headerlink" title="同时打开与同时关闭"></a>同时打开与同时关闭</h4><p>两个程序的同时打开与同时关闭是有可能的，例如A:port1 向B:port2发送SYN同步信息的同时，B:port2也向A:port1发送了一个SYN同步信息，此时双发收到对方的SYN后各自向对方回一个ack表示，确认，连接就正常建立了，这样一个打开需要四个报文段。</p><p>而同时关闭同理，也是双方同时发送FIN报文段，双方在ack确认，这样还是使用4个报文段双方完成了连接的关闭只不过此时双方都跳过了FINWAIT2阶段</p><h4 id="大量的Time-wait怎么办"><a href="#大量的Time-wait怎么办" class="headerlink" title="大量的Time-wait怎么办"></a>大量的Time-wait怎么办</h4><p>Time-wait 状态不能消除，只能快速的回收或重用</p><p>reuse 处于Time-wait状态可以被后续连接重用</p><p>recycle 开启服务器对于time-wait的快速回收</p><p>time-out 修改系统默认的TIMEOUT时间</p><h4 id="重置报文段-RST字段"><a href="#重置报文段-RST字段" class="headerlink" title="重置报文段 RST字段"></a>重置报文段 RST字段</h4><ol><li>针对不存在端口的连接请求</li><li>终止一条连接：重置报文段会被立即发送，任何排队的数据都将被抛弃；接收方会说明通信另一端采用了终止的方式而不是一次正常关闭。</li><li>半开连接：服务器主机被切断连接重启后，留给客户端一个半开的连接。当再次从这条连接上接收到数据时，服务器对其一无所知，并回复一个重置报文段关闭连接。</li><li>一个重置报文段能破坏TIME_WAIT状态并强制连接关闭。</li></ol><h4 id="TCP保活机制"><a href="#TCP保活机制" class="headerlink" title="TCP保活机制"></a>TCP保活机制</h4><p>若某个连接长时间处于空闲状态，在该连接地一端会发送一个探测数据包（可以不含任何数据，但一般会包含垃圾字节）从而实现保活功能。</p><ol><li>对方主机正在工作且可以到达。正常响应，保活计时器重置</li><li>对方主机崩溃。没有响应，请求段会保活时间间隔指定地时间后超时断开连接。</li><li>对方主机崩溃已重启。重置报文段，断开连接</li><li>对方主机正在工作但无法到达。同2</li></ol><h4 id="TCP-连接的本质是什么，真的是“链接”吗"><a href="#TCP-连接的本质是什么，真的是“链接”吗" class="headerlink" title="TCP 连接的本质是什么，真的是“链接”吗"></a>TCP 连接的本质是什么，真的是“链接”吗</h4><p>状态和序列号，以及错误校验（可以查看TCP和UDP的请求头，就会发现两者之间的差距了），其实所谓的TCP三次握手请求连接，无非就是初始化一个序列号，保证后面的数据有序到达，同时TCP还支持重传，错误校验，保证数据的可靠性，当然UDP也提供校验。</p><ul><li><p>建立连接（标志位）：通信前确认通信实体存在。</p></li><li><p>序号机制（序号、确认号）：确保了数据是按序、完整到达。</p></li><li><p>数据校验（校验和）：CRC校验全部数据。</p></li><li><p>超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。</p></li><li><p>窗口机制（窗口）：提供流量控制，避免过量发送。</p></li><li><p>拥塞控制：同上。</p></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;网络层提供了主机之间的逻辑通信，运输层协议为不同主机上的应用进程之间提供了逻辑通信。通过逻辑通信，运行不同进程的主机好像直相连一样。&lt;/p&gt;</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（二）应用层</title>
    <link href="http://yoursite.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BA%94%E7%94%A8%E5%B1%82/"/>
    <id>http://yoursite.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%BA%8C%EF%BC%89%E5%BA%94%E7%94%A8%E5%B1%82/</id>
    <published>2020-10-29T12:15:42.000Z</published>
    <updated>2020-10-29T12:38:37.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="应用层协议原理"><a href="#应用层协议原理" class="headerlink" title="应用层协议原理"></a>应用层协议原理</h2><h3 id="网络应用程序体系结构"><a href="#网络应用程序体系结构" class="headerlink" title="网络应用程序体系结构"></a>网络应用程序体系结构</h3><h4 id="1-客户-服务器体系结构"><a href="#1-客户-服务器体系结构" class="headerlink" title="1.   客户-服务器体系结构"></a>1.   客户-服务器体系结构</h4><pre><code>会出现一台单独的服务器跟不上所有客户请求的情况，需要配备大量主机的数据中心</code></pre><h4 id="2-P2P体系结构"><a href="#2-P2P体系结构" class="headerlink" title="2.   P2P体系结构"></a>2.   P2P体系结构</h4><pre><code>应用程序在间断连接的主机对之间直接通信，对等方。有自扩展性。未来P2P应用由于高度非集中式结构，面临安全性、性能和可靠性挑战。</code></pre><h3 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h3><p>进行通信的实际上是<strong>进程</strong>，而不是程序。</p><p>在两个不同端系统上的进程，通过跨越计算机网络交换报文（message）而通信。</p><h4 id="客户和服务器进程"><a href="#客户和服务器进程" class="headerlink" title="客户和服务器进程"></a>客户和服务器进程</h4><h4 id="进程与计算机网络之间的接口"><a href="#进程与计算机网络之间的接口" class="headerlink" title="进程与计算机网络之间的接口"></a>进程与计算机网络之间的接口</h4><pre><code>进程通过叫**套接字**的软件接口向网络发送和接受报文。套接字也称为应用程序编程接口（Application Programming Interface，API）</code></pre><h4 id="进程寻址"><a href="#进程寻址" class="headerlink" title="进程寻址"></a>进程寻址</h4><pre><code>1.  主机的地址（IP地址）2.  目的主机中接受指定接受进程的标识符（端口号）。</code></pre><h3 id="可供应用程序使用的运输服务"><a href="#可供应用程序使用的运输服务" class="headerlink" title="可供应用程序使用的运输服务"></a>可供应用程序使用的运输服务</h3><pre><code>1. 可靠数据传输2.  吞吐量3. 定时4. 安全性</code></pre><h3 id="因特网提供的运输服务"><a href="#因特网提供的运输服务" class="headerlink" title="因特网提供的运输服务"></a>因特网提供的运输服务</h3><pre><code>1. TCP服务2. UDP服务3. 因特网运输协议所不提供的服务    Tcp可以提供可靠的端到端数据传送，并且可以通过SSL加强以提供安全服务。但是吞吐量和定时服务没有被提供。</code></pre><h3 id="应用层协议"><a href="#应用层协议" class="headerlink" title="应用层协议"></a>应用层协议</h3><h2 id="Web和HTTP"><a href="#Web和HTTP" class="headerlink" title="Web和HTTP"></a>Web和HTTP</h2><h3 id="HTTP概况"><a href="#HTTP概况" class="headerlink" title="HTTP概况"></a>HTTP概况</h3><p>超文本传输协议（HyperText Transfer Protocol） HTTP</p><p>统一资源定位符（Uniform Resource Locator） URL(网页地址)</p><p>统一资源标识符（Uniform Resource Identifier） URI（由某个协议方案标识的资源的定位标识符）</p><p>HTTP使用TCP作为它的支撑运输协议。HTTP协议不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节。这是分层体系结构的最大优点。</p><p>服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息，所以HTTP是一个无状态协议（stateless protocol）</p><h3 id="非持续连接和持续连接"><a href="#非持续连接和持续连接" class="headerlink" title="非持续连接和持续连接"></a>非持续连接和持续连接</h3><ul><li><p>非持续连接<br>  每个请求/响应对是经过一个<strong>单独</strong>的TCP连接发送</p><p>  缺点：</p><ol><li>必须为每个请求的对象建立和维护一个全新的连接。对每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量。</li><li>每一个对象经受两倍RTT的交付时间，一个RTT用于建立TCP，另一个RTT用于请求和接受一个对象。</li></ol></li><li><p>持续连接<br>  每个请求/响应对是经过一个<strong>相同</strong>的TCP连接发送</p><p>  对对象的请求可以一个接一个的发出，而不必等待对未决请求的回答。</p></li><li><p>HTTP/1.1 中默认保持持久连接，但是1.0版本的HTTP需要设置 connection:keep-live</p></li></ul><h3 id="HTTP报文格式"><a href="#HTTP报文格式" class="headerlink" title="HTTP报文格式"></a>HTTP报文格式</h3><h4 id="HTTP请求报文"><a href="#HTTP请求报文" class="headerlink" title="HTTP请求报文"></a>HTTP请求报文</h4><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png" alt="HTTP请求报文"></p><p>包括请求行、首部行、空行、实体体</p><p>HTTP请求报文的第一行叫请求行， 有3个字段：方法字段、URL字段、HTTP版本字段。</p><p>使用GET方法是实体体为空，使用POST方法时才使用实体体。</p><p>CR（Carriage Return） 回车符<br>LF（Line Feed） 换行符</p><h4 id="HTTP响应报文"><a href="#HTTP响应报文" class="headerlink" title="HTTP响应报文"></a>HTTP响应报文</h4><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png" alt="HTTP响应报文"></p><p>包括状态行、首部行、空行、实体体</p><p>HTTP响应报文的第一行叫状态行，有3个字段： 协议版本字段、状态码字段、相应状态信息。</p><p>实体体部分时报文的主要部分，它包含了所请求的对象。</p><h4 id="请求方法"><a href="#请求方法" class="headerlink" title="请求方法"></a>请求方法</h4><p>HTTP/1.1 协议中定了 9 种方法来表明Request-URL指定资源的不同的操作方式</p><ol><li>OPTIONS 询问支持的方法。返回服务器针对特定资源的HTTP请求方法</li><li>HEAD 获得报文首部。向服务器索要与GET请求一致的响应，而响应体不会被返回</li><li>GET 获取资源。  向特定资源发出请求（GET可能会被爬虫随意访问）</li><li>POST 传输实体主体。 向指定资源提交数据处理的请求（提交表单、上传文件）数据被包含在请求体中。POST可能会导致新建资源或已有资源的修改</li><li>PUT 传输文件。 自身不带验证机制，存在安全性问题。向指定资源上传最新内容</li><li>DELETE 删除文件。与PUT一样，存在安全性问题。请求服务器删除 REQUEST_URL 所标识的资源</li><li>TRACE 追踪路径。回显服务器收到的请求</li><li>CONNECT 在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容加密后将网络隧道传输。</li><li>PATCH 局部修改某一资源</li></ol><p>当请求的资源不支持请求方法时，服务器返回405（Method Nnt Allowed）</p><p>当服务器不认识或不支持方法时，返回501（Not Implement）</p><h5 id="GET-与-POST的区别"><a href="#GET-与-POST的区别" class="headerlink" title="GET 与 POST的区别"></a>GET 与 POST的区别</h5><p><strong>作用</strong> GET用于获取资源，POST用于传输实体主体</p><p><strong>参数</strong>  GET 和POST 都能使用额外的参数，但是GET的参数以查询字符串的方式出现在URL中，这个过程用户可见。而POST的参数存储在实体主体中。因为URL只支持ASCII码，因此GET参数中文会被编码，空格被编码为%20</p><p><strong>安全</strong> 安全的HTTP方法不会改变服务器状态，可以说是只读的</p><p>GET方法安全，POST不是，POST方法传出主题内容，可能是表单数据，服务器可能把其存进数据库中，这样状态就发生了改变。</p><p><strong>幂等性</strong> 幂等性的方法，同样的请求被执行一次和连续执行多次的效果是一样的，服务器状态也是一样的。</p><p>所有安全的方法是幂等的，GET、HEAD、PUT、DELETE应该是幂等的。<br>而post方法不是幂等的。</p><p><strong>其他</strong> GET传输数据量小，因为受URL的限制，但是效率高；POST可以传输大量数据，文件只能通过POST传递。</p><p>GET方式只支持ASCII字符，向服务器传输的中文字符可能乱码。post支持标准字符集，可以正确的传递中文字符。</p><h4 id="首部行"><a href="#首部行" class="headerlink" title="首部行"></a>首部行</h4><h5 id="HTTP首部Request"><a href="#HTTP首部Request" class="headerlink" title="HTTP首部Request"></a>HTTP首部Request</h5><table><thead><tr><th align="center">Header</th><th align="center">解释</th><th align="center">某度首页示例</th></tr></thead><tbody><tr><td align="center">Accept</td><td align="center">客户端能够接受的内容类型</td><td align="center">text/html</td></tr><tr><td align="center">Accept-Encoding</td><td align="center">浏览器可以支持的web服务器返回内容压缩编码类型</td><td align="center">gzip</td></tr><tr><td align="center">Accept-Language</td><td align="center">浏览器可以接受的语言</td><td align="center">zh-CN</td></tr><tr><td align="center">Cache-Control</td><td align="center">指定请求和相应遵循的缓存机制</td><td align="center">max-age=0</td></tr><tr><td align="center">Connection</td><td align="center">表示是否需要持久连接</td><td align="center">keep-alive</td></tr><tr><td align="center">Cookie    HTTP</td><td align="center">请求发送时，会把保存在请求域名下的所有cookie值一起发送给web服务器</td><td align="center">键值对</td></tr><tr><td align="center">Host</td><td align="center">请求服务器的域名和端口号</td><td align="center"><a href="http://www.baidu.com">www.baidu.com</a></td></tr><tr><td align="center">Upgrade-Insecure-Requests</td><td align="center">浏览器可以处理HTTPS协议</td><td align="center">1</td></tr><tr><td align="center">User-Agent</td><td align="center">发出请求的用户信息</td><td align="center">Mozilla/5.0</td></tr></tbody></table><h5 id="HTTP首部Response"><a href="#HTTP首部Response" class="headerlink" title="HTTP首部Response"></a>HTTP首部Response</h5><table><thead><tr><th align="center">Header</th><th align="center">解释</th><th align="center">某度首页示例</th></tr></thead><tbody><tr><td align="center">Cache-Control</td><td align="center">告诉所有的缓存机制是否可以缓存及缓存哪种类型</td><td align="center">private</td></tr><tr><td align="center">Connection</td><td align="center">是否保持持久连接</td><td align="center">keep-alive</td></tr><tr><td align="center">Content-Encoding</td><td align="center">返回内容压缩编码类型</td><td align="center">gzip</td></tr><tr><td align="center">Content-type</td><td align="center">返回内容的MIME类型</td><td align="center">text/html charset=utf-8</td></tr><tr><td align="center">Date</td><td align="center">原始服务器消息发出时间</td><td align="center">Wed 03 Oct2018 12:04:45 GMT</td></tr><tr><td align="center">Expires</td><td align="center">响应过期的时间</td><td align="center">Wed 03 Oct2018 12:04:45 GMT</td></tr><tr><td align="center">Server    Web</td><td align="center">服务器软件名称</td><td align="center">BWS1.1</td></tr><tr><td align="center">Set-Cookie</td><td align="center">设置浏览器缓存</td><td align="center">BDSVRTM=114; path=/</td></tr><tr><td align="center">Transfer-Encoding</td><td align="center">文件传输编码</td><td align="center">chunked</td></tr></tbody></table><h4 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h4><p>状态码的类别<br> <img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/%E7%8A%B6%E6%80%81%E7%A0%81%E7%9A%84%E7%B1%BB%E5%88%AB.jpg" alt=""></p><h5 id="100-Containue：收到了请求的初始部分，请客户端继续"><a href="#100-Containue：收到了请求的初始部分，请客户端继续" class="headerlink" title="100 Containue：收到了请求的初始部分，请客户端继续"></a>100 Containue：收到了请求的初始部分，请客户端继续</h5><h5 id="200-Ok-请求被正常处理"><a href="#200-Ok-请求被正常处理" class="headerlink" title="200 Ok: 请求被正常处理"></a>200 Ok: 请求被正常处理</h5><h5 id="204-No-Content：-请求被接受，但是响应报文只有状态行和首部行，不含实体体。"><a href="#204-No-Content：-请求被接受，但是响应报文只有状态行和首部行，不含实体体。" class="headerlink" title="204 No Content： 请求被接受，但是响应报文只有状态行和首部行，不含实体体。"></a>204 No Content： 请求被接受，但是响应报文只有状态行和首部行，不含实体体。</h5><h5 id="206-Partial-Content-客户端进行了范围请求，服务器成功执行了这部分的GET请求"><a href="#206-Partial-Content-客户端进行了范围请求，服务器成功执行了这部分的GET请求" class="headerlink" title="206 Partial Content:客户端进行了范围请求，服务器成功执行了这部分的GET请求"></a>206 Partial Content:客户端进行了范围请求，服务器成功执行了这部分的GET请求</h5><h5 id="301-Moved-Permanently-永久重定向"><a href="#301-Moved-Permanently-永久重定向" class="headerlink" title="301 Moved Permanently 永久重定向"></a>301 Moved Permanently 永久重定向</h5><h5 id="302-Found-临时重定向，资源被临时移动了。"><a href="#302-Found-临时重定向，资源被临时移动了。" class="headerlink" title="302 Found 临时重定向，资源被临时移动了。"></a>302 Found 临时重定向，资源被临时移动了。</h5><h5 id="303-See-Other-表示请求对应的资源代表另一个URI，应该使用GET获取资源"><a href="#303-See-Other-表示请求对应的资源代表另一个URI，应该使用GET获取资源" class="headerlink" title="303 See Other 表示请求对应的资源代表另一个URI，应该使用GET获取资源"></a>303 See Other 表示请求对应的资源代表另一个URI，应该使用GET获取资源</h5><h5 id="304-Not-Modified-当客户端发送附带请求时，服务器找到资源但未符合请求（与重定向无关）"><a href="#304-Not-Modified-当客户端发送附带请求时，服务器找到资源但未符合请求（与重定向无关）" class="headerlink" title="304 Not Modified 当客户端发送附带请求时，服务器找到资源但未符合请求（与重定向无关）"></a>304 Not Modified 当客户端发送附带请求时，服务器找到资源但未符合请求（与重定向无关）</h5><h5 id="307-Temporary-Redirect-临时重定向，与302相同。但是301，302不许将POST改为GET，大家并不遵守。307不会从POST变为GET。"><a href="#307-Temporary-Redirect-临时重定向，与302相同。但是301，302不许将POST改为GET，大家并不遵守。307不会从POST变为GET。" class="headerlink" title="307 Temporary Redirect 临时重定向，与302相同。但是301，302不许将POST改为GET，大家并不遵守。307不会从POST变为GET。"></a>307 Temporary Redirect 临时重定向，与302相同。但是301，302不许将POST改为GET，大家并不遵守。307不会从POST变为GET。</h5><h5 id="400-Bad-Request-请求报文中存在语法错误。"><a href="#400-Bad-Request-请求报文中存在语法错误。" class="headerlink" title="400 Bad Request 请求报文中存在语法错误。"></a>400 Bad Request 请求报文中存在语法错误。</h5><h5 id="401-Unauthorized-请求需要进行认证"><a href="#401-Unauthorized-请求需要进行认证" class="headerlink" title="401 Unauthorized 请求需要进行认证"></a>401 Unauthorized 请求需要进行认证</h5><h5 id="403-Forbidden-请求被服务器拒绝"><a href="#403-Forbidden-请求被服务器拒绝" class="headerlink" title="403 Forbidden 请求被服务器拒绝"></a>403 Forbidden 请求被服务器拒绝</h5><h5 id="404-Not-Found-服务器无法找到对应资源"><a href="#404-Not-Found-服务器无法找到对应资源" class="headerlink" title="404 Not Found 服务器无法找到对应资源"></a>404 Not Found 服务器无法找到对应资源</h5><h5 id="405-Method-Not-Allowed-请求中带有不支持的方法"><a href="#405-Method-Not-Allowed-请求中带有不支持的方法" class="headerlink" title="405 Method Not Allowed 请求中带有不支持的方法"></a>405 Method Not Allowed 请求中带有不支持的方法</h5><h5 id="500-Internet-Server-Error-服务器内部错误"><a href="#500-Internet-Server-Error-服务器内部错误" class="headerlink" title="500 Internet Server Error 服务器内部错误"></a>500 Internet Server Error 服务器内部错误</h5><h5 id="501-Not-Implemented-服务器不认识或不支持对应的请求方法"><a href="#501-Not-Implemented-服务器不认识或不支持对应的请求方法" class="headerlink" title="501 Not Implemented 服务器不认识或不支持对应的请求方法"></a>501 Not Implemented 服务器不认识或不支持对应的请求方法</h5><h5 id="502-Bad-GateWay-代理或网关服务器从下一条链路收到了伪响应"><a href="#502-Bad-GateWay-代理或网关服务器从下一条链路收到了伪响应" class="headerlink" title="502 Bad GateWay 代理或网关服务器从下一条链路收到了伪响应"></a>502 Bad GateWay 代理或网关服务器从下一条链路收到了伪响应</h5><h5 id="503-Server-Unavailable-服务器正忙"><a href="#503-Server-Unavailable-服务器正忙" class="headerlink" title="503 Server Unavailable 服务器正忙"></a>503 Server Unavailable 服务器正忙</h5><h5 id="504-GateWay-Timeout-一个代理网关等待另一服务器超时了"><a href="#504-GateWay-Timeout-一个代理网关等待另一服务器超时了" class="headerlink" title="504 GateWay Timeout 一个代理网关等待另一服务器超时了"></a>504 GateWay Timeout 一个代理网关等待另一服务器超时了</h5><h3 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h3><p>HTTP服务器时无状态的，但是一个Web站点通常希望能够识别用户，（限制访问、用户身份）为此使用cookie技术。</p><p>网络服务器用HTTP头向客户端发送cookies, 在客户终端，浏览器解析这些cookies 并将它们保存为一个本地文件，它们在会在下一次对服务器的请求时附上这些cookies。</p><p>cookie技术的4个组件：</p><ol><li>HTTP响应报文中的cookie首部行</li><li>HTTP请求报文中的cookie首部行</li><li>用户端系统中保留有一个cookie文件，由浏览器进行管理。</li><li>位于Web站点的后端数据库</li></ol><p>过期时间：</p><ul><li>会话cookie： 若不设置过期时间，表示这个cookie的生命周期未浏览器会话期间，若关闭浏览器，cookie就会消失。这种生命周期的cookie被称为会话cookie</li><li>持久cookie： 若设置了过期时间，浏览器会把cookie存储到硬盘上（可以拒绝），关闭后在打开这些cookie仍然有效</li></ul><h3 id="session"><a href="#session" class="headerlink" title="session"></a>session</h3><p>session机制是一种服务端的机制，服务器利用一种类似于散列表的结构来保存信息</p><p>当程序需要为某个客户端的请求创建session时，服务器检查这个客户端是否包含了一个session标志，称为session_id, 如果检测到说明该客户曾创建过ID，服务器会把这个ID检索出来使用（或者未检测到新建一个），session_id 既不会重复也不容易被找到仿造。</p><h4 id="session-id的存储"><a href="#session-id的存储" class="headerlink" title="session_id的存储"></a>session_id的存储</h4><ol><li>保存这个session_id可以采用cookie，这样交互过程中浏览器可以把这个标志返回给服务器。一般该变量名与session有关，如github的session ID即名为user_session</li><li>由于cookie可以被人为的禁止，必须有其他机制保证session_id传回服务器，经常使用的一种方法是URL重写，即直接把session_ID附在URL后面。作为路径的附加信息或查询字符</li><li>另一种技术是表单隐藏字段，服务器自动修改表单加入一个隐藏字段，便于传回session_id</li></ol><h3 id="cookie与session的区别"><a href="#cookie与session的区别" class="headerlink" title="cookie与session的区别"></a>cookie与session的区别</h3><ul><li><h4 id="存取方式不同"><a href="#存取方式不同" class="headerlink" title="存取方式不同"></a>存取方式不同</h4><p>  cookie只能保存ASCII字符，Unicode和二进制数据需要编码，cookie不能直接存取java对象，存储略微复杂的信息较难。<br>  而session中能够存取任何类型的数据，十分方便。</p></li><li><h4 id="隐私策略不同"><a href="#隐私策略不同" class="headerlink" title="隐私策略不同"></a>隐私策略不同</h4><p>  cookie存储在客户端浏览器中，对客户可见，客户端可以窥探甚至修改cookie内容。<br>  session存储在服务器上，对用户透明，不存在泄漏风险。<br>  cookie可以像google及百度一样将敏感信息加密后保存，在服务器上进行解密。</p></li><li><h4 id="有效时间不同"><a href="#有效时间不同" class="headerlink" title="有效时间不同"></a>有效时间不同</h4><p>  由于session依赖于session_ID的cookie，而session_id的过期时间默认为-1，关闭浏览器即消失。而cookie可以设置长期的保存。</p></li><li><h4 id="服务器压力不同"><a href="#服务器压力不同" class="headerlink" title="服务器压力不同"></a>服务器压力不同</h4><p>  由于不从的存储方式，存储在客户点的cookie不会给服务器造成压力，而session由于存在服务器上，对服务器压力较大。</p></li><li><h4 id="浏览器支持不同"><a href="#浏览器支持不同" class="headerlink" title="浏览器支持不同"></a>浏览器支持不同</h4><p>  cookie需要客户端浏览器的支持，假如客户端禁用或不支持cookie，则会话跟踪会失效<br>  假如客户端不支持cookie，就需要运用session及URL地址重写。注意，所有用到session的程序url都要进行重写，否则session会话会失效</p></li><li><h4 id="跨域支持不同"><a href="#跨域支持不同" class="headerlink" title="跨域支持不同"></a>跨域支持不同</h4><p>  cookie支持跨域名访问，一切以相同后缀的域名均可以访问该cookie，跨域名cookie被广泛应用<br>  session尽在当前域名有效</p></li></ul><h3 id="Web缓存"><a href="#Web缓存" class="headerlink" title="Web缓存"></a>Web缓存</h3><p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。</p><h3 id="条件GET方法"><a href="#条件GET方法" class="headerlink" title="条件GET方法"></a>条件GET方法</h3><p>条件GET使缓存器证实他的对象是最新的。</p><ol><li>请求报文中使用GET方法</li><li>请求报文中包含”If-Modified-Since”首部行</li></ol><p>304 Not Modified 告诉缓存器可以继续使用该对象</p><h3 id="HTTP和HTTPS的区别"><a href="#HTTP和HTTPS的区别" class="headerlink" title="HTTP和HTTPS的区别"></a>HTTP和HTTPS的区别</h3><ol><li>HTTPS协议需要CA申请证书，需要缴费</li><li>HTTP是超文本传输协议，明文传输，HTTPS是SSL加密传输</li><li>80 和443</li><li>HTTP连接很简单，无状态，HTTPS经过SSL+HTTP协议构建的，加密传输，身份认证</li><li>HTTPS耗性能，安全性要求低用HTTP</li></ol><h3 id="CGI（Common-Gateway-Interface）公共网关接口"><a href="#CGI（Common-Gateway-Interface）公共网关接口" class="headerlink" title="CGI（Common Gateway Interface）公共网关接口"></a>CGI（Common Gateway Interface）公共网关接口</h3><p>CGI 是HTTP 中重要的技术之一，有着不可替代的作用。CGI是一个web服务器的标注接口。通过CGI接口Web服务器就能获取客户端提交的信息转交给服务器端的CGI程序处理，最后结果返回给客户端。</p><p><img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/CGI.png" alt=""></p><p>CGI规范定义了Web服务器如何向扩展应用程序发送消息，在收到扩展应用程序的信息后又如何进行处理等内容。服务器和客户端之间的通信，是浏览器和服务端web服务器的HTTP通信，所以只需知道浏览器执行哪个CGI程序即可.</p><h2 id="因特网中的电子邮件"><a href="#因特网中的电子邮件" class="headerlink" title="因特网中的电子邮件"></a>因特网中的电子邮件</h2><p>因特网电子邮件系统由3个主要组成部分：<strong>用户代理（user-agent)</strong>、<strong>邮件服务器（mail server)</strong>、<strong>简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）</strong></p><h3 id="SMTP"><a href="#SMTP" class="headerlink" title="SMTP"></a>SMTP</h3><p>25号端口、TCP连接、<br>传输的三个阶段： 握手、传输、关闭连接。</p><h3 id="与HTTP的对比"><a href="#与HTTP的对比" class="headerlink" title="与HTTP的对比"></a>与HTTP的对比</h3><p>都是TCP连接，持续的HTTP和SMTP都是持续连接。</p><ol><li>HTTP是一个拉协议，TCP连接由想接受文件的机器发起。SMTP是一个推协议，TCP连接由发送文件的机器发起。</li><li>SMTP要求报文采用7比特ASCII码格式，如果报文包含了非7比特ASCII字符，必须按照7比特ASCII码进行编码。HTTP数据则不受这种限制。</li><li>如何处理一个既包含文本又包含图形的文档。HTTP把每个对象封装到各自的HTTP响应报文中，SMTP则把所有报文对象放在同一个报文之中。</li></ol><h3 id="邮件报文格式"><a href="#邮件报文格式" class="headerlink" title="邮件报文格式"></a>邮件报文格式</h3><p>必须包含From首部行和To首部行。也许Subject首部行</p><h3 id="邮件访问协议"><a href="#邮件访问协议" class="headerlink" title="邮件访问协议"></a>邮件访问协议</h3><p>由于取报文是一个拉操作，而SMTP是一个退协议。所以有邮件访问协议</p><h4 id="第三版邮局协议（Post-Office-Protocol-Version3，POP3）"><a href="#第三版邮局协议（Post-Office-Protocol-Version3，POP3）" class="headerlink" title="第三版邮局协议（Post Office Protocol-Version3，POP3）"></a>第三版邮局协议（Post Office Protocol-Version3，POP3）</h4><h4 id="因特网邮件访问协议（Internet-Mail-Access-Protocol，-IMAP）"><a href="#因特网邮件访问协议（Internet-Mail-Access-Protocol，-IMAP）" class="headerlink" title="因特网邮件访问协议（Internet Mail Access Protocol， IMAP）"></a>因特网邮件访问协议（Internet Mail Access Protocol， IMAP）</h4><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><h2 id="FTP-文件传输协议"><a href="#FTP-文件传输协议" class="headerlink" title="FTP 文件传输协议"></a>FTP 文件传输协议</h2><p>FTP使用两个并行的TCP连接来传输数据，一个TCP（21号端口）被称为控制连接，用来传输FTP命令；一个TCP（20号端口）连接称为数据连接用于传输文件数据。</p><p>因为在FTP协议内，控制信息是通过一个独立的TCP连接传输，所以我们称FTP的控制信息是<strong>带外传送</strong>的，如果控制信息和数据信息通过同一个TCP传输，则称为带内传送</p><p>FTP中控制连接贯穿整个会话，但是数据连接在一个文件开始传输时建立，传输结束后关闭，所以每次传输一个新文件时，都会建立一个数据连接。</p><p>FTP需要在整个会话期间，保留用户的状态，也就是将控制连接同用户账户关联起来，同时记录在远程目录树上的操作，这就限制了FTP可以同时维持的会话总数</p><h2 id="因特网的目录服务：-DNS"><a href="#因特网的目录服务：-DNS" class="headerlink" title="因特网的目录服务： DNS"></a>因特网的目录服务： DNS</h2><h3 id="DNS提供的服务"><a href="#DNS提供的服务" class="headerlink" title="DNS提供的服务"></a>DNS提供的服务</h3><p>主机名到IP地址转换的目录服务。<br>域名系统：（Domain Name System， DNS）</p><p>DNS运行在UDP传输协议之上，使用53号端口</p><p>DNS是：1. 一个由分层的DNS服务器实现的分布式数据库。2.   一个使得主机能够查询分布式数据库的应用层协议。</p><p>DNS采用分布式的设计方案，因为单一的DNS服务器无法解决单点故障，无法保证通信容量以及无法临近所有的查询主机和维护困难等问题。</p><p><strong>根DNS服务器</strong>：因特网上由13个根DNS服务器，每台服务器是一个冗余的计算机网络以*提供安全性和可靠性</p><p><strong>顶级域DNS服务器</strong>：负责顶级域名如com、org、net、edu等以及各个国家顶级域名的转换。</p><p><strong>权威DNS服务器</strong>：因特网上，具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。</p><p><strong>本地DNS服务器</strong>：邻近其所在网络的其他主机。当主机发出DNS请求时，请求被发往本地DNS服务器，起着代理的作用。</p><p><strong>递归查询</strong>：从请求主机到本地DNS服务器的查询是递归的，</p><p><strong>迭代查询</strong>：其余都是迭代的</p><p><strong>DNS缓存</strong>每当DNS服务器发出请求后受到回答时，就将回答的内容缓存在自己的主机空间上。注意有效时间</p><h2 id="P2P文件分发"><a href="#P2P文件分发" class="headerlink" title="P2P文件分发"></a>P2P文件分发</h2><p>p2p体系结构具有良好的自扩展性。这种扩展性的直接成因是对等方除了是比特的消费者之外还是重新分发者。</p><h3 id="BitTorrent"><a href="#BitTorrent" class="headerlink" title="BitTorrent"></a>BitTorrent</h3><p>参与一个特定文件分发的所有对等方的集合被称为一个<strong>洪流</strong></p><p>在一个洪流中的对等方彼此下载等长度的文件<strong>块</strong></p><p>当一个对等方下载文件块的时候，也向其他对等方发送了多个块，一旦某对等方获得了完整文件，就可以自私地离开洪流或者大公无私地留下来继续向其他对等方发送文件。 </p><p>P2P文件共享协议，参与一个特定文件分发的所有对等方结合被称为一个洪流（torrent），在一个洪流的对等方彼此下载等长度的文件块，可以随时离开洪流，也可继续向其他对等方上载。每个洪流都有一个追踪器。</p><p>Alice加入某洪流时，会在追踪器里进行注册，周期性通知追踪器它仍在洪流中。我们称所有与ALICE成功的创建了一个TCP链接的对等方成为邻近对等方。</p><p>洪流随机从参与对等方的结合中选择一个子集，将他们的IP地址发给Alice，Alice维护这张对等方列表，试图与所有对等方建立并行的TCP连接。</p><p>Alice周期询问每个邻近对等方（连上的）他们有的文件块列表，她随时知道邻居有哪些文件块</p><p>Alice使用最稀缺优先技术，首先请求那些邻居们副本数量最少的块，使该文件块迅速分发，以均衡每个块在洪流中的副本数量</p><p>BitTorrent使用一种算法，Alice优先从像她传时速度最快的邻居（4个，每10s修改一次）那里获取文件块。</p><p>每过30s，Alice也要随机选择另外一个对等方Bob，向他发送块。若Alice是Bob最快的前四快，Bob也是Alice的前4快，则Bob和Alice互相发送数据。</p><p>每过30s换一个新的对象，互相交换数据（一报还一报），为了使对等方能够找到彼此协调的速率上传</p><h3 id="分布式散列表（DHT）"><a href="#分布式散列表（DHT）" class="headerlink" title="分布式散列表（DHT）"></a>分布式散列表（DHT）</h3><h2 id="视频流和内容分发网"><a href="#视频流和内容分发网" class="headerlink" title="视频流和内容分发网"></a>视频流和内容分发网</h2><h3 id="经HTTP的动态适应性流（Dynamic-Adaptive-Streaming-over-HTTP，DASH）"><a href="#经HTTP的动态适应性流（Dynamic-Adaptive-Streaming-over-HTTP，DASH）" class="headerlink" title="经HTTP的动态适应性流（Dynamic Adaptive Streaming over HTTP，DASH）"></a>经HTTP的动态适应性流（Dynamic Adaptive Streaming over HTTP，DASH）</h3><p>在DASH中视频编码为几个不同的版本，每个版本具有不同的比特率，对应于不同的质量水平。</p><h3 id="内容分发网（Content-Distribution-Network，CDN-）"><a href="#内容分发网（Content-Distribution-Network，CDN-）" class="headerlink" title="内容分发网（Content Distribution Network，CDN ）"></a>内容分发网（Content Distribution Network，CDN ）</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;应用层协议原理&quot;&gt;&lt;a href=&quot;#应用层协议原理&quot; class=&quot;headerlink&quot; title=&quot;应用层协议原理&quot;&gt;&lt;/a&gt;应用层协议原理&lt;/h2&gt;&lt;h3 id=&quot;网络应用程序体系结构&quot;&gt;&lt;a href=&quot;#网络应用程序体系结构&quot; class=&quot;head</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络（一）计算机网络和互联网</title>
    <link href="http://yoursite.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E4%BA%92%E8%81%94%E7%BD%91/"/>
    <id>http://yoursite.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%EF%BC%88%E4%B8%80%EF%BC%89%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%92%8C%E4%BA%92%E8%81%94%E7%BD%91/</id>
    <published>2020-10-29T12:11:15.000Z</published>
    <updated>2020-10-29T12:38:37.741Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是因特网"><a href="#什么是因特网" class="headerlink" title="什么是因特网"></a>什么是因特网</h2><p>端系统通过通信链路和分组交换机连接到一起。</p><ol><li>构成因特网的基本硬件和软件组件</li><li>为分布式应用提供服务的联网基础设施</li></ol><h3 id="协议"><a href="#协议" class="headerlink" title="协议"></a>协议</h3><p>协议定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送、接受、或其他事件采取的动作</p><h2 id="网络边缘"><a href="#网络边缘" class="headerlink" title="网络边缘"></a>网络边缘</h2><p>主机==端系统 分为客户（client）和服务器（client）</p><h2 id="网络核心"><a href="#网络核心" class="headerlink" title="网络核心"></a>网络核心</h2><h3 id="分组交换"><a href="#分组交换" class="headerlink" title="分组交换"></a>分组交换</h3><ul><li>存储转发传输</li><li>排队时延和分组丢失</li><li>转发表和路由选择协议</li></ul><h3 id="电路交换"><a href="#电路交换" class="headerlink" title="电路交换"></a>电路交换</h3><ul><li>频分复用</li><li>时分复用</li></ul><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>分组交换的缺点： 不适合实时服务，因为它端到端的时延是变动的和不可测的（排队时延）</p><p>分组交换的优点：提供了比电路交换更好的带宽共享；比电路交换更简单、更有效、实现成本低。</p><h2 id="分组交换网中的时延、丢包、和吞吐量"><a href="#分组交换网中的时延、丢包、和吞吐量" class="headerlink" title="分组交换网中的时延、丢包、和吞吐量"></a>分组交换网中的时延、丢包、和吞吐量</h2><ol><li>时延<ol><li>处理时延</li><li>排队时延</li><li>传输时延</li><li>传播时延</li></ol></li><li>排队时延和丢包<ul><li>排队时延：流量强度La/R &lt; 1,</li><li>丢包： 队列已满</li></ul></li><li>端到端时延</li><li>吞吐量</li></ol><h2 id="协议层次及其服务模型"><a href="#协议层次及其服务模型" class="headerlink" title="协议层次及其服务模型"></a>协议层次及其服务模型</h2><h3 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h3><p>将各层的所有协议称为协议栈（protocol stack）</p><ul><li>应用层 确定进程间的通信性质以满足通信需求，应用程序间通信    报文（message）</li><li>传输层 负责主机间不同进程的通信                           报文段（segment）</li><li>网络层 负责不同主机之间的通信                               数据报（datagram）</li><li>链路层  将数据报封装成帧                                   帧（frame）</li><li>物理层   透明的传输bit流                                    bit流</li></ul><p>表示层：处理数据格式、数据加密等，编码方式（图像编解码）</p><p>会话层：建立、维护、管理会话 ， 建立会话（session认证、断电续传）</p><p>四层网络模型<img src="https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/%E5%9B%9B%E5%B1%82%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B.png" alt=""></p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>在每一层中，一个分组具有两种类型的字段：首部字段和有效载荷字段</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是因特网&quot;&gt;&lt;a href=&quot;#什么是因特网&quot; class=&quot;headerlink&quot; title=&quot;什么是因特网&quot;&gt;&lt;/a&gt;什么是因特网&lt;/h2&gt;&lt;p&gt;端系统通过通信链路和分组交换机连接到一起。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;构成因特网的基本硬件和软件组件&lt;/li</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络常用名词</title>
    <link href="http://yoursite.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E7%94%A8%E5%90%8D%E8%AF%8D/"/>
    <id>http://yoursite.com/2020/10/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E7%94%A8%E5%90%8D%E8%AF%8D/</id>
    <published>2020-10-29T12:07:23.000Z</published>
    <updated>2020-10-29T12:38:37.741Z</updated>
    
    <content type="html"><![CDATA[<p>计算机网络 computer network</p><p>主机 host</p><p>端系统 end system</p><p>通信链路 communication link</p><p>分组交换机 packet switch</p><p>传输速率 transmission rate</p><p>路由器 router</p><p>链路层交换机 link-layer switch</p><p>路径 route / path</p><p>因特网服务提供商（Internet Service Provider） ISP</p><p>数字用户线（digital Subscriber line）DSL</p><p>协议 protocol /ˈproʊtəkɑːl/ 协议定义了在两个或多个通信实体之间交换的报文的格式和顺序，以及报文发送或接受一条报文时或其他事件时采取的动作。</p><p>传输控制协议 （transmission control protocol） TCP</p><p>网际协议（Internet Protocol) IP</p><p>分布式应用程序 distributed application</p><p>套接字接口（socket interface） 该接口规定了运行在一个端系统上的程序请求因特网基础设施向运行在另一个端系统上的特定目的地程序交付数据地方式。</p><p>客户  client</p><p>主机 server</p><p>数据中心 data center</p><p>报文 message</p><p>分组 packet</p><p>存储转发传输（store-and-forward transmission） 指在交换机能够开始向输出链路传输该分组的第一个比特之前，必须接收到整个分组。</p><p>缓存 buffer</p><p>分组丢失（丢包） packet loss</p><p>频分复用（Frequency-Division Multiplication） FDM</p><p>时分复用（Time-Division Multiplication） TDM</p><p>往返时间 （Round-Trip Time）RTT</p><p>最大消息长度（Maximum Segment Size）MSS</p><p>最大传送单元（Maximum Transmission Unit） MTU</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;计算机网络 computer network&lt;/p&gt;
&lt;p&gt;主机 host&lt;/p&gt;
&lt;p&gt;端系统 end system&lt;/p&gt;
&lt;p&gt;通信链路 communication link&lt;/p&gt;
&lt;p&gt;分组交换机 packet switch&lt;/p&gt;
&lt;p&gt;传输速率 transmi</summary>
      
    
    
    
    <category term="计算机基础知识" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
    <category term="计算机网络" scheme="http://yoursite.com/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="常用名词" scheme="http://yoursite.com/tags/%E5%B8%B8%E7%94%A8%E5%90%8D%E8%AF%8D/"/>
    
    <category term="计算机网络" scheme="http://yoursite.com/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>buttfly主题</title>
    <link href="http://yoursite.com/2020/10/29/butterfly%E4%B8%BB%E9%A2%98/"/>
    <id>http://yoursite.com/2020/10/29/butterfly%E4%B8%BB%E9%A2%98/</id>
    <published>2020-10-29T08:06:54.000Z</published>
    <updated>2020-10-29T12:38:37.741Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asdf</span><br></pre></td></tr></table></figure><p>$S_a$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla</summary>
      
    
    
    
    <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/03/05/hello-world/"/>
    <id>http://yoursite.com/2020/03/05/hello-world/</id>
    <published>2020-03-05T03:15:45.000Z</published>
    <updated>2020-10-29T12:38:37.741Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
  <entry>
    <title>markdown syntax</title>
    <link href="http://yoursite.com/2020/03/03/markdown-syntax/"/>
    <id>http://yoursite.com/2020/03/03/markdown-syntax/</id>
    <published>2020-03-03T12:17:35.000Z</published>
    <updated>2020-10-29T12:38:37.741Z</updated>
    
    <content type="html"><![CDATA[<p>$A$</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">n1, n2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> a1 = n1.split(<span class="string">&#x27;&#x27;</span>).reverse();</span><br><span class="line">  <span class="keyword">const</span> a2 = n2.split(<span class="string">&#x27;&#x27;</span>).reverse();</span><br><span class="line">  <span class="keyword">const</span> result = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, l = <span class="built_in">Math</span>.max(a1.length, a2.length); i &lt; l; i++) &#123;</span><br><span class="line">    result[i] = (result[i] || <span class="number">0</span>) + <span class="built_in">parseInt</span>(a1[i] || <span class="number">0</span>) + <span class="built_in">parseInt</span>(a2[i] || <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span> (result[i] &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">      result[i] -= <span class="number">10</span>;</span><br><span class="line">      result[i + <span class="number">1</span>] = (result[i + <span class="number">1</span>] || <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result.reverse().join(<span class="string">&#x27;&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><p><strong>加粗</strong><br><em>倾斜</em><br><strong><em>加粗倾斜</em></strong><br><del>加删除线</del></p><blockquote><p>引用的内容（可以嵌套）</p></blockquote><h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><hr><p><img src="http://file.koolearn.com/20161207/14810957953513.png" alt="图片 alt" title="网上随便找的"></p><p><a href="超链接地址" title="超链接title">超链接名</a></p><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ul><li>列表内容</li></ul><ol><li>列表内容</li><li>列表内容</li><li>列表内容</li></ol><table><thead><tr><th>表头</th><th align="center">表头</th><th align="right">表头</th></tr></thead><tbody><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr><tr><td>内容</td><td align="center">内容</td><td align="right">内容</td></tr></tbody></table><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">第二行分割表头和内容</span><br><span class="line">-有一个就行</span><br><span class="line">文字默认居左</span><br><span class="line">--两边加:表示文字居中</span><br><span class="line">--右边加:表示文字居右</span><br><span class="line">原生的语法两边都要用|包起来，此处原作者省略。</span><br></pre></td></tr></table></figure><p>单行代码:代码之间分别用一个反引号包起来<br><code>代码内容</code></p><p>代码块:代码之间分别用三个反引号包起来，且两边的反引号独占一行</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始 </span><br><span class="line">op&#x3D;&gt;operation: My Operation </span><br><span class="line">cond&#x3D;&gt;condition: Yes or No? </span><br><span class="line">e&#x3D;&gt;end: 结束 </span><br><span class="line"></span><br><span class="line">st-&gt;op-&gt;cond </span><br><span class="line">cond(yes)-&gt;e </span><br><span class="line">cond(no)-&gt;op </span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st&#x3D;&gt;start: 开始框</span><br><span class="line">op&#x3D;&gt;operation: 处理框</span><br><span class="line">cond&#x3D;&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1&#x3D;&gt;subroutine: 子流程</span><br><span class="line">io&#x3D;&gt;inputoutput: 输入输出框</span><br><span class="line">e&#x3D;&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;$A$&lt;/p&gt;
&lt;figure class=&quot;highlight js&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;sp</summary>
      
    
    
    
    <category term="语法" scheme="http://yoursite.com/categories/%E8%AF%AD%E6%B3%95/"/>
    
    
  </entry>
  
</feed>
