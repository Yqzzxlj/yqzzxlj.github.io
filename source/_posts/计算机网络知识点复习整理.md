---
title: 计算机网络知识点复习整理
date: 2021-03-02 23:41:22
tags:
    - 计算机网络
    - 基础知识
categories:
    - 计算机基础知识
    - 计算机网络
---

参考之前的笔记以及该[leetbook](https://leetcode-cn.com/leetbook/detail/)整理。

## 一、 协议层次及服务类型

### 1. OSI七层模型

1. 应用层：该层协议定义了应用进程之间的交互规则，通过不同的应用层协议为不同的网络应用提供服务。例如域名系统 DNS，支持万维网应用的 HTTP 协议，电子邮件系统采用的 SMTP 协议等。  报文（message）
2. 表示层：使通信的应用程序能够解释交换数据的含义。该层提供的服务主要包括数据压缩，数据加密以及数据描述。
3. 会话层：负责建立、管理和终止表示层实体之间的通信会话。该层提供了数据交换的定界和同步功能，包括了建立检查点和恢复方案的方法。
4. 传输层：为两台主机进程之间的通信提供服务。该服务并不针对某一特定的应用，多种应用可以使用同一个运输层服务。
5. 网络层：两台计算机之间传送数据时其通信链路往往不止一条，所传输的信息甚至可能经过很多通信子网。网络层的主要任务就是选择合适的网间路由和交换节点，确保数据按时成功传送。
6. 数据链路层：两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层协议。在两个相邻节点之间传送数据时，数据链路层将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息。通过控制信息我们可以知道一个帧的起止比特位置，此外，也能使接收端检测出所收到的帧有无差错，如果发现差错，数据链路层能够简单的丢弃掉这个帧，以避免继续占用网络资源。
7. 物理层：物理层的作用是实现计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。使其上面的数据链路层不必考虑网络的具体传输介质是什么。

### 2. TCP/IP参考模型

1. 应用层：将 OSI 参考模型中的会话层、表示层和应用层的功能合并到一个应用层实现，通过不同的应用层协议为不同的应用提供服务。FTP、Telnet、DNS、SMTP等
2. 传输层：其中面向连接的 TCP 协议保证了数据的传输可靠性，面向无连接的 UDP 协议能够实现数据包简单、快速地传输。
3. 网际互联层：负责相同或不同网络中计算机之间的通信。在网际互联层， IP 协议提供的是一个可靠、无连接的数据报传递服务。该协议实现两个基本功能：寻址和分段。根据数据报报头中的目的地址将数据传送到目的地址，在这个过程中 IP 负责选择传送路线。除了 IP 协议外，该层另外两个主要协议是互联网组管理协议（IGMP）和互联网控制报文协议（ICMP）。
4. 网络接入层：对应于 OSI 参考模型中的物理层和数据链路层，它负责监视数据在主机和网络之间的交换。

### 3. 五层参考模型

### 4. OSI模型和TCP/IP模型比较

+ 相同点：
  1. 都采用了层次结构
  2. 都提供面向连接和无连接两种通信服务机制
+ 不同点：
  1. OSI七层，TCP/IP四层
  2. OSI现有模型，后有协议规范，适用于描述各种网络。TCP/IP先有协议集在建立模型，不适用非TCP/IP网络。

### 5. 为什么TCP/IP没有会话层和表示层

由于应用层，表示层，会话层都是在应用程序内部实现，最终的产出是一个应用数据包。应用程序之间时无法实现代码的抽象共享的。数据压缩加密及会话难以抽象成一个协议。

### 6. 数据如何在各层之间传输（数据的封装过程）

在发送端主机，一个应用层报文被传送到运输层。在最简单的情况下，运输层收取到报文并附上附加信息，该首部将被接收端的运输层使用。应用层报文和运输层首部信息一道构成了运输层报文段。附加的信息可能包括：允许接收端运输层向上向适当的应用程序交付报文的信息以及差错检测位信息。该信息让接收端能够判断报文中的比特是否在途中已被改变。运输层则向网络层传递该报文段，网络层增加了如源和目的端系统地址等网络层首部信息，生成了网络层数据报。该数据报接下来被传递给链路层，在数据链路层数据包添加发送端 MAC 地址和接收端 MAC 地址后被封装成数据帧，在物理层数据帧被封装成比特流，之后通过传输介质传送到对端。

### 7. 协议对应

| OSI                     | TCP/IP     |                              |
| ----------------------- | ---------- | ---------------------------- |
| 应用层（application）   | 应用层     | HTTP，FTP，SMTP，DNS         |
| 表示层（presentation）  |            |                              |
| 会话层（Session）       |            |                              |
| 传输层（transport）     | 传输层     | TCP，UDP                     |
| 网络层（Network）       | 网络层     | IP，ICMP，ARP，RIP，IGMP     |
| 数据链路层（data link） | 数据链路层 | PPP、Ethernet                |
| 物理层（Physical）      |            | IEEE802.1A, IEEE802.3-802.11 |





## 二、应用层

## HTTP

### 1. HTTP报文格式

#### 1.1 请求报文

+ 请求行： 方法 sp URL sp 版本 cr lf（回车+换行）
+ 首部行：首部字段名 sp 值 cr lf    （n个）
+ cr lf
+ 实体主体（post时使用）

#### 1.2 响应报文

+ 状态行：版本 sp 状态码 sp 短语 cr lf
+ 首部行：首部字段名 sp 值 cr lf    （n个）
+ cr lf
+ 实体主体：报文的主要部分，它包含了所请求的对象。

### 2. HTTP首部行

通用头部、请求头部、响应头部、实体头部

1. 通用头部
   1. Cache-Control,指出是否使用缓存机制
   2. Connection，优先使用的连接类型
   3. Date，报文创建时间
   4. Upgrade，要求服务器升级到高版本协议
   5. Transfer-Encoding，用来改变报文格式
2. 请求头部
   1. Accept，告诉服务器自己允许哪些媒体类型
   2. Accept-charset， 可接受的字符集
   3. Accept-Encoding，可接受的编码方式
   4. Accept-Language，可以接受的语言
   5. Authorization，表示HTTP中需要认证资源的认证信息
   6. Host，服务器的域名及监听的端口号
   7. User-Agent，浏览器的身份标识
3. 响应头部
   1. Server，服务器信息
   2. Location，重定向后的URL
   3. Age，创建响应的时间
4. 实体头部
   1. Content-Length，返回内容的字节长度
   2. Content-encoding，返回内容的编码方式
   3. Content-Language，响应体的语言
   4. Content-Type，返回内容的MIME类型
   5. Last-Modified，请求资源的最后修改时间
   6. Expires，请求资源的过期时间

### 3. HTTP方法

+ HTTP/1.0定义了三种请求方法：GET、POST、HEAD
+ HTTP/1.1增加了六种请求方法：OPTIONS、PUT、PATCH、DELETE、TRACE、CONNECT

1. GET：请求指定页面信息，并返回具体内容。通常只用于读取数据。
2. POST：向指定资源提交数据进行处理请求（例如提交表单或上传文件）。数据被包含在请求体中。post请求可能会导致新的资源的建立或已有资源的更改。
3. HEAD：类似于GET请求，只不过返回的响应中没有具体的内容，用于获取报头。
4. PUT：替换指定的资源，没有就新增。
5. DELETE：请求服务器删除指定资源
6. CONNECT：将服务器作为代理，让服务器代替用户进行访问。
7. OPTIONS：服务器返回指定资源所支持的方法
8. TRACE：回显服务器收到的请求数据。
9. PATCH：对PUT方法的补充，对已知资源进行局部更新

### 4. 状态码

| 分类 | 描述                                     |
| ---- | ---------------------------------------- |
| 1XX  | 指示信息，表示请求正在处理               |
| 2XX  | 成功，表示请求被处理完毕                 |
| 3XX  | 重定向，要完成的请求需要进行附加操作     |
| 4XX  | 客户端错误，请求有语法错误或请求无法实现 |
| 5XX  | 服务器错误，服务器处理请求出现错误       |

| 状态码 | 英文描述           | 中文描述                                                     |
| ------ | ------------------ | ------------------------------------------------------------ |
| 100    | continue           | 继续，客户端继续处理请求                                     |
| 101    | switching protocol | 切换协议。服务器根据客户端的请求切换到更高级的协议           |
| 200    | OK                 | 请求成功                                                     |
| 201    | Created            | 请求实现并且新的资源根据请求建立                             |
| 204    | No Content         | 服务器成功处理了请求，但不需要返回任何实体内容               |
| 301    | Moved Permanently  | 永久移动。请求的资源已被永久地移动到新 URI，返回信息会包含新的 URI，浏览器会自动定向到新 URI |
| 302    | Found              | 临时移动。与 301 类似。但资源只是临时被移动，客户端应继续使用原有URI |
| 304    | Not Modified       | 未修改。如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码 |
| 400    | Bad Request        | 客户端请求的语法错误，服务器无法理解；请求的参数有误         |
| 401    | Unauthorized       | 当前请求需要用户验证                                         |
| 403    | Forbidden          | 服务器已经理解请求，但是拒绝执行它                           |
| 404    | Not Found          | 请求失败，请求所希望得到的资源未被在服务器上发现             |
| 500    | Internal Server    | 服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理 |
| 501    | Not Implemented    | 服务器不支持当前请求所需要的某个功能                         |
| 502    | Bad Gateway        | 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到无效的响应 |

#### 状态码301和302的区别

1. 301永久移动：请求的资源已被永久的移动到新的URI，旧的地址已经被永久的删除了。返回信息会包括新的URI，浏览器会自动定向到新的URI。今后新的请求都应使用新的URI代替。
2. 302临时移动：客户端拿到服务端的响应消息后会跳转到一个新的 URL 地址。但资源只是临时被移动，旧的地址还在，客户端应继续使用原有URI。

### 5. GET和POST的区别

1. GET提交的数据会放在URL之后，并且请求参数会被完整的保留在浏览器的记录里。由于参数直接暴露在URL中，可能会存在安全问题，因此往往用于获取资源信息。而post参数放在请求主体中，并且参数不会被保留，相比get更安全，主要用于修改服务器上的资源。
2. get请求只支持URL编码，post请求支持多种编码格式。
3. get只支持ASCII字符格式的参数，post方法没有限制。
4. get提交的数据大小有限制（受浏览器限制），而post提交的数据没限制。
5. get方法产生一个数据包，post方法产生两个（并不是所有浏览器都产生两个）。

PUT请求：如果两个请求相同，后一个请求会把第一个请求覆盖掉。（所以PUT用来改资源）

Post请求：后一个请求不会把第一个请求覆盖掉。（所以Post用来增资源

### 6. GET的长度限制

HTTP 中的 GET 方法是通过 URL 传递数据的，而 URL 本身并没有对数据的长度进行限制，真正限制 GET 长度的是浏览器。由于 POST 方法请求参数在请求主体中，理论上讲，post 方法是没有大小限制的，而真正起限制作用的是服务器处理程序的处理能力。

### 7. HTTP的报文长度

当响应消息中存在 Content-Length 字段时，我们可以直接根据这个值来判断数据是否接收完成，例如客户端向服务器请求一个静态页面或者一张图片时，服务器能够很清楚的知道请求内容的大小，因此可以通过消息首部字段 Content- Length 来告诉客户端需要接收多少数据。

如果服务器预先不知道请求内容的大小，例如加载动态页面的时候，就需要使用 Transfer-Encoding: chunked 的方式来代替 Content-Length。分块传输编码（Chunked transfer encoding）是 HTTP/1.1 中引入的一种数据传输机制，其允许 HTTP 由服务器发送给客户端的数据可以分成多个部分，当数据分解成一系列数据块发送时，服务器就可以发送数据而不需要预先知道发送内容的总大小，每一个分块包含十六进制的长度值和数据，最后一个分块长度值为0，表示实体结束，客户机可以以此为标志确认数据已经接收完毕。

### 8. HTTP长链接和短链接

+ 长连接：服务器在响应后保持该 TCP 连接打开，在同一个客户机与服务器之间的后续请求和响应报文可通过相同的连接进行传送。甚至位于同一台服务器的多个 Web 页面在从该服务器发送给同一个客户机时，可以在单个持久 TCP 连接上进行。多用于操作频繁，点对点的通讯，而且客户端连接数目较少的情况。例如即时通讯、网络游戏等。
+ 短链接：浏览器每次 发起 HTTP 请求都要与服务器创建一个新的 TCP 连接，服务器完成请求处理后立即断开 TCP 连接，服务器不跟踪每个客户也不记录过去的请求。然而创建和关闭连接的过程需要消耗资源和时间，为了减少资源消耗，缩短响应时间，就需要重用连接。在用户数目较多的Web网站的 HTTP 服务一般用短连接。例如京东，淘宝这样的大型网站一般客户端数量达到千万级甚至上亿，若采用长连接势必会使得服务端大量的资源被无效占用，所以一般使用的是短连接。

### 9. MIME（多用途的网际邮件扩充协议）

- text/html HTML页面
- text/plain 无格式文本
- application/postscript Postscript文档
- image/gif GIF格式编码的二进制图像
- image/png PNG格式编码的二进制图像
- image/jpeg JPEG格式编码的二进制图像

压缩包、css、xml

### 10. HTTP如何保存用户状态

假如某个特定的客户机在短时间内两次请求同一个对象，服务器并不会因为刚刚为该用户提供了该对象就不再做出反应，而是重新发送该对象，就像该服务器已经完全忘记不久之前所做过的是一样。因为一个 HTTP 服务器并不保存关于客户机的任何信息，所以我们说 HTTP 是一个无状态协议。

+ Session

  在客户端第一次向服务器发送 HTTP 请求后，服务器会创建一个 Session 对象并将客户端的身份信息以键值对的形式存储下来，然后分配一个会话标识（SessionId）给客户端，这个会话标识一般保存在客户端 Cookie 中，之后每次该浏览器发送 HTTP 请求都会带上 Cookie 中的 SessionId 到服务器，服务器根据会话标识就可以将之前的状态信息与会话联系起来，从而实现会话保持。

  优点：安全性高，因为状态信息保存在服务器端。

  缺点：由于大型网站往往采用的是分布式服务器，浏览器发送的 HTTP 请求一般要先通过负载均衡器才能到达具体的后台服务器，倘若同一个浏览器两次 HTTP 请求分别落在不同的服务器上时，基于 Session 的方法就不能实现会话保持了。

  【解决方法：采用中间件，例如 Redis，我们通过将 Session 的信息存储在 Redis 中，使得每个服务器都可以访问到之前的状态信息】

+ Cookie

  当服务器发送响应消息时，在 HTTP 响应头中设置 Set-Cookie 字段，用来存储客户端的状态信息。客户端解析出 HTTP 响应头中的字段信息，并根据其生命周期创建不同的 Cookie，这样一来每次浏览器发送 HTTP 请求的时候都会带上 Cookie 字段，从而实现状态保持。基于 Cookie 的会话保持与基于 Session 实现的会话保持最主要的区别是前者完全将会话状态信息存储在浏览器 Cookie 中。

  优点：服务器不用保存状态信息， 减轻服务器存储压力，同时便于服务端做水平拓展。

  缺点：1. 该方式不够安全，因为状态信息存储在客户端，这意味着不能在会话中保存机密数据。2。浏览器每次发起 HTTP 请求时都需要发送额外的 Cookie 到服务器端，会占用更多带宽。

  拓展：Cookie被禁用了怎么办？

  ​	若遇到 Cookie 被禁用的情况，则可以通过重写 URL 的方式将会话标识放在 URL 的参数里，也可以实现会话保持。

+ token

  验证请求是根据sessionid 到数据库中查找session表的，而数据库操作是服务端常见的性能瓶颈，尤其是当用户量比较大的时候。

  token 简单来说，就是包含了 数据信息 和 校验信息的 数据包。Session 机制是把 数据信息（比如session表）放到 服务端，**服务端数据是客户无法篡改的**，从而保证验证的 可靠性。

  而 token机制 数据信息 直接传给 客户端，客户每次请求再携带过来给服务端。服务端无需查找数据库，直接根据token里面的数据信息进行校验。

  Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。

### 11. HTTP和HTTPS的区别

1. HTTP协议以明文方式发送内容，数据都是为加密的，安全性较差。HTTPS传输过程数据是加密的，安全性较好
2. HTTP用80端口，HTTPS用443端口
3. HTTPS需要到数字认证机构（CA）申请证书
4. HTTP响应比HTTPS快，主要因为HTTP使用TCP3次握手连接；而HTTPS除了3次握手，还需要经历SSL协商过程

### 12. HTTPS的加密方式

HTTPS采用对称加密与非对称加密相结合的方式。首先使用 SSL/TLS 协议进行加密传输，为了弥补非对称加密的缺点（无法确定对方身份），HTTPS 采用证书来进一步加强非对称加密的安全性，通过非对称加密，客户端和服务端协商好之后进行通信传输的对称密钥，后续的所有信息都通过该对称秘钥进行加密解密，完成整个 HTTPS 的流程。

### 13. 客户端为什么信任第三方证书

假设中间人篡改了证书原文，由于他没有 CA 机构的私钥，所以无法得到此时加密后的签名，因此无法篡改签名。客户端浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书被中间人篡改，证书不可信，从而终止向服务器传输信息。

上述过程说明证书无法被篡改，我们考虑更严重的情况，例如中间人拿到了 CA 机构认证的证书，它想窃取网站 A 发送给客户端的信息，于是它成为中间人拦截到了 A 传给客户端的证书，然后将其替换为自己的证书。此时客户端浏览器收到的是被中间人掉包后的证书，但由于证书里包含了客户端请求的网站信息，因此客户端浏览器只需要把证书里的域名与自己请求的域名比对一下就知道证书有没有被掉包了。

### 14. HTTP和HTTPS的连接过程

+ HTTP

  使用TCP作为传输协议，其默认工作在 TCP 协议 80 端口，HTTP 客户机发起一个与服务器的 TCP 连接，一旦连接建立，浏览器和服务器进程就可以通过套接字接口访问 TCP。客户机从套接字接口发送 HTTP 请求报文和接收 HTTP 响应报文。类似地，服务器也是从套接字接口接收 HTTP 请求报文和发送 HTTP 响应报文。其通信内容以明文的方式发送，不通过任何方式的数据加密。当通信结束时，客户端与服务器关闭连接。

+ HTTPS

  > 以安全为目标的 HTTP 协议，在 HTTP 的基础上通过传输加密和身份认证的方式保证了传输过程的安全性。
  >
  > 1. 客户端发起一个HTTPS请求，并连接到服务器的443端口，提供自身支持的算法列表和密钥长度等
  > 2. 服务端将自身所支持的所有加密算法与客户端的算法列表进行对比并选择一种支持的加密算法，然后将它和其它密钥组件一同发送给客户端。
  > 3. 服务器向客户端发送一个包含数字证书的报文，该数字证书中包含证书的颁发机构、过期时间、服务端的公钥等信息。
  > 4. 最后服务端发送一个完成报文通知客户端 SSL 的第一阶段已经协商完成。
  > 5. SSL 第一次协商完成后，客户端发送一个回应报文，报文中包含一个客户端生成的随机密码串，称为 pre_master_secre，并且该报文是经过证书中的公钥加密过的。
  > 6. 紧接着客户端会发送一个报文提示服务端在此之后的报文是采用pre_master_secre 加密的。
  > 7. 客户端向服务端发送一个 finish 报文，这次握手中包含第一次握手至今所有报文的整体校验值，最终协商是否完成取决于服务端能否成功解密。
  > 8. 服务端同样发送与第 ⑥ 步中相同作用的报文，已让客户端进行确认，最后发送 finish 报文告诉客户端自己能够正确解密报文
  >
  > 当服务端和客户端的 finish 报文交换完成之后，SSL 连接就算建立完成了，之后就进行和 HTTP 相同的通信过程，唯一不同的是在 HTTP 通信过程中并不是采用明文传输，而是采用对称加密的方式，其中对称密钥已经在 SSL 的建立过程中协商好了。

### 15. HTTP1.0、1.1、2.0的区别

http1.0采用的是非持续连接的方式，一次连接只能处理一次请求，如何一个用户多次向服务器提供请求，就是因为多次连接造成大量的交付时延。

http1.1为了解决这个问题，开始支持持久连接，一次TCP连接可以进行多次http请求。同时增加了更多的缓存处理，带宽优化及网络连接的使用（可以设置请求范围），错误通知的管理，Host头处理（在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname））

http2.0在http1.0的基础上增加了多路复用（避免第一个请求阻塞后，后面的请求都需要等待，这也就是队头阻塞(Head of line blocking)）同时增加了新的二进制格式，Header压缩，服务端推送功能

HTTP/3 采用QUIC+UDP，上层仍然是http/2，建立连接快，正常只需要 1 RTT 即可建立连接。

### 16. 抓包的过程（代理）

### 17. URL和URI的区别（子集）

### 18. socket套接字有哪些（流、数据包、原始）

### 19. DNS的作用和原理（UDP）

#### 作用

通常我们有两种方式识别主机：通过主机名或者 IP 地址。人们喜欢便于记忆的主机名表示，而路由器则喜欢定长的、有着层次结构的 IP 地址。为了满足这些不同的偏好，我们就需要一种能够进行主机名到 IP 地址转换的目录服务，域名系统作为将域名和 IP 地址相互映射的一个分布式数据库，能够使人更方便地访问互联网。

#### 工作原理

（1）查询浏览器，操作系统缓存；
（2）查询本地域名服务器；
（3）查询根域名服务器；
（4）查询主域名服务器；
（5）查询对方的域名服务器；
（6）找到ip；

### 20. 其他协议

#### 20.1 FTP

FTP使用两个并行的TCP连接来传输数据，一个TCP（21号端口）被称为控制连接，用来传输FTP命令；一个TCP（20号端口）连接称为数据连接用于传输文件数据

#### 20.2 SMTP

简单邮件传输服务。TCP，25端口

### 21. 网页解析过程

1. **DNS解析**：当用户输入一个网址并按下回车键的时候，浏览器获得一个域名，而在实际通信过程中，我们需要的是一个 IP 地址，因此我们需要先把域名转换成相应 IP 地址。
2.  **TCP 连接**：浏览器通过 DNS 获取到 Web 服务器真正的 IP 地址后，便向 Web 服务器发起 TCP 连接请求，通过 TCP 三次握手建立好连接后，浏览器便可以将 HTTP 请求数据发送给服务器了。
3. **发送HTTP请求**：浏览器向 Web 服务器发起一个 HTTP 请求，HTTP 协议是建立在 TCP 协议之上的应用层协议，其本质是在建立起的TCP连接中，按照HTTP协议标准发送一个索要网页的请求。
4. **处理请求并返回**：服务器获取到客户端的 HTTP 请求后，会根据 HTTP 请求中的内容来决定如何获取相应的文件，并将文件发送给浏览器。
5. **浏览器渲染**：浏览器根据响应开始显示页面，首先解析 HTML 文件构建 DOM 树，然后解析 CSS 文件构建渲染树，等到渲染树构建完成后，浏览器开始布局渲染树并将其绘制到屏幕上。
6. **断开连接**：客户端和服务器通过四次挥手终止 TCP 连接。

### 22. （找自己IP（ICMP、UDP、IP、以太网），找网关MAC（DNS，ARP），TCP，HTTP）

#### DHCP、UDP、IP和以太网（找本机IP）

DHCP四个步骤中仅有最后两个步骤是实际必要的。

1. 主机生成一个DHCP请求报文，并将这个报文放入具有目的端口67（DHCP服务器）和源端口68（DHCP客户）的UDP报文段中。
2. 该报文段被放入一个具有广播IP目的地址（255.255.255.255）和源IP地址（0.0.0.0)的IP数据报中，因为主机还没有一个IP地址。
3. 该IP数据报被放置在以太网帧中，该MAC帧具有目的MAC地址（FF:FF:FF:FF:FF:FF),将该帧广播到交换机连接的所有设备(顺利的话也包括DHCP服务器)；该帧的源MAC地址时主机的MAC地址。
4. 该帧是第一个由主机发送到以太网交换机中的帧。该交换机在所有的出端口广播入帧。
5. DHCP服务器的接口受到该帧，不断向上解析得到IP、UDP、DHCP报文，之后生成DHCP的ACK报文，该报文包括IP地址（CIDR分配策略），DNS服务器的IP地址、默认网关路由器的IP地址、子网掩码。将DHCP的ACK报文放入UDP报文段中，UDP报文段被放入IP数据报中，IP数据报在被放入一个以太网帧中。源MAC地址是服务器接口的MAC地址，目的MAC地址是主机MAC地址。
6. 以太网帧发送到交换机中，由于交换机是自学习的（记录每个接口对应的MAC地址），并且受到过主机的以太网帧，所以交换机仅向主机接口转发该帧。
7. 主机收到帧后，提取出IP数据报，取出UDP报文段，取出ACK报文。DHCP客户端记录下他的IP地址和他的DNS服务器的IP地址。并在**IP转发表**中安装默认网关的地址，主机会向网关发送目的地址为其子网以外的所有数据报。

#### DNS、ARP（找网关MAC地址)

1. 主机会通过浏览器生成一个TCP套接字，用于向网站发送HTTP请求，但是需要知道网站的IP地址。
2. 主机的操作系统生成一个DNS查询报文，将网站的域名放入DNS报文的问题段中。将该报文放入一个目的端口号为53（DNS服务器）的UDP报文段中。该报文段被放入IP目的地址为DNS服务器，源地址为主机IP地址的IP数据报中。
3. 数据报会放入到以太网帧中。该帧将发送到网关路由器。但是主机通过DHCP过程只知道网关路由器的IP地址，不知道网关路由器的MAC地址。为了获取网关的MAC地址，需要使用ARP协议。
4. 主机生成一个具有目的IP地址为网关IP的ARP查询报文。放入到一个具有广播地址（FF:FF:FF:FF:FF:FF)的以太网帧中，并向交换机发送这个广播帧，交换机将帧发送给所有连接的设备，包括网关路由器。
5. 网关在收到该帧后，发现目标IP与自己IP匹配，所以要发送一个ARP回答，指示自己的MAC地址对应自己的IP地址。将ARP回答放入以太网帧中，目的地址为主机的MAC地址，向交换机发送该帧，由交换机发送给主机。
6. 主机收到该帧并抽取网关路由器的MAC地址，继续DNS解析过程。
7. 将包含DNS查询报文的数据报放入目的地址为网关MAC地址的以太网帧中，通过交换机发送给网关路由器。主机报文的IP目的地址是DNS服务器，MAC目的地址是网关服务器。
8. 网关接收到DNS查询的IP数据报后，根据IP数据报的目的地址选择转发给响应的路由器。
9. 路由器收到IP数据报后，根据目的地址和转发表确定出接口，根据内部网关协议（RIP、OSPF）和外部网关协议（BGP）配置路由器到DNS的路由表项（路由选择）。
10. DNS服务器收到数据报后，抽取DNS查询报文。并在DNS库中查找域名。
11. 找到包含对应域名的IP地址的DNS源记录后，向主机发送一个包含域名到IP地址映射的DNS回答报文，将该DNS回答报文放入UDP报文段、IP数据报中，通过路由器反转发给网关路由器，经过交换机到主机。
12. 主机从报文中抽取服务器的IP地址。

#### TCP、HTTP

1. 有了服务器的IP地址之后，便生成TCP套接字，用该套接字向服务器发送HTTP GET报文。
2. 建立HTTP连接需要进行TCP连接，进行三次握手
3. 建立连接后发送HTTP的GET报文，将报文放入TCP报文段的载荷中，然后生成IP数据报送往服务器。
4. 服务器从TCP套接字中读取报文，生成HTTP响应报文，将页面内容放入HTTP响应体中，发送到主机。
5. 浏览器收到HTTP响应报文后抽取Web页面内容进行渲染，显示web页面。

## 三、运输层

### 1. 三次握手和四次挥手机制

#### 三次握手

三次握手是TCP连接的建立过程。在握手之前，主动打开连接的客户端结束 CLOSE 阶段，被动打开的服务器也结束 CLOSE 阶段，并进入 LISTEN 阶段。随后进入三次握手阶段：

1. 首先客户端向服务器发送一个SYN包，并等待服务器确认。
   + 标志位SYN置位，表示请求建立连接。
   + 序列号Seq=x（随机选择）。
   + 客户端进入SYN-SENT阶段。
2. 服务器接收到客户端发来的SYN包之后，对该包进行确认结束LISTEN阶段，并返回一段TCP报文。
   1. 标志位SYN和ACK置位。表示确认客户端的报文Seq序号有效，服务器能正常接受客户端发送的数据，并同意建立连接。
   2. 序列号Seq=y。
   3. 确认号Ack=x+1，表示收到客户端的序号Seq并将其值加1作为确认号Ack的值。随后服务器端进入SYN-RECV状态。
3. 客户端接收到SYN+ACK包之后，明确了从客户端到服务器的数据传输是正常的，从而结束SYN-SENT阶段。并返回最后一段TCP报文。
   1. 标识位为ACK，表示确认收到服务器端同意连接的信号。
   2. 序列号为Seq=x+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值。
   3. 确认号为Ack=y+1，表示收到服务器端的序列号Seq，将其值加1作为自己确认号的值。
   4. 随后客户端进入ESTABLISHED阶段。

当服务器收到来自客户端的报文之后，得知从服务器到客户端的数据传输是正常的，从而结束SYN-RECV阶段，进入ESTABLISH阶段，完成三次握手。

#### 四次挥手

四次挥手是TCP连接的释放，这里假设客户端主动释放连接。在挥手之前主动释放连接的客户端结束ESTABLISH阶段。

1. 客户端向服务器发送一段TCP报文表明其想要释放TCP连接。

   1. 标志位为FIN，表示请求释放连接
   2. 序列号为Seq=u，
   3. 随后客户端进入FIN-WAIT-1阶段，即半关闭状态，并且停止向服务器端发送数据。

2. 服务器接收到客户端接收请求断开连接的FIN报文后，结束ESTABLISH阶段，进入CLOST-WAIT阶段并返回一段报文。

   1. 标志位为ACK，表示接收到客户端释放连接的请求。
   2. 序列号为Seq=v，
   3. 确认号为Ack=u+1，表示是在接收到客户端报文的基础上，将其序列号加1作为本段报文的确认号。

   客户端收到服务器发送过来的TCP报文后，确认服务器已经收到了客户端连接释放的请求。随后客户端结束FIN-WAIT-1阶段，进入FIN-WAIT-2阶段。

3. 服务器端在发出ACK确认报文之后，服务器端会将遗留的待传数据传送给客户端，待传输完成后结束CLOSE-WAIT阶段，准备释放服务器到客户端方向上的连接，再次向客户端发送一段TCP报文，其中，

   1. 标志位为FIN和ACK，表示准备好释放连接了
   2. 序列号为Seq=w，
   3. 确认号为Ack=u+1，表示是在接收到客户端报文的基础上，将其序列号加1作为本段报文的确认号。

   随后服务器端结束CLOST-WAIT阶段，进入LAST-WAIT阶段，并且停止向客户端发送数据。

4. 客户端收到服务器端发来的TCP报文，确认了服务器已经做好释放连接的准备，于是结束FIN-WAIT-2阶段，进入TIME-WAIT阶段，向服务器发送一段报文，

   1. 标志位为ACK，表示接收到释放连接的请求。
   2. 序列号为Seq=u+1，表示收到服务器端的确认号Ack，并将其值作为自己的序号值。
   3. 确认号为w+1，表示是在接收到客户端报文的基础上，将其序列号加1作为本段报文的确认号。

   随后客户端在TIME-WAIT阶段等待2MSL。服务器收到来自客户端的报文之后结束LAST-ACK阶段，进入CLOSE阶段。由此正式结束服务器端到客户端方向上的连接，客户端等待完2MSL时间后，结束TIME-WAIT阶段，进入CLOSE阶段，由此完成四次挥手。

### 2. 如果每次握手的时候每次握手信息对方没有收到怎么办

1. 若第一次握手服务器未接收到客户端请求建立连接的数据包时，服务器不会进行任何相应的动作，而客户端由于在一段时间内没有收到服务器发来的确认报文， 因此会等待一段时间后重新发送 SYN 同步报文，若仍然没有回应，则重复上述过程直到发送次数超过最大重传次数限制后，建立连接的系统调用会返回 -1。
2. 若第二次握手客户端未接收到服务器回应的 ACK 报文时，客户端会采取第一次握手失败时的动作，这里不再重复，而服务器端此时将阻塞在 accept() 系统调用处等待 client 再次发送 ACK 报文。
3. 若第三次握手服务器未接收到客户端发送过来的 ACK 报文，同样会采取类似于客户端的超时重传机制，若重传次数超过限制后仍然没有回应，则 accep() 系统调用返回 -1，服务器端连接建立失败。但此时客户端认为自己已经连接成功了，因此开始向服务器端发送数据，但是服务器端的 accept() 系统调用已返回，此时没有在监听状态。因此服务器端接收到来自客户端发送来的数据时会**发送 RST 报文**给客户端，消除客户端单方面建立连接的状态。

### 3. 为什么要进行三次握手，两次可以吗

三次握手的主要目的是确认自己和对方的发送和接收都是正常的，从而保证了双方能够进行可靠通信。若采用两次握手，当第二次握手后就建立连接的话，此时客户端知道服务器能够正常接收到自己发送的数据，而**服务器并不知道客户端是否能够收到自己发送的数据**。

我们知道网络往往是非理想状态的（存在丢包和延迟），当客户端发起创建连接的请求时，如果服务器直接创建了这个连接并返回包含 SYN、ACK 和 Seq 等内容的数据包给客户端，这个数据包因为网络传输的原因丢失了，丢失之后客户端就一直接收不到返回的数据包。由于客户端可能设置了一个超时时间，一段时间后就关闭了连接建立的请求，再重新发起新的请求，而服务器端是不知道的，**如果没有第三次握手告诉服务器客户端能否收到服务器传输的数据的话，服务器端的端口就会一直开着，等到客户端因超时重新发出请求时，服务器就会重新开启一个端口连接**。长此以往， 这样的端口越来越多，就会造成服务器开销的浪费。

### 4. 为什么要4次挥手

释放 TCP 连接时之所以需要四次挥手，是因为 FIN 释放连接报文和 ACK 确认接收报文是分别在两次握手中传输的。 当主动方在数据传送结束后发出连接释放的通知，由于被动方可能还有必要的数据要处理，所以会先返回 ACK 确认收到报文。当被动方也没有数据再发送的时候，则发出连接释放通知，对方确认后才完全关闭TCP连接。

### 5. CLOSE-WAIT和TIME-WAIT的意义

+ CLOSE-WAIT：在服务器收到客户端关闭连接的请求并告诉客户端自己已经成功收到了该请求之后，服务器进入了 CLOSE-WAIT 状态，然而此时有可能服务端还有一些数据没有传输完成，因此不能立即关闭连接，而 CLOSE-WAIT 状态就是为了保证服务器在关闭连接之前将待发送的数据发送完成。
+ TIME-WAIT：TIME-WAIT 发生在第四次挥手，当客户端向服务端发送 ACK 确认报文后进入该状态，若取消该状态，即客户端在收到服务端的 FIN 报文后立即关闭连接，此时服务端相应的端口并没有关闭，若客户端在相同的端口立即建立新的连接，则**有可能接收到上一次连接中残留的数据包**，可能会导致不可预料的异常出现。除此之外，假设客户端**最后一次发送的 ACK 包在传输的时候丢失了**，由于 TCP 协议的超时重传机制，**服务端将重发 FIN 报文**，若客户端并没有维持 TIME-WAIT 状态而直接关闭的话，当收到服务端重新发送的 FIN 包时，客户端就会用**RST包**来响应服务端，这将会使得对方认为是有错误发生，然而其实只是正常的关闭连接过程，并没有出现异常情况。

### 6. TIME-WAIT状态导致什么问题

我们考虑高并发短连接的业务场景，在高并发短连接的 TCP 服务器上，当服务器处理完请求后主动请求关闭连接，这样服务器上会有大量的连接处于 TIME_WAIT 状态，服务器维护每一个连接需要一个 socket，也就是每个连接会占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些正常的 连接失败。

解决方案：修改配置或设置 SO_REUSEADDR 套接字，使得服务器处于 TIME-WAIT 状态下的端口能够快速回收和重用。

### 7. TIME-WAIT为什么是2MSL

当客户端发出最后的 ACK 确认报文时，并不能确定服务器端能够收到该段报文。所以客户端在发送完 ACK 确认报文之后，会设置一个时长为 2 MSL 的计时器。MSL（Maximum Segment Lifetime），指一段 TCP 报文在传输过程中的最大生命周期。2 MSL 即是服务器端发出 FIN 报文和客户端发出的 ACK 确认报文所能保持有效的最大时长。

若**服务器在 1 MSL 内没有收到客户端发出的 ACK 确认报文**，再次向客户端发出 FIN 报文。如果客户端在 2 MSL 内收到了服务器再次发来的 FIN 报文，说明服务器由于一些原因并没有收到客户端发出的 ACK 确认报文。客户端将再次向服务器发出 ACK 确认报文，并重新开始 2 MSL 的计时。

若**客户端在 2MSL 内没有再次收到服务器发送的 FIN 报文**，则说明服务器正常接收到客户端 ACK 确认报文，客户端可以进入 CLOSE 阶段，即完成四次挥手。

所以客户端要经历 2 MSL 时长的 TIME-WAIT 阶段，为的是确认服务器能否接收到客户端发出的 ACK 确认报文。

### 8. TCP和UDP的区别

| 类型 | 是否面向连接 | 可靠性 | 传输形式 | 传输效率 | 所需资源 | 应用场景           | 首部字节 |
| ---- | ------------ | ------ | -------- | -------- | -------- | ------------------ | -------- |
| TCP  | 是           | 可靠   | 字节流   | 慢       | 多       | 文件传输、邮件传输 | 20-60    |
| UDP  | 否           | 不可靠 | 数据报   | 快       | 少       | 即时通讯、域名转换 | 8        |

### 9. TCP协议中的定时器

建立连接定时器、重传定时器、坚持定时器（窗口变大）、延迟应答定时器、保活定时器、FIN-WAIT-2定时器、TIME-WAIT定时器

### 10. TCP如何保证可靠性

1. 数据分块：应用数据被分割成TCP最适合发送的数据块
2. 序列号和确认应答：CP 给发送的每一个包进行编号，在传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答，即发送 ACK 报文，这个 ACK 报文当中带有对应的确认序列号，告诉发送方成功接收了哪些数据以及下一次的数据从哪里开始发。除此之外，接收方可以根据序列号对数据包进行排序，把有序数据传送给应用层，并丢弃重复的数据。
3. 校验和：TCP将保持它首部和数据部分的校验和，这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到报文段的检验和有差错，TCP 将丢弃这个报文段并且不确认收到此报文段。
4. 流量控制：TCP 连接的双方都有一个固定大小的缓冲空间，发送方发送的数据量不能超过接收端缓冲区的大小。当接收方来不及处理发送方的数据，会提示发送方降低发送的速率，防止产生丢包。TCP 通过滑动窗口协议来支持流量控制机制。
5. 拥塞控制：当网络某个节点发生拥塞时，减少数据的发送。
6. 超时重传：当 TCP 发出一个报文段后，它启动一个定时器，等待目的端确认收到这个报文段。如果超过某个时间还没有收到确认，将重发这个报文段。
7. ARQ协议：每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。

### 11. UDP为什么是不可靠的？bind和connect对于UDP的作用

UDP只有一个socket接收缓冲区，没有socket发送缓冲区，即只要有数据就发送，不管对方是否能正确接收。而在对方的socket接收缓冲区满了之后，新来的数据报无法进入到socket接收缓冲区，此数据报就会被丢弃，因此UDP不保证数据能够到达目的地，此外，UDP也没有流量控制和重传机制。故UDP的数据传输是不可靠的。

和TCP建立连接时使用3次握手不同，UDP中调用connect只是把对端的IP和端口号记录下来，并且UDP可多次调用connect来指定新的IP和端口号，或断开旧的IP和端口号。和普通的 UDP 相比，调用 connect 的 UDP 会提升效率，并且在高并发服务中会增加系统稳定性。

当 UDP 的发送端调用 bind 函数时，就会将这个套接字指定一个端口，若不调用 bind 函数，系统内核会随机分配一个端口给该套接字。当手动绑定时，能够避免内核来执行这一操作，从而在一定程度上提高性能。

### 12. TCP超时重传的原理

发送方在发送一次数据后就开启一个定时器，在一定时间内如果没有得到发送数据包的 ACK 报文，那么就重新发送数据，在达到一定次数还没有成功的话就放弃重传并发送一个复位信号。其中超时时间的计算是超时的核心，而定时时间的确定往往需要进行适当的权衡，因为当定时时间过长会造成网络利用率不高，定时太短会造成多次重传，使得网络阻塞。在 TCP 连接过程中，会参考当前的网络状况从而找到一个合适的超时时间。

### 13. TCP的停止等待协议

停止等待协议是为了实现 TCP 可靠传输而提出的一种相对简单的协议，该协议指的是发送方每发完一组数据后，直到收到接收方的确认信号才继续发送下一组数据。

可能出现的情况：无差错、超时重传、确认丢失、确认迟到。

### 14. TCP最大连接数限制

client 在每次发起 TCP 连接请求时，如果自己并不指定端口的话，系统会随机选择一个本地端口（local port），该端口是独占的，不能和其他 TCP 连接共享。TCP 端口的数据类型是 unsigned short，因此本地端口个数最大只有 65536，除了端口 0不能使用外，其他端口在空闲时都可以正常使用，这样可用端口最多有 65535 个。

server 通常固定在某个本地端口上监听，等待 client 的连接请求。不考虑地址重用（Unix 的 SO_REUSEADDR 选项）的情况下，即使 server 端有多个 IP，本地监听端口也是独占的，因此 server 端 TCP 连接 4 元组中只有客户端的 IP 地址和端口号是可变的，因此最大 TCP 连接为客户端 IP 数 × 客户端 port 数，对 IPV4，在不考虑 IP 地址分类的情况下，最大 TCP 连接数约为 2 的 32 次方（IP 数）× 2 的 16 次方（port 数），也就是 server 端单机最大 TCP 连接数约为 2 的 48 次方

### 15. TCP流量控制与拥塞控制

+ 流量控制：所谓流量控制就是让发送方的发送速率不要太快，让接收方来得及接收。如果接收方来不及接收发送方发送的数据，那么就会有分组丢失。在 TCP 中利用可边长的滑动窗口机制可以很方便的在 TCP 连接上实现对发送方的流量控制。主要的方式是接收方返回的 ACK 中会包含自己的接收窗口大小，以控制发送方此次发送的数据量大小（发送窗口大小）。
+ 拥塞控制：在实际的网络通信系统中，除了发送方和接收方外，还有路由器，交换机等复杂的网络传输线路，此时就需要拥塞控制。拥塞控制是作用于网络的，它是防止过多的数据注入到网络中，避免出现网络负载过大的情况。常用的解决方法有：慢开始和拥塞避免、快重传和快恢复。
+ 区别：拥塞控制往往是一种全局的，防止过多的数据注入到网络之中，而TCP连接的端点只要不能收到对方的确认信息，猜想在网络中发生了拥塞，但并不知道发生在何处。而流量控制往往指点对点通信量的控制，是端到端的问题。

### 16. 如果接收方滑动窗口满了，发送方会怎么做

基于 TCP 流量控制中的滑动窗口协议，我们知道接收方返回给发送方的 ACK 包中会包含自己的接收窗口大小，若接收窗口已满，此时接收方返回给发送方的接收窗口大小为 0，此时发送方会等待**接收方发送的窗口大小直到变为非 0 **为止，然而，**接收方回应的 ACK 包是存在丢失的可能**的，为了防止双方一直等待而出现死锁情况，此时就需要**坚持计时器**来辅助发送方周期性地向接收方查询，以便发现窗口是否变大【坚持计时器参考问题】，当发现窗口大小变为非零时，发送方便继续发送数据。

### 17. TCP拥塞控制采取的四种算法

1. 慢开始

   当发送方开始发送数据时，由于一开始不知道网络负荷情况，如果立即将大量的数据字节传输到网络中，那么就有可能引起网络拥塞。一个较好的方法是在一开始发送少量的数据先探测一下网络状况，即由小到大的增大发送窗口（拥塞窗口 cwnd）。慢开始的慢指的是初始时令 cwnd为 1，即一开始发送一个报文段。如果收到确认，则 cwnd = 2，之后每收到一个确认报文，就令 cwnd = cwnd* 2。

   但是，为了防止拥塞窗口增长过大而引起网络拥塞，另外设置了一个慢开始门限 ssthresh。

   ① 当 cwnd < ssthresh 时，使用上述的慢开始算法；

   ② 当 cwnd > ssthresh 时，停止使用慢开始，转而使用拥塞避免算法；

   ③ 当 cwnd == ssthresh 时，两者均可。

2. 拥塞避免

   拥塞控制是为了让拥塞窗口 cwnd 缓慢地增大，即每经过一个往返时间 RTT （往返时间定义为发送方发送数据到收到确认报文所经历的时间）就把发送方的 cwnd 值加 1，通过让 cwnd 线性增长，防止很快就遇到网络拥塞状态。

   当网络拥塞发生时，让新的慢开始门限值变为发生拥塞时候的值的一半,并将拥塞窗口置为 1 ,然后再次重复两种算法（慢开始和拥塞避免）,这时一瞬间会将网络中的数据量大量降低。

3. 快重传

   快重传算法要求接收方每收到一个失序的报文就立即发送重复确认，而不要等到自己发送数据时才捎带进行确认，假定发送方发送了 Msg 1 ~ Msg 4 这 4 个报文，已知接收方收到了 Msg 1，Msg 3 和 Msg 4 报文，此时因为接收到收到了失序的数据包，按照快重传的约定，接收方应立即向发送方发送 Msg 1 的重复确认。 于是在接收方收到 Msg 4 报文的时候，向发送方发送的仍然是 Msg 1 的重复确认。这样，发送方就收到了 3 次 Msg 1 的重复确认，于是立即重传对方未收到的 Msg 报文。由于发送方尽早重传未被确认的报文段，因此，快重传算法可以提高网络的吞吐量。

4. 快恢复

   快恢复算法是和快重传算法配合使用的，该算法主要有以下两个要点：

   ① 当发送方连续收到三个重复确认，执行乘法减小，慢开始门限 ssthresh 值减半；

   ② 由于发送方可能认为网络现在没有拥塞，因此与慢开始不同，把 cwnd 值设置为 ssthresh 减半之后的值，然后执行拥塞避免算法，线性增大 cwnd。

### 18. TCP粘包问题

① 发送方写入的数据大于套接字缓冲区的大小，此时将发生拆包。

② 发送方写入的数据小于套接字缓冲区大小，由于 TCP 默认使用 Nagle 算法，只有当收到在传数据的确认后，才将分组发送给对端，当发送方收集了多个较小的分组，就会一起发送给对端，这将会发生粘包。

③ 进行 MSS （最大报文长度）大小的 TCP 分段，当 TCP 报文的数据部分大于 MSS 的时候将发生拆包。

④ 发送方发送的数据太快，接收方处理数据的速度赶不上发送端的速度，将发生粘包。

#### 常见解决方法

① 在消息的头部添加消息长度字段，服务端获取消息头的时候解析消息长度，然后向后读取相应长度的内容。

② 固定消息数据的长度，服务端每次读取既定长度的内容作为一条完整消息，当消息不够长时，空位补上固定字符。但是该方法会浪费网络资源。

③ 设置消息边界，也可以理解为分隔符，服务端从数据流中按消息边界分离出消息内容，一般使用换行符。

#### 什么时候要处理粘包问题

当接收端同时收到多个分组，并且这些分组之间毫无关系时，需要处理粘包；而当多个分组属于同一数据的不同部分时，并不需要处理粘包问题

### 19.TCP报文

1. 源端口号、目的端口号
2. 序列号
3. 确认号
4. 首部长度、保留字段、URG、ACK、PSH、RST、SYN、FIN、接收窗口
5. 校验和、紧急数据指针
6. 选项
7. 数据

+ 源端口号和目的端口号：它用于多路复用/分解来自或送往上层应用的数据，其和 IP 数据报中的源 IP 与目的 IP 地址一同确定一条 TCP 连接。
+ 序列号和确认号：序号是本报文段发送的数据部分中第一个字节的编号，在 TCP 传送的流中，每一个字节一个序号。例如一个报文段的序号为 100，此报文段数据部分共有 100 个字节，则下一个报文段的序号为 200。序号确保了 TCP 传输的有序性。确认号，即 ACK，指明下一个想要收到的字节序号，发送 ACK 时表明当前序号之前的所有数据已经正确接收。这两个字段的主要目的是保证数据可靠传输。
+ 首部长度：该字段指示了以 32 比特的字为单位的 TCP 的首部长度。其中固定字段长度为 20 字节，由于首部长度可能含有可选项内容，因此 TCP 报头的长度是不确定的，20 字节是 TCP 首部的最小长度。
+ 保留字段
+ 控制位
  + URG：紧急指针标志，该位为1时表示紧急指针有效
  + ACK：确认序号标志，即相应报文段包含对以成功接收报文的确定
  + PSH：push标志，指接收到该报文段后，应当尽快将该报文段交给应用程序，而不是在缓冲区排队。
  + RST：重置连接标志，指连接出现错误，使用此标志来拒绝非法的请求。
  + SYN：为同步序号，在连接的建立过程中使用，例如三次握手时，发送方发送 SYN 包表示请求建立连接
  + FIN：finish标志，用于释放连接，为 1 时表示发送方已经没有数据发送了，即关闭本方数据流。
+ 接收窗口：用于TCP流量控制。该字段告诉发送方其窗口大小，以次控制发送速率，达到流量控制的效果
+ 校验和：奇偶校验，此校验和是对整个 TCP 报文段，包括 TCP 头部和 数据部分。该校验和是一个端到端的校验和，由发送端计算和存储，并由接收端进行验证，主要目的是检验数据是否发生改动，若检测出差错，接收方会丢弃该 TCP 报文。
+ 紧急数据指针：紧急数据用于告知紧急数据所在的位置，在URG标志位为 1 时才有效。当紧急数据存在时，TCP 必须通知接收方的上层实体，接收方会对紧急模式采取相应的处理。
+ 选项：该字段一般为空，可根据首部长度进行推算。主要有以下作用：
  1. TCP连接初始化时，通信双方确认最大报文长度
  2. 在高速数据传输时，协商窗口扩大因子
  3. 作为时间戳时，提供一个 较为精准的 RTT，主要为了更好的实现 TCP 流量控制协议。
+ 数据：CP 报文中的数据部分也是可选的，例如在 TCP 三次握手和四次挥手过程中，通信双方交换的报文只包含头部信息，数据部分为空，只有当连接成功建立后，TCP 包才真正携带数据。

### 20. SYN FLOOD

SYN FLOOD是典型的DoS（拒绝服务）攻击，其目的是通过消耗服务器可用资源是服务器无法处理合法请求。通过重复发送初始连接请求（SYN）数据包，攻击者能够压倒目标服务器上的所有可用端口，导致目标设备根本不响应合法请求。

### 21. 为什么服务端易受到SYN攻击

在TCP建立连接的过程中，因为服务端不确定自己发给客户端的 SYN-ACK 消息或客户端反馈的 ACK 消息是否会丢在半路，所以会给每个待完成的半开连接状态设一个定时器，如果超过时间还没有收到客户端的 ACK 消息，则重新发送一次 SYN-ACK 消息给客户端，直到重试超过一定次数时才会放弃。

服务端为了维持半开连接状态，需要分配内核资源维护半开连接。当攻击者伪造海量的虚假 IP 向服务端发送 SYN 包时，就形成了 SYN FLOOD 攻击。攻击者故意不响应 ACK 消息，导致服务端被大量注定不能完成的半开连接占据，直到资源耗尽，停止响应正常的连接请求。

解决方法：1. 减少半开资源占用时间，2. 黑名单阻止恶意IP

SYN cache、SYN cookie。 由于服务端不保存半连接状态，所以没有超时重传能力

SYN proxy

## 四、网络层

### 1. IP协议的定义与作用

IP协议（Internet Protocol）又称互联网协议，是支持网间互联的数据包协议。该协议工作在网络层，主要目的是为了提高网络的可扩展性。和传输层的TCP相比，IP是一种无连接、不可靠、尽力而为的数据包传输服务，其与TCP协议（传输控制协议）一起构成了TCP/IP协议族的核心。IP协议主要有以下几个作用

+ 寻址和路由：在IP 数据包中会携带源 IP 地址和目的 IP 地址来标识该数据包的源主机和目的主机。IP 数据报在传输过程中，每个中间节点（IP 网关、路由器）只根据网络地址进行转发，如果中间节点是路由器，则路由器会根据路由表选择合适的路径。IP 协议根据路由选择协议提供的路由信息对 IP 数据报进行转发，直至抵达目的主机。
+ 分段与重组：IP数据包在传输过程中可能会经过不同的网络，不同的网络中数据包的最大长度限制是不同的。IP协议通过给每个IP数据包分配一个标识符以及分段与组装的相关信息，使得数据包在不同的网络中能够被传输，被分段后的 IP 数据报可以独立地在网络中进行转发，在**到达目的主机后由目的主机完成重组工作**，恢复出原来的 IP 数据包。

### 2. 域名和IP的关系

一个域名只能对应一个 IP 地址，是一对一的关系；而一个 IP 却可以对应多个域名，是一对多的关系。

### 3. IPv4地址不够怎么解决

+ DHCP： 动态主机配置协议。动态分配IP地址，只给接入网络的设备分配IP地址。因此同一个MAC地址的设备每次接入互联网时得到的IP地址不一定是相同的，该协议使得空闲的IP可以得到充分利用。
+ CIDR：无类别域间路由。CIDR消除了A类、B类、C类地址以及子网划分概念，因而更加有效的分配IPv4的地址空间，但无法从根本上解决地址耗尽问题。一个IP地址包括标识网络的前缀和紧接着的在这个网络内的主机地址，CIDR使得前缀可变长。
+ NAT：网络地址转换协议。属于不同局域网的主机可以使用相同的IP地址，从一定程度上解决了IP资源枯竭的问题，然而主机在局域网中使用的 IP 地址是不能在公网中使用的，当局域网主机想要与公网进行通信时， NAT 方法可以将该主机 IP 地址转换成全球 IP 地址。该协议能够有效解决 IP 地址不足的问题。
+ IPv6:作为接替 IPv4 的下一代互联网协议，其可以实现 2 的 128 次方个地址。

### 4. 路由器的分组转发流程

1. 从IP数据包提取目的主机的IP地址D，其所在的网络N
2. 判断目的IP地址所在的网络N是否与本路由器直接相连，如果是，则不需要经过其他路由器，直接交付，不是执行3
3. 检查路由表中是否有目的IP地址D的特定主机路由，如果有，则按照路由表跳转到下一跳路由器中，否则执行4
4. 逐条检查路由表，若路由表中有到达网络N的路由，则把数据报传给路由表中所指明的下一跳路由器，否则执行5
5. 若路由表中设置有默认路由，则按默认路由转发到默认路由中，没有执行6
6. 无法找到合适路由，向源主机报错

### 5. 路由器和交换机的区别

+ 交换机：交换机用于局域网，利用主机的MAC地址确定数据转发的目的地址，工作在数据链路层
+ 路由器：路由器根据数据包中的目标IP地址识别不同的网络从而确定数据转发的目的地址，网络号是唯一的，路由器根据路由选择协议和路由表信息从而确定数据的转发路径，直到到达目的网络，它工作于网络层。

### 6. ICMP协议概念/作用

ICMP（Internet Control Message Protocol）是因特网控制报文协议，主要实现IP协议中未实现的部分功能，是一种网络层协议。该协议并不传输数据，而是传递控制信息来辅助网络层通信。其主要功能是用来验证网络是否畅通（确认接收方能否成功接收到数据包）以及辅助IP协议实现可靠传输（如果发生IP丢包，ICMP会通知发送方IP数据包被丢弃的原因，之后发送方会进行相应的处理）

### 7. ICMP的应用

#### 7.1 ping

Ping（Packet Internet Groper）即因特网包探测器。是一种工作在网络层的服务命令，主要用于测试网络连接量。本地主机通过向目的主机发送ICMP Echo请求报文，目的主机接收到之后会发送Echo响应报文，Ping会根据时间和成功响应的次数估算出数据包往返时间以及丢包率从而推断网络是否通畅、运行是否正常等。

#### 7.2 TraceRoute

TraceRoute 是 ICMP 的另一个应用，其主要用来跟踪一个分组从源点耗费最少 TTL 到达目的地的路径。TraceRoute 通过逐渐增大 TTL 值并重复发送数据报来实现其功能，首先，TraceRoute 会发送一个 TTL 为 1 的 IP 数据报到目的地，当路径上的第一个路由器收到这个数据报时，它将 TTL 的值减 1，此时 TTL = 0，所以路由器会将这个数据报丢掉，并返回一个差错报告报文，之后源主机会接着发送一个 TTL 为 2 的数据报，并重复此过程，直到数据报能够刚好到达目的主机。此时 TTL = 0，因此目的主机要向源主机发送 ICMP 终点不可达差错报告报文，之后源主机便知道了到达目的主机所经过的路由器 IP 地址以及到达每个路由器的往返时间。

### 8. 两台电脑ping不同的问题

1. 网络是否正常连接，网卡驱动是否正确安装
2. 局域网设置问题，IP地址是否正确设置
3. 看是否被防火墙阻拦（有些设置中防火墙会对 ICMP 报文进行过滤），如果是的话，尝试关闭防火墙 。
4. 看是否被第三方软件拦截。
5. 两台设备间的网络延迟是否过大（例如路由设置不合理），导致 ICMP 报文无法在规定的时间内收到。

### 9. ARP地址解析协议的原理和地址解析过程

ARP（Address Resolution Protocol）是地址解析协议的缩写，该协议提供根据IP地址获取物理地址的功能，它工作在数据链路层，在网络层和物理层之间进行联系，同时向上层提供服务。当通过以太网发送IP数据包时，需要先封装32位的IP地址和48位MAC地址，在局域网中两台主机进行通信时需要依靠各自的物理地址进行标识，但由于发送方只知道IP地址，不知道其MAC地址，因此需要地址解析协议。ARP协议的解析过程：

1. 首先，每个主机都会在自己的ARP缓冲区中建立一个ARP表，以表示IP地址和MAC地址之间的对应关系
2. 当源主机要发送数据时，首先检查ARP列表中是否有IP地址对应的目的主机MAC地址，如果存在，则可以直接发送数据，否则就向同一子网的所有主机发送ARP数据包，该数据包包括源主机的IP地址、MAC地址和目的主机的IP地址。
3. 当本网络中的所有主机收到该 ARP 数据包时，首先检查数据包中的 目的 主机IP 地址是否是自己的 IP 地址，如果不是，则忽略该数据包，如果是，则首先从数据包中取出源主机的 IP 和 MAC 地址写入到 ARP 列表中，如果已经存在，则覆盖，然后将自己的 MAC 地址写入 ARP 响应包中，告诉源主机自己是它想要找的 MAC 地址。
4. 源主机收到 ARP 响应包后。将目的主机的 IP 和 MAC 地址写入 ARP 列表，并利用此信息发送数据。如果源主机一直没有收到 ARP 响应数据包，表示 ARP 查询失败

### 10. 网络地址转换NAT

NAT（Network Address Translation），即网络地址转换，它是一种把内部私有网络地址翻译成公有网络IP地址的技术，该技术不仅能解决IP地址不足的问题，还能够隐藏和保护网络内部主机，避免来自外部网络的攻击。

NAT的实现方式：

1. 静态转换：内部私有 IP 地址和公有 IP 地址是一对一的关系，并且不会发生改变。通过静态转换，可以实现外部网络对内部网络特定设备的访问，这种方式原理简单，但当某一共有 IP 地址被占用时，跟这个 IP 绑定的内部主机将无法访问 Internet。
2. 动态转换：采用动态转换的方式时，私有 IP 地址每次转化成的公有 IP 地址是不唯一的。当私有 IP 地址被授权访问 Internet 时会被随机转换成一个合法的公有 IP 地址。当 ISP 通过的合法 IP 地址数量略少于网络内部计算机数量时，可以采用这种方式。
3. 端口多路复用：该方式将外出数据包的源端口进行端口转换，通过端口多路复用的方式，实现内部网络所有主机共享一个合法的外部 IP 地址进行 Internet 访问，从而最大限度地节约 IP 地址资源。同时，该方案可以隐藏内部网络中的主机，从而有效避免来自 Internet 的攻击。

### 11. TTL是什么，有什么作用

TTL 是指生存时间，简单来说，它表示了数据包在网络中的时间。每经过一个路由器后 TTL 就减一，这样 TTL 最终会减为 0 ，当 TTL 为 0 时，则将数据包丢弃。

通过设置 TTL 可以避免这两个路由器之间形成环导致数据包在环路上死转的情况，由于有了 TTL ，当 TTL 为 0 时，数据包就会被抛弃。

### 12. 运输层协议和网络层协议的区别

网络层协议负责提供主机间的逻辑通信；运输层协议负责提供进程间的逻辑通信。

### 13. IP报文

目标地址、源地址、检验和，版本号、首部长度、总长度、上层协议、TTL、标识（分片重组）标志（3bit，分片信息）保留字段。

1. 版本号、首部长度、服务类型（质量，8）、数据包长度（16）
2. 标识（16）、标志（3）保留字段
3. TTL、上层协议、检验和
4. 源IP地址
5. 目的IP地址
6. 选项
7. 数据

### 14. 保留/私有IP地址

私有：

- A类 10.0.0.0 ~ 10.255.255.255（10/8）
- B类 172.16.0.0 ~ 172.31.255.255（172.16/12）
- C类 192.168.0.0 ~ 192.168.255.255（192.168/16） 包含在这个范围内的IP地址都属于私有IP，在此之外的IP称为全局IP。

保留（常见）：

+ 0.0.0.0/8 This host is on network
+ 127.0.0.0/8 LoopBack 凡是以`127`开头的**IP地址**，都是**回环地址（Loop back address）**，其所在的回环接口一般被理解为虚拟网卡，并不是真正的路由器接口。正常的`数据包`会从`IP层`进入`链路层`，然后发送到`网络`上；而给`回环地址`发送`数据包`，`数据包`会直接被发送主机的`IP层`获取，后面就没有`链路层`他们啥事了。
+ 255.255.255.255/32 Limited Broadcast  传播范围非常有限，到了广播域的边界（**网关**）会自动终结
+ 169.254.X.X是保留地址。如果你的IP地址是自动获取IP地址，而你在网络上又没有找到可用的DHCP服务器。就会得到其中一个IP。

## 五、数据链路层

### 1. MAC地址和IP地址有什么区别

- MAC 地址是数据链路层和物理层使用的地址，是写在网卡上的物理地址。MAC 地址用来定义网络设备的位置。
- IP 地址是网络层和以上各层使用的地址，是一种逻辑地址。IP 地址用来区别网络上的计算机。

### 2. 为什么有了 MAC 地址还需要 IP 地址

如果我们只使用 MAC 地址进行寻址的话，我们需要路由器记住每个 MAC 地址属于哪一个子网，不然每一次路由器收到数据包时都要满世界寻找目的 MAC 地址。而我们知道 MAC 地址的长度为 48 位，也就是说最多总共有 2 的 48 次方个 MAC 地址，这就意味着每个路由器需要 256 T 的内存，这显然是不现实的

和 MAC 地址不同，IP 地址是和地域相关的，在一个子网中的设备，我们给其分配的 IP 地址前缀都是一样的，这样路由器就能根据 IP 地址的前缀知道这个设备属于哪个子网，剩下的寻址就交给子网内部实现，从而大大减少了路由器所需要的内存。

### 3. 为什么有了 IP 地址还需要 MAC 地址

只有当设备连入网络时，才能根据他进入了哪个子网来为其分配 IP 地址，在设备还没有 IP 地址的时候或者在分配 IP 地址的过程中，我们需要 MAC 地址来区分不同的设备。

### 4. 私网地址和公网地址之间进行转换：同一个局域网内的两个私网地址，经过转换之后外面看到的一样吗

当采用静态或者动态转换时，由于一个私网 IP 地址对应一个公网地址，因此经过转换之后的公网 IP 地址是不同的；而采用端口复用方式的话，在一个子网中的所有地址都采用一个公网地址，但是使用的端口是不同的。

### 六、 计算机网络中的安全

### 1. 安全攻击有哪些

网络安全攻击主要分为两类：主动攻击和被动攻击

+ 被动攻击：攻击者窃听和监听数据传输，从而获取到传输的数据信息，被动攻击主要有两种形式：消息内容泄露攻击和流量分析攻击。由于攻击者并没有修改数据，使得这种攻击类型是很难被检测到的。
+ 主动攻击：攻击者修改传输的数据流或者故意添加错误的数据流，例如假冒用户身份从而得到一些权限，进行权限攻击，除此之外，还有重放、改写和拒绝服务等主动攻击的方式。

### 2. ARP攻击

在ARP解析过程中，局域网上的任何一台主机如果接收到一个ARP应答报文，并不会去检测这个报文的真实性，而是直接记入自己ARP缓存表中，并且这个ARP缓存表是可以被更改的，当表中的某一列长时间不使用时就会被删除。ARP攻击就是利用了这一点，不断的发送ARP报文，将源MAC地址改为自己的MAC地址，而源IP地址改为自己的IP地址，通过不断发送这些伪造的 ARP 报文，让网络内部的所有主机和网关的 ARP 表中被攻击者的 IP 地址所对应的 MAC 地址为攻击者的 MAC 地址。这样所有发送给被攻击者的信息都会发送到攻击者的主机上，从而产生 ARP 欺骗。通常可以把 ARP 欺骗分为以下几种：

1. 洪泛攻击

   攻击者恶意向局域网中的网关、路由器和交换机等发送大量 ARP 报文，设备的 CPU 忙于处理 ARP 协议，而导致难以响应正常的服务请求。其表现通常为：网络中断或者网速很慢。

2. 欺骗主机

   这种攻击方式也叫仿冒网关攻击。攻击者通过 ARP 欺骗使得网络内部被攻击主机发送给网关的信息实际上都发送给了攻击者，主机更新的 ARP 表中对应的 MAC 地址为攻击者的 MAC。当用户主机向网关发送重要信息使，该攻击方式使得用户的数据存在被窃取的风险。

3. 欺骗网关

   该攻击方式和欺骗主机的攻击方式类似，不过这种攻击的欺骗对象是局域网的网关，当局域网中的主机向网关发送数据时，网关会把数据发送给攻击者，这样攻击者就会源源不断地获得局域网中用户的信息。该攻击方式同样会造成用户数据外泄。

4. 中间人攻击

   攻击者同时欺骗网关和主机，局域网的网关和主机发送的数据最后都会到达攻击者这边。这样，网关和用户的数据就会泄露。

5. IP地址冲突

   攻击者对局域网中的主机进行扫描，然后根据物理主机的 MAC 地址进行攻击，导致局域网内的主机产生 IP 冲突，使得用户的网络无法正常使用。

### 3. 对称加密（AES）和非对称（RSA）的区别，非对称加密有哪些

+ 加密解密过程不同：对称加密和解密过程使用同一个密钥；非对称加密中加密和解密采用公钥和私钥两个密钥，一般使用公钥进行加密，使用私钥进行解密。
+ 加密解密速度不同：对称加密和解密速度较快，当数据量比较大时适合使用；非对称加密和解密时间较长，速度相对较慢，适合少量数据传输的场景。
+ 传输的安全性不同：采用对称加密方式进行通信时，收发双方在数据传送前需要协定好密钥，而这个密钥还有可能被第三方窃听到的，一旦密钥泄漏，之后的通信就完全暴漏给攻击者了；非对称加密采用公钥加密和私钥解密的方式，其中私钥是基于不同的算法生成的随机数，公钥可以通过私钥通过一定的算法推导得出，并且私钥到公钥的推导过程是不可逆的，也就是说公钥无法反推导出私钥，即使攻击者窃听到传输的公钥，也无法正确解出数据，所以安全性较高。

### 4. DDoS 有哪些，如何防范

DDoS 为分布式拒绝服务攻击，是指处于不同位置的多个攻击者同时向一个或数个目标发动攻击，或者一个攻击者控制了不同位置上的多台机器并利用这些机器对受害者同时实施攻击。和单一的 DoS 攻击相比，DDoS 是借助数百台或者数千台已被入侵并添加了攻击进程的主机一起发起网络攻击。

DDoS 攻击主要有两种形式：流量攻击和资源耗尽攻击。前者主要针对网络带宽，攻击者和已受害主机同时发起大量攻击导致网络带宽被阻塞，从而淹没合法的网络数据包；后者主要针对服务器进行攻击，大量的攻击包会使得服务器资源耗尽或者 CPU 被内核应用程序占满从而无法提供网络服务。

SYN FLOOD, 

DRDOS:黑客冒充了被攻击主机。黑客发送请求包所用的软件是可以伪造源地址的，接到伪造数据包的主机会根据源地址把回应发出去，这当然就是被攻击主机的地址。黑客同时还会把发送请求包的时间间隔减小，这样在短时间能发出大量的请求包，使被攻击主机接到从被欺骗计算机那里传来的洪水般的回应，就像遭到了DDoS攻击导致系统崩溃

HTTP FLOOD:攻击者通过代理或僵尸主机向目标服务器发起大量的HTTP报文，请求涉及数据库操作的URI（Universal Resource Identifier）或其它消耗系统资源的URI，造成服务器资源耗尽，无法响应正常请求。
