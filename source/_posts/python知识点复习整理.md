---
title: python知识点复习整理
date: 2021-03-10 18:46:53
tags:
    - python3
    - 基础知识
categories:
    - 计算机基础知识
    - python3
---
### 1. 垃圾回收机制

#### 1.1 对象共用

+ 小整数[-5, 257)和单个字符，共用对象，常驻内存
+ 单个单词不可修改，默认开启intern机制，共用对象，引用计数为0时销毁
+ 字符串（含有空格），大整数，不可修改，没开启intern机制，不共用对象，引用计数为0时销毁

#### 1.2 垃圾回收

1. 引用计数

   python里每一个东西都是对象，它们的核心就是一个结构体：`PyObject`

   ```c
   typedef struct_object {
       int ob_refcnt;
       struct_typeobject *ob_type;
   } PyObject;
   ```

   + 优点：简单、实时性（一旦没有引用内存直接释放，将处理回收内存的时间分摊到平时）
   + 缺点：维护引用计数耗费资源，循环引用问题（容器对象）

2. 标记-清除（对活动对象打上标记，清除没有标记的对象）

   + 零代链表：将所有对象放到一个双向链表（方便插入删除）中，这些对象称为零代。
   + 循环遍历链表，如果被本链表内的对象引用，则自身的被引用数-1，如果被引用数为0，则出发引用计数回收条件，被回收
   + 未被回收的对象升级为1代
   + 当一代列表越来越多，触发gc阈值，对以及链表进行标记清除操作，将剩下活跃对象升级为2代

除了到达阈值外，还可以手动调用gc.collect()或者等python虚拟机退出

### 2. 迭代器与生成器

当需要扫描内存中放不下的数据集时，我们需要一种惰性获取数据项的方式，即按需要一次获取一个数据项。

#### 区别

+ 迭代器用于从集合中取出数据
+ 生成器用于生成数据

#### 迭代器

迭代器有基本的next()方法和iter()方法

+ next():返回后续元素，没有后续元素时抛出异常。
+ iter():返回一个迭代器对象，可以通过对其调用next()方法返回下一个

```python
>>> list=[1,2,3,4]
>>> it = iter(list)    # 创建迭代器对象
>>> print (next(it))   # 输出迭代器的下一个元素
1
>>> print (next(it))
2
>>>
```

把一个类作为迭代器需要在类中实现两个方法 ____iter____()和____next____()方法

StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况

#### 生成器

使用了 yield 的函数被称为生成器（generator）。生成器是一个返回迭代器的函数，只能用于迭代操作，更简单点理解生成器就是一个迭代器。

```python
import sys
 
def fibonacci(n): # 生成器函数 - 斐波那契
    a, b, counter = 0, 1, 0
    while True:
        if (counter > n): 
            return
        yield a
        a, b = b, a + b
        counter += 1
f = fibonacci(10) # f 是一个迭代器，由生成器返回生成
 
while True:
    try:
        print (next(f), end=" ")
    except StopIteration:
        sys.exit()
```



### 3. 装饰器

+ 增强函数功能的函数。（函数嵌套（内层+外层），返回函数（外层返回内层，内层添加功能+执行函数），函数作为参数（调用外层函数））

```python
def decorator_name(f):
    def decorated(*args, **kwargs):
        if not can_run:
            return "Function will not run"
        return f(*args, **kwargs)
    return decorated
 
@decorator_name
def func():
    return("Function is running")
```

+ 装饰器可以传参，也可以不传参

```python
def login(text):
  def decorator(func):
      def wrapper(*args, **kwargs):
          if not can_run:
              return "Function will not run"
          return f(*args, **kwargs)
      return wrapper
 		return decorator
```

+ 用途

  + 引用日志
  + 函数执行时间计算
  + 执行函数之前的预备处理
  + 执行函数之后的清理
  + 权限校检
  + 缓存

+ 内置装饰器

  + @property 将方法作为属性

    ```python
    @property
    def x(self): ...
    
    # 等同于
    
    def x(self): ...
    x = property(x)
    ```

    

  + @staticmethod：静态方法，不需要实例化，直接通过类名就可以实现调用。不需要表示自身对象的self和自身类的cls参数(这两个参数都不需要添加)

  + @classmethod：类方法，不需要实例化，直接通过类名就可以实现调用。不需要self参数，但第一个参数需要是表示自身类的cls参数。

### 4. 全局解释器锁（Global Interpreter Lock， GIL）

python代码执行有Python虚拟机控制。在解释器中只有一个线程在执行，即任意时刻只有一个线程在解释器中运行。对Python虚拟机的访问有全局解释器锁来控制。

在多线程环境中，Python虚拟机按照如下方式运行：

1. 设置GIL
2. 切换到一个线程去运行
3. 运行：指定数量的字节码指令或线程主动让出控制
4. 线程睡眠
5. 解锁GIL
6. 重复上述步骤

- 因为GIL的存在，只有IO Bound场景下得多线程会得到较好的性能
- 如果对并行计算性能较高的程序可以考虑把核心部分也成C模块，或者索性用其他语言实现
- GIL在较长一段时间内将会继续存在，但是会不断对其进行改进
- 任何Python线程执行前，必须先获得GIL锁，然后，每执行n条字节码，解释器就自动释放GIL锁，让别的线程有机会执行。这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核。

### 5. 内存管理机制

1. 0层是C的malloc、free管理内存
2. 1层是python的内存分配
3. 2层是对象的内存分配（内存池）
4. 3层是对象缓冲池

python分大内存和小内存，对象小于256k时由该层分配，大于时由malloc进行分配

### 6. 对象引用

1. 变量不是盒子，应该把变量视作便利贴
2. 标识（id)，相等性(is, ==)和别名(id相同)
   1. is运算符比==速度快，因为不能重载，所以python不用寻找并调用特殊方法，直接比较两个整数id。
   2. 元组的相对不可变性。
3. 默认作浅复制。
   1. 构造方法或[:]作的是浅复制（即复制了最外层容器，副本中的元素是源容器中元素的引用。
   2. 深复制用deepcopy，浅复制copy
4. 函数的参数作为引用时
   1. 不要使用可变类型作为参数的默认值，通常使用None作为接受可变值参数的默认值。没有初始化该参数的类实例会共享该初始值。根源问题是，默认值在定义函数时计算，因此默认值变成了函数对象的属性。因此如果默认值是可变对象，而且修改了它的值，那么后续的函数调用都会受到影响。
   2. 防御可变参数（在处理过程中谨慎修改可变参数，可创建副本）

```python
def outer(l = []):
    l.append(1)
    print(l)

outer() # [1]
outer() # [1, 1]
outer() # [1, 1, 1]
```

### 7. 方法解析顺序（MRO， Method Resolution Order）多继承查找规则

C3算法最早提出用于Lisp，应用到Python中是为了解决原来深度优先搜索不满足本地优先级、单调性的问题。

本地优先级：声明父类的顺序C(A, B)，访问父类时应该分局声明顺序优先查找A类然后是B类

按顺序找到哪个用哪个

单调性：如果在C的解析顺序中呢，A在B前面，那么C的所有子类都必须是这个顺序



子类永远在父类前面

如果有多个父类，会根据它们在列表中的顺序被检查

如果对下一个类存在两个合法的选择，选择第一个父类

```c
 mro(Child(Base1，Base2)) = [ Child ] + merge( mro(Base1), mro(Base2),  [ Base1, Base2] )
 （其中Child继承自Base1, Base2）
```

### 8. 变量作用域

```
L = Local     局部作用域
E = Enclosing 嵌套作用域
N = nonlocal  只作用于嵌套作用域，而且只是作用在函数里面
G = global    全局作用域
B = Built-in  内置作用域
```

python引用变量的顺序： 当前作用域局部变量->外层作用域变量->当前模块中的全局变量->python内置变量.

### 9. 一切皆对象

#### 函数和类也是对象

1. 赋值给一个变量
2. 可以添加到集合对象中
3. 可以作为参数传递给函数
4. 可以作为函数的返回值

#### Type、Object、 Class

+ 所有内置类都是由type创建出来的对象（包括type 和Object）
+ object是最顶层基类（type继承自Object）

#### 对象的特征

+ 身份（id），对象在内存中的地址
+ 类型（type）实例化对象的类型
+ 值

### 10. 元类

元类用来创建类，是类的类。type实际上是一个元类。

一个类在实例化的时候：

1. 触发元类中的`__call__`方法
2. 通过`__new__`产生一个空对象
3. 通过`__init__`初始化这个对象
4. 返回

### 11. PEP8规范

1. 缩进4个空格
2. 行的最大字符数限制为79
3. 空行
   1. 顶层函数和类的定义，前后用两个空行隔开
   2. 类里的方法定义用一个空行隔开
4. imports 导入分组，加入空行
5. Comments注释、块注释、行注释
6. 字符串文档
7. 命名规则（类名首字母大写，函数名小写）

### 12. 对python的理解

- python是一种解释性语言，与C语言及其衍生语言不同，Python运行之前不需要编译
- python是动态类型的语言，声明变量时，不需要说明变量的类型
- 非常适合面向对象编程（OOP），没有访问说明符__x(约定为私有), _x(约定为保护)
- 函数是第一类对象（与其他对象具有相同地位，区别于过程），可以被指定给变量，返回函数类型，可以赋值给变量、存储在容器中、作为参数、嵌套、作为返回值。并且当对象实现__call__方法后，也可以被调用。
- Python代码编写快，但是运行慢，Python允许编写C语言的扩展以加快速度