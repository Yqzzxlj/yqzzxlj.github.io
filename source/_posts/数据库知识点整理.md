---
title: 数据库知识点整理
date: 2021-03-04 22:51:54
tags:
    - 数据库原理
    - 基础知识
categories:
    - 计算机基础知识
    - 数据库原理
---

## 一、事务

### 1. 什么是事务？4特征

事务是一组原子性的SQL语句，要不全部执行成功，要不全部执行失败。

ACID：

+ A（Atomicity）原子性：一个事务必须被视为一个不可分割的最小单元，整个事务的所有操作要不全部执行，要不全部回滚，对于一个事务来说不可能只执行部分操作。回滚可以通过回滚日志来实现，回滚日志记录着事务执行的修改操作，回滚时反向执行。
+ C（Consistently）一致性：数据库总是从一个一致性状态转移到另一个一致性状态。当执行某个事务中途出现错误时，因为没有提交，因此不会保存到服务器中。在一致性状态下，所有事务对一个数据的读取结果都是相同的。
+ I（Isolation）隔离性：一个事务提交之前所做的修改，其他事务是看不到的。
+ D（Durability）持久性：一旦事务提交，他做的修改就会永远保存在数据库中。即使系统崩溃事务执行结果也不能丢失，使用重做日志来保障持久性。

### 2. 隔离级别

1. 未提交读：即使事务没有提交，对于其他事务也是可见的，事务可以读取未提交的数据，成为脏读。
2. 提交读：大部分数据库都是采用这个作为隔离级别（MYSQL不是），一个事务开始时，只能看到已经提交的事务。这个隔离级别也叫做不可重复读，因为两次同样的查询，可能会得到不同的结果。
3. 可重复读：该级别保证了多次查询结果一致。但是不能解决幻读问题，当一个事务在读取某个范围内的记录的时候，另外一个事务在这个范围内插入了新的数据，当第一个事务在一次读取时，就会产生幻行。通过多版本控制MVCC解决这个问题，MYSQL默认隔离级别
4. 可串行化：通过强制事务串行执行，避免了幻读的问题。会在每一行数据加锁，会导致超时和锁争用的问题。

### 3. 隔离级别的实现

1. 锁：通过封锁来保证事务的可串行化。通过共享、排他锁及两阶段封锁协议保证串行化下的并发读
2. 时间戳：为每一个事务分配一个时间戳，系统维护两个时间戳来保证冲突情况下按照顺序访问数据
3. 多版本和快照隔离：快照隔离中，我们可以想象每个事务开始时尤其是自身的数据库版本或快照，他从这个私有的版本中读取数据，因为和其他事务的更新隔离。事务的更新只在私有数据库中进行，只有提交时才将信息保存，写入数据库。

## 二、封锁

### 1. 封锁的粒度

MySQL中提供了两种封锁粒度，行级锁和表级锁。

应当只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，放生锁争用的可能就越小，系统的并发程度就越高。但是加锁需要消耗资源，锁的各种操作（获取锁、释放锁、检查锁的状态）都会增加系统开销，因此封锁粒度越小，系统开销越大。

所以选择封锁粒度时，应该在锁粒度和系统开销之间作出权衡。

### 2. 封锁类型

#### 2.1 读写锁

+ 互斥锁（X锁），又称写锁。一个事务对数据加了X锁，就可以对数据进行读取和更新，加锁期间其他事务不能对数据加任何锁。
+ 共享锁（S锁），又称读锁。一个事务对数据加了S锁，就可以对数据进行读取，但是不能更新，加锁期间其他事务能对数据加S锁，但是不能加X锁。

#### 2.2 意向锁

使用意向锁可以更容易的支持多粒度封锁。在存在行级锁和表级锁的情况下，事务想要加表锁就必须检查是否有其他事务对表或表中的行加了锁，这是非常耗时的。

意向锁在原来的X/S锁之上引入了IX/IS，IX/IS都是表锁，用来表示一个事务想要在表中的某个数据行上加X锁或S锁

+ 一个事务在获取某个数据行的S锁之前，必须先获得表的IS锁或着级别强的锁。
+ 一个事务在获取某个数据行的X锁之前，必须获得表的IX锁。

### 3. 封锁协议

#### 3.1 三级封锁协议

1. 一级封锁协议：事务T要修改数据A时必须加X锁，直到T结束才释放锁。解决修改丢失
2. 二级封锁协议：在一级的基础上，要求读取数据A时必须加S锁，读取完马上释放S锁。解决读脏数据问题，
3. 三级封锁协议：在二级的基础上，要求读取数据A时必须加S锁，直到事务结束了才能释放S锁。解决不可重复读问题。

#### 3.2 两段锁协议

加锁和解锁分为两个阶段进行：

+ 增长阶段：事务可以获得锁，但是不能释放锁
+ 缩减阶段：事务可以释放锁，但是不能获得新锁

可串行化是指，通过并发控制，使得并发执行的事务结果与某个串行执行的事务结果相同。串行执行的事务互不干扰，不会出现并发一致性问题。事务遵循两段锁协议是保证可串行化调度的充分条件。例如一下操作满足两段锁协议，它是可串行化调度。

#### 3.3 MySQL隐式与显示锁定

MySQL的InnoDB存储引擎采用两段锁协议，会根据隔离级别在需要的时候自动加锁，并且所有的锁都是在同一时刻被释放，这被称为隐式锁定。可用语句进行显示锁定。

## 三、多版本并发控制（MVCC）

### 1. 什么是多版本并发控制？

MVCC（Multi-Version Concurrency Control）是实现隔离级别的一种具体实现方式，用于实现提交读和可重复读两种隔离级别。而未提交读隔离级别总是读取最新的数据行，无需使用MVCC。可串行化隔离级别需要对所有读取的行都加锁，单纯使用MVCC无法实现。

加锁能解决多个事务同时执行时出现的并发一致性，在实际场景中读操作往往多于写操作，因此引入读写锁来避免不必要的加锁操作。而MVCC利用了多版本思想，写操作更新最新的版本快照，而读操作去读旧版本快照，没有互斥关系。

在MVCC中事务的修改操作都会为数据行新增一个版本快照。

### 2. 实现原理

#### 1.版本号

+ 系统版本号SYS_ID:是一个递增的数据，每开始一个新的事务，系统版本号就会递增。
+ 事务版本号TRX_ID:事务开始时系统的版本号。

#### 2. Undo日志

MVCC的多版本指的是多个版本的快照，快照存储在Undo日志中，该日志通过回滚指针ROLL_PTR把一个数据行的所有快照连接起来。INSERT,UPDATE,DELETE操作会创建一个日志，并将事务版本号TRX_ID写入。DELETE可以看成是一个特殊的UPDATE，还会额外将DEL字段设为1。

#### 3. ReadView

MVCC维护了一个ReadView结构，主要包含了当前系统未提交的事务列表TRX_IDs {id1, id2, ...},还有该列表的最小值TRX_ID_MIN与最大值TRX_ID_MAX。

进行SELECT操作时，根据数据行快照的TRX_ID与TRX_ID_MAX，TRX_ID_MIN之间的关系，从而判断数据行是否可用。

+ TRX_ID < TRX_ID_MIN,表示该数据行的快照是在当前所有未提交事务之前进行更改的，因此可以使用。
+ TRX_ID > TRX_ID_MAX,表示该数据行快照是在事务启动之后被更改的，因此不可用。
+ TRX_ID_MIN <= TRX_ID <= TRX_ID_MAX, 需要根据隔离级别进行判断：
  + 提交读：如果TRX_ID在TRX_IDs列表中，表示该数据行快照对应的事务还未提交，则该快照不可用。否则表示已提交，可以使用。
  + 可重复读：都不可以使用。

#### 4. 快照读与当前读

+ 快照读：MVCC的SELECT操作是快照中的数据，不需要进行加锁操作。
+ 当前读：MVCC其他会对数据库进行修改的操作（INSERT、DELETE、UPDATE）需要进行加锁操作，从而读取新的数据。可以看到MVCC并不是完全不加锁，而只是避免了SELECT的加锁操作

### 3. Next-Key Locks

MVCC不能解决幻影读问题，Next-Key Locks 就是为了解决这个问题而存在的。在可重复读隔离级别下，使用MVCC+Next-Key Locks可以解决幻读问题。

#### Record Locks

锁定一个记录上的索引，而不是记录本身。

#### Gap Locks

锁定索引之间的间隙，但是不包含索引本身。

#### Next-Key Locks

它是Record Locks 和Gap Locks的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙。

## 四、数据库的范式

+ 第一范式：1NF是对属性的原子性约束，要求属性(列)具有原子性，不可再分解；(只要是关系型数据库都满足1NF)[属性不可再分]
+ 第二范式：2NF是对记录的惟一性约束，表中的记录是唯一的, 就满足2NF, 通常我们设计一个主键来实现，主键不能包含业务逻辑。（属性完全依赖于主键）[消除对主属性的部份依赖]
+ 第三范式：3NF是对字段冗余性的约束，它要求字段没有冗余。 没有冗余的数据库设计可以做到（例如，存在一个课程表，课程表中有课程号(Cno),课程名(Cname),学分(Ccredit)，那么在学生信息表中就没必要再把课程名，学分再存储到学生表中，这样会造成数据的冗余，第三范式就是属性不依赖与其他非主属性，也就是说，如果存在非主属性对于码的传递函数依赖，则不符合第三范式），但是，没有冗余的数据库未必是最好的数据库，有时为了提高运行效率，就必须降低范式标准，适当保留冗余数据。[消除对主属性的传递依赖]

## 五、SQL与NOSQL的区别

关系型数据库的数据结构是表**结构**，它容易理解，同时易于维护，并且提供了通用的**SQL语言**，使用起来非常方便，学习成本较简单，并且支持多个表的连接查询等复杂的查询。但是由于固定的表结构，**扩展性**比较差，一旦进行系统的升级需要很大的变动。然而非关系数据库的存储机制有很多，如键值对，基于文档的等等，具有很高的灵活性，同时易于扩展，但是它不支持复杂的查询。同时由于数据量的增多，关系型数据库通过表的连接进行**查询效率**很低。

关系型数据库还有一个特点是数据的**一致性**，它的事务遵循ACID的准则。但是在现在的一些应用中，不需要严格的数据一致性和实时性，用户A和用户B看到C的内容的改变可以相差一段时间，因此数据一致性的要求没有那么严谨。同时由于关系型数据库为了满足一致性导致**读写性能**较差，然而现在的应用更多的追求高并发读写要求，因此成为了高并发的瓶颈。（而关系型数据库由于是从**硬盘I/O*）

关系型数据库的优点：
1.容易理解：二维表结构是非常贴近逻辑世界的一个概念，关系模型相对网状、层次等其他模型来说更容易理解
2.使用方便：通用的SQL语言使得操作关系型数据库非常方便
3.易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率

关系型数据库存在的问题
1.网站的用户并发性非常高，往往达到每秒上万次读写请求，对于传统关系型数据库来说，硬盘I/O是一个很大的瓶颈
2.网站每天产生的数据量是巨大的，对于关系型数据库来说，在一张包含海量数据的表中查询，效率是非常低的
3.在基于web的结构当中，数据库是最难进行横向扩展的，当一个应用系统的用户量和访问量与日俱增的时候，数据库却没有办法像web server和app server那样简单的通过添加更多的硬件和服务节点来扩展性能和负载能力。当需要对数据库系统进行升级和扩展时，往往需要停机维护和数据迁移。
4.性能欠佳：在关系型数据库中，导致性能欠佳的最主要原因是多表的关联查询，以及复杂的数据分析类型的复杂SQL报表查询。为了保证数据库的ACID特性，必须尽量按照其要求的范式进行设计，关系型数据库中的表都是存储一个格式化的数据结构。

非关系型数据库优点 1.用户可以根据需要去添加自己需要的字段，为了获取用户的不同信息，不像关系型数据库中，要对多表进行关联查询。仅需要根据id取出相应的value就可以完成查询。 2.适用于SNS(Social Networking Services)中，例如facebook，微博。系统的升级，功能的增加，往往意味着数据结构巨大变动，这一点关系型数据库难以应付，需要新的结构化数据存储。由于不可能用一种数据结构化存储应付所有的新的需求，因此，非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。

非关系型数据库不足：
只适合存储一些较为简单的数据，对于需要进行较复杂查询的数据，关系型数据库显的更为合适。不适合持久存储海量数据

MySQL体积小、速度快、成本低、结构稳定、便于查询，可以保证数据的一致性，但缺乏灵活性。NoSQL高性能、高扩展、高可用，不用局限于固定的结构，减少了时间和空间上的开销，却又很难保证数据一致性。

如果规模和性能比24小时的数据一致性更重要，那NoSQL是一个理想的选择 （NoSQL依赖于BASE模型——基本可用、软状态、最终一致性）。

但如果要保证到“始终一致”，尤其是对于机密信息和财务信息，那么MySQL很可能是最优的选择（MySQL依赖于ACID模型——原子性、一致性、独立性和耐久性）

## 六、索引

+ 单列索引
+ 唯一索引
+ 复合索引（多列）

### 1. MySQL索引

#### 1. B+TREE索引

+ 因为不在需要进行全表扫描，只需要对树进行搜索即可，所以查找速度快很多
+ 因为B+Tree的有序性，所以除了用于查找，还可以用于排序和分组。
+ 可以指定多个列作为索引列，多个索引列共同组成键。
+ 适用于全键值、键值范围和键前缀查找，其中键前缀查找只适用于最左前缀查找。如果不是按照索引列的顺序进行查找，则无法使用索引。
+ InnoDB的B+Tree索引分为主索引和辅助索引。主索引的叶子节点data域记录着完整的数据记录，这种索引方式被称为聚簇索引。因为无法把数据行存放在两个不同的地方，所以一个表只能有一个聚簇索引。
+ 辅助索引的叶子节点的data域记录着主键的值，因此在使用辅助索引进行查找时，需要先查找到主键值，然后再到主索引中进行查找。

#### 2. hash索引

哈希索引以O(1)时间进行查找，但是失去了有序性：

- 无法用于排序与分组
- 只支持精确查找，无法用于部分查找和范围查找。

InnoDB存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在B+Tree索引之上在创建一个哈希索引，这样就让B+Tree索引具有哈希索引的一些优点，比如快速的哈希查找。

#### 3. 索引的优缺点及使用

#### 优点

1. 加快数据检索速度
2. 减少分组中查找和排序用的时间
3. 通过创建唯一性索引，保证数据的唯一性
4. 加速表与表之间的连接

#### 缺点

1. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。
3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。

#### 使用情况

1. 主键自动建立唯一索引
2. 频繁作为查询条件的字段应该创建索引
3. 查询中排序的字段创建索引将大大提高排序的速度（索引就是排序加快速查找
4. 查询中统计或者分组的字段；

#### 不应该使用的情况

1. 频繁更新的字段不适合创建索引，因为每次更新不单单是更新记录，还会更新索引，保存索引文件
2. where条件里用不到的字段，不创建索引；
3. 表记录太少，不需要创建索引；
4. 数据范围小，因此为经常查询的和经常排序的字段建立索引。注意某些数据包含大量重复数据，因此他建立索引就没有太大的效果，例如性别字段，只有男女，不适合建立索引

### 2. 聚簇索引和非聚簇索引的区别

聚簇索引，就是将索引和数据放到一起，找到索引也就找到了数据，我们刚才看到的B+树索引就是一种聚簇索引，而非聚簇索引就是将数据和索引分开，查找时需要先查找到索引，然后通过索引回表找到相应的数据。InnoDB有且只有一个聚簇索引，而MyISAM中都是非聚簇索引。

**非聚簇索引不一定会回表查询**,这涉及到查询语句所要求的字段是否全部命中了索引,如果全部命中了索引,那么就不必再进行回表查询.

### 3.  唯一索引和主码索引的区别

1. 主键不允许空值，唯一索引允许空值
2. 主键只允许一个，唯一索引允许多个
3. 主键产生唯一的聚集索引，唯一索引产生唯一的非聚集索引

### 4. 索引最左前缀匹配问题

联合索引的排序有这么一个原则，从左往右依次比较大小

MySQL会一直向右匹配直到遇到范围查询（>、<、between、like）就停止匹配

我们找到第一个满足条件的人之后，直接向右遍历就可以了，由于索引是有序的，所有满足条件的人都会聚集在一起。

而这种定位到最左边，然后向右遍历寻找，就是我们所说的最左前缀原则。

### 5. hash索引和B+树索引的区别

1. hash索引不能进行排序和范围查询。因为在hash索引中经过hash函数建立索引之后,索引的顺序与原顺序无法保持一致,不能支持范围查询.而B+树的的所有节点皆遵循(左节点小于父节点,右节点大于父节点,多叉树也类似),天然支持范围.
2. hash索引不支持模糊查询和联合索引的最左前缀匹配原则。因此hash函数对于aa和aab是没有相关性。
3. hash函数必须要回表查询。B+树索引可以通过聚集索引或覆盖索引不需要回表。
4. hash索引虽然等值查询快，但是不稳定。如果hash函数造成的碰撞次数较多，效率可能极差。

### 6. 索引的底层实现（B+树，为何不采用红黑树，B树）

不适用红黑树，是因为红黑树需要通过旋转变色维护平衡，维护平衡的效率低，同时B+树可以降低高度，提高查找效率。

不使用B树，是因为
（1）非叶子节点不包含Data,这样每页能存更多的索引，深度比较低，查询速度快
（2）叶子节点包含所有内容,便于全局遍历.

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用B+ Tree作为索引结构，这是因为使用B+树访问磁盘数据有更高的性能。

+ B+树有更低的树高

平衡树的树高`O(h)=O(logdN)O(h)=O(logdN)`,其中d为每个节点的出度。红黑树的出度为2，而B+ Tree的出度一般都非常大，所以红黑树的树高h很明显比B+Tree大非常多。

+ 磁盘访问原理

操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次I/O就能完全载入一个节点。

如果数据不在同一个磁盘块上，那么通常需要移动制动手臂进行寻道，而制动手臂因为其物理结构导致了移动效率低下，从而增加磁盘数据读取时间。B+Tree相对于红黑树有更低的树高，进行寻道的次数与树高成正比，在同一个磁盘块上进行访问只需要很短的磁盘旋转时间，所以B+Tree更适合磁盘数据的读取。

+ 磁盘预读特性

为了减少磁盘IO操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道，并且只需要很短的磁盘旋转时间，速度会非常快。并且可以利用预读特性，相邻的节点也能够被预先载入。

## 七、 优化

### 1. 索引优化

1. 全值匹配
2. 最佳左前缀法则
3. 不要在索引列上做任何操作，比如计算、使用函数、自动或手动进行类型转换，会导致索引失效，从而使查询转向全表扫描
4. 存储引擎不能使用范围条件右边的索引列。
5. 尽量使用覆盖索引（只访问索引的查询（索引列包含查询列）），减少select *语句。
6. mysql在使用不等于（!=或者<>）的时候无法使用索引会导致全表扫描
7. is null，is not null 也无法使用索引。
8. like以通配符开头（like'%aaa'）mysql索引失效会变成全表扫描操作。

### 2. 查询优化

1. 查询缓存
2. 用索引
3. 优化关联查询：确保ON或者USING子句中的列上有索引。确保任何的GROUP BY 和ORDER BY中的表达式只涉及到一个表中的列。
4. 优化COUNT()查询 使用近似值 
5. 优化LIMIT分页 
6. 优化UNION查询：经常需要手工地将WHERE,LIMIT,ORDER BY等子句"下推"到UNION的各个子查询中。除非确实需要服务器消除重复的行，否则就一定要使用UNION ALL，这一点很重要

### 3. 库表结构优化

1. 合适的结构类型
   1. 使用可以存下你的数据的最小的数据类型
   2. 使用简单的数据类型。Int要比varchar类型在mysql处理上简单
   3. 尽可能的使用not null定义字段
2. 表的范式化和反范式化
3. 表的垂直拆分和水平拆分

### 4. 水平拆分与垂直拆分

+ 水平拆分：通过建立结构相同的几张表分别储存数据。它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。

+ 垂直拆分：将经常使用的字段放在一个单独的表中，分割后表记录之间是意义对应的关系。垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

  在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。

### 5. 主从复制

1. 确保数据安全：做数据的热备，作为后备数据库，主数据库服务器故障后，可切换到从数据库继续工作，避免数据的丢失。
2. 提升I/O性能：随着日常生产中业务量越来越大,I/O访问频率越来越高，单机无法满足，此时做多库的存储，有效降低磁盘I/O访问的频率，提高了单个设备的I/O性能。
3. 读写分离，用来解决数据库的**读性能瓶颈**，使数据库能支持更大的并发。主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

- **binlog 线程** ：负责将主服务器上的数据更改写入二进制日志（Binary log）中。
- **I/O 线程** ：负责从主服务器上读取二进制日志，并写入从服务器的重放日志（Replay log）中。
- **SQL 线程** ：负责读取重放日志并重放其中的 SQL 语句。

### 6. doublewrite

https://www.cnblogs.com/geaozhang/p/7241744.html

## 八、存储引擎

### 1. InnoDB

是MySQL默认的事务型存储引擎，只有在需要它不支持的特性时，才考虑使用其他存储引擎。

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking防止幻影读。

主索引是聚簇索引，在索引中保存了数据，从而避免直接读取磁盘，因此对查询性能有很大的提升。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取

### 2. MyISAM

### 3. 比较

- 事务：InnoDB是事务型的，可以使用Commit和Rollback语句。
- 并发：MyISAM只支持表级锁，而InnoDB还支持行级锁。
- 外键：InnoDB支持外键。
- 备份：InnoDB支持在线热备份。
- 崩溃恢复：MyISAM崩溃后发生损坏的概率比InnoDB高很多，而且恢复的速度也很慢。
- 其他特性：MyISAM支持压缩表和空间数据索引。


