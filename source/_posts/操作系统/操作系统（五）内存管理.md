---
title: 操作系统（五）内存管理
date: 2020-10-29 21:15:51
tags: 
    - 操作系统
categories:
    - 计算机基础知识
    - 操作系统
---
主存（RAM）是一件非常重要的资源，不管存贮器有多大，程序大小的增长速度比内存容量的增长速度要快的多。

#### 分层存储器体系（memory hierarchy）

![](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/%E5%AD%98%E5%82%A8%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84.png)

#### 无存储器抽象

将物理内存暴露给进程的缺点：
1. 如果用户程序可以寻址内存的每个字节，他们就可以很容易的破坏操作系统，从而使系统停止运行。
2. 难以运行多个程序（地址冲突）。

## 内存管理

### 目的
更好的支持多道程序并发执行，提高系统性能。进程之间共享的不仅仅是处理机，还有主存储器。如果不对内存进行管理，容易导致内存数据的混乱。（及以上）

### 内存管理功能

+ 内存空间的分配与回收
+ 地址转换：在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址
+ 内存空间的扩充：虚拟存储技术或自动覆盖技术，从逻辑上扩充内存
+ 存储保护：保证各道作业在各自的存储空间内运行，互不干扰

### 程序装入和链接

### 逻辑地址空间与物理地址空间
+ 编译后，每个目标模块都是从0号单元开始编址（逻辑地址），链接程序顺序依次案各个模块的相对地址构成从0号单元开始编址的逻辑地址空间。
+ 物理地址空间指内存中物理单元的集合。通过物理地址在主存中存取数据。
+ 当装入程序将可执行代码装入内存时，必须通过地址转换讲逻辑地址转换成物理地址，这个过程称为地址重定位

### 内存保护
内存分配前，需要保护操作系统不受用户进程的影响，同时保护用户进程不受其他用户进程的影响。
+ 设置上下限寄存器存放主存中的上下限地址判断是否越界
+ 采用重定位寄存器（基址寄存器，存放最小的物理地址值）和界地址寄存器（限长寄存器，存放逻辑地址的最大值）。


## 管理方式

### 连续分配管理方式
1. 单一连续分配：分配到内存固定区域，只适合单任务系统
2. 固定分区分配：分配到内存中不同的固定区域，分区可以相等也可以不相等。内部碎片
3. 动态分区分配：按程序的需要进程动态划分。外部碎片

#### 空闲内存管理

在进行内存动态分配时，操作系统必须对其进行管理。大致上说，有两种监控内存使用的方式
+ 位图（bitmap）：使用位图方法时，内存被划分为分配单元，每个分配单元对应于位图中的一位，0表示空闲，1表示占用（或者相反）。位图的大小取决于内存和分配单元的大小。
+ 位图的分配：找到连续的0。
+ 空闲列表（free lists）：维护一个记录已分配内存段和空闲内存段的链表，链表中的一个节点会包含进程或者是两个进程间的空闲区域。
+ 空闲列表的分配：
    (如果为进程和空闲区维护各自独立的链表，就能集中精力只检查空闲区而不是进程，但这种分配速度的提高的一个不可避免的代价就是增加复杂度和内存释放速度变慢，因为必须将一个回收的段从进程链表中删除并插入空闲区链表)
    1. 首次适配：从头开始扫描，直到找到一个足够大的空闲区
    2. 下次适配：从上次结束的地方开始扫描
    3. 最佳适配：从头到尾扫描，找到能容纳进程的最小空闲区。会产生大量无用的小缓冲区。
    4. 最差适配：总是分配最大的内存区域（不会分裂出小缓冲区）
    5. 快速适配：为常用大小的空闲区维护单独的链表。


### 非连续分配管理方式
非连续分配（分页/分段）允许一个程序分散地装入到不相邻的内存分区中去。

#### 基本分页存储管理方式
内存分为固定的块，按物理结构划分，会有内部碎片

##### 基本概念
1. 进程中的块称为**页**，内存中的块称为**页框**，外存以同样的单位进行划分，称为**块**。进程在执行时需要申请主存空间，就是要为每个页面分配主存中的可用页框。
2. **地址结构** **页号**+**页内偏移量**
3. **页表** 为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建3立一张页表，记录页面在内存中对应的物理块号。页表一般放在内存中。

##### 基本地址变换机构
页式管理中地址空间是一维的。

两个主要问题：
1. 每次访问操作都需要进行逻辑地址到物理地址的转换，**地址转换过程必须足够快，否则访存速度会降低**
2. 每个进程引入了页表，用于存储映射机制，**页表不能太大，否则内存利用率会降低**

##### 具有快表的地址变换机构
若页表全部放在内存中，则存取一条数据或指令至少需要访问两次内存：一次访问页表，确定物理地址，第二次存取数据或指令

**快表/联想寄存器/TLB** 在地址变换机构中的一个具有并行查找能力的高速缓冲存储器。用来存放当前访问的若干页表项，以加速地址变换的过程。主存中的页表称为慢表。

##### 两级页表

一级页号+二级页号+业内偏移

#### 基本分段存储管理方式
内存块的大小不固定，按逻辑结构划分，会有外部碎片

##### 分段
段式管理方式按照用户进程中国呢的自然段划分逻辑空间（段内要求连续，段间不要求连续）

##### 段表
##### 地址变换机构
二维，段名+段内地址
##### 段的共享与保护
当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。

容易实现“共享”和“动态链接”，分页不容易实现。

#### 段页式管理方式
基本分段和基本分页的结合，会有内部碎片。

作业的地址空间首先被分为若干个逻辑段，每一段再被分为若干个大小固定的页。

## 内存扩充

### 覆盖与交换

#### 覆盖
程序运行时，并非任何时候都要访问程序及数据的各个部分，因此可以吧用户空间分成一个固定区和若干个覆盖区。将经常活跃的部分放在固定区，其余部分里即将访问的段放进覆盖区，其他段放在外存。

#### 交换

把处于等待状态的程序从内存移到辅存，把内存空间腾出来（换出）。把准备好竞争CPU运行的程序从辅存移到内存（换入）。

+ 内存紧缩：内存把所有的空闲区尽可能向下移动合并成一个大的空闲区。消耗CPU资源。
+ 增长预留：为堆栈的增长预留出空间

### 虚拟内存


随着软件的不断增大，需要运行的程序往往大到内存无法容纳。应用交换技术并不是很高效（交换几GB的内存）。

虚拟内存使用了外存上的空间来扩充内存的空间，通过一定的换入换出，使得整个系统在逻辑上能够使用一个远远超出其物理内存大小的内存容量。因为虚拟内存技术调换页面时需要访问外存，导致平均访存时间下降，如果使用了不合适的替换算法，则会
大大降低系统性能。
+ 虚拟存储器：对物理存储器的抽象，**允许程序申请大于实际物理存储的内存**，提供一致性的地址空间。基于局部性原理，在程序装入时，可以将程序的一部分装入内存，而将其余部分留在外存，就可以启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统讲所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放要掉入内存的信息。这样，系统好像为用户提供了一个比实际内存大得多的存储器，称为虚拟存储器。
+ 内存管理单元（Memory Management Unit， MMU），MMU把虚拟地址映射为物理内存地址。

#### 局部性原理
+ 时间局部性：如果一条指令被执行或某个数据被访问过，那么不久以后该指令可能再次执行，该数据可能再次被访问
+ 空间局部性：如果某个单元被访问过，那么不久之后它周围的空间也会被访问。


#### 特征：
1. 多次性， 无序在作业时一次性全部装入内存，而是允许呗分成多次调入内存运行
2. 对换性，无需在作业运行时一直常驻内存，允许在作业的运行过程中，进行换进和换出
3. 虚拟性，从逻辑上扩充内存的容量，用户看到的内存容量，远大于实际的内存容量



#### 虚拟内存技术的实现
+ 一定容量的内存和外存
+ 页表机制（或段表机制），作为主要的数据结构
+ 中断机构，当用户程序访问到的部分尚未调入内存，则产生中断
+ 地址变换机构，逻辑地址到物理地址的变换

#### 请求分页管理方式

1. 页表机制
+ 页号
+ 物理块号
+ 状态位P：指示该页是够调入内存
+ 访问字段A：记录本页在一段时间内被访问的次数，或多长时间未被访问
+ 修改位M：标识该页在调入内存后收否被修改过
+ 外存地址：该页在外存上的地址

2. 缺页中断机构
+ 在请求分页系统中，每当要访问的页面不在内存时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。此时应将缺页的进程阻塞（调页完成时唤醒），如果内存中有空闲块则分配一个块，将要调入的页装入该块，并修改页表中相应页表项，若此时内存中没有空闲块，则要淘汰某页。（若被淘汰页在内存期间被修改过，则要将其写回外存）
3. 地址变换机构

![](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/%E8%AF%B7%E6%B1%82%E5%88%86%E9%A1%B5%E4%B8%AD%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E8%BF%87%E7%A8%8B.jpeg)

#### 页面置换算法（决定应该换入哪页换出哪页）

1. 最佳置换算法（OPT）：选择在最长时间内不在被访问的页面换出。**实际上该算法无法使用**
2. 先进先出（FIFO）页面置换算法：淘汰最早进入内存的页面
3. 最近最久未使用（LRU）置换算法：选择最长时间未访问的页面淘汰**需要TLB实现（硬件支持** 双向链表+hash
4. 时钟（CLOCK）（Not Recently Used，NRU）置换算法：循环扫描缓冲区，像时钟的针一样转动。给每一帧关联一个使用位。当缺页错误出现时，首先检查指针指向的页面，如果R位是0就淘汰页面，并把新页面插入，然后表针前移；如果R位是1就清零前移。**和第二次算法性能差不多，花费更少时间，实际使用的算法**
5. 改进的始终置换算法：增加一个修改位。先找r=0,m=0不做修改，再找r=0,m=1,r位置零。如果全部页面都实用过，优先把未修改过的页面换出。**性能不是很高**
6. 第二次机会页面置换算法：在FIFO基础上增加使用位，如果链首使用位是1则清零加入链尾。**相比FIFO性能大大提高**
7. 工作集置换算法，一个进程当前使用的页面的集合称为工作集。
8. 工作集时钟页面置换算法
9. LFU（ Least Frequently Used，最不频繁使用）两个双向链表+hash