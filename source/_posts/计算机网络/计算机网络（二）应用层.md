---
title: 计算机网络（二）应用层
date: 2020-10-29 20:15:42
tags: 
    - 计算机网络
categories:
    - 计算机基础知识
    - 计算机网络
---

##  应用层协议原理

###  网络应用程序体系结构

#### 1.   客户-服务器体系结构
    会出现一台单独的服务器跟不上所有客户请求的情况，需要配备大量主机的数据中心

#### 2.   P2P体系结构
    应用程序在间断连接的主机对之间直接通信，对等方。有自扩展性。
    
    未来P2P应用由于高度非集中式结构，面临安全性、性能和可靠性挑战。

### 进程通信

进行通信的实际上是**进程**，而不是程序。

在两个不同端系统上的进程，通过跨越计算机网络交换报文（message）而通信。


#### 客户和服务器进程
#### 进程与计算机网络之间的接口
    进程通过叫**套接字**的软件接口向网络发送和接受报文。
    套接字也称为应用程序编程接口（Application Programming Interface，API）
#### 进程寻址
    1.  主机的地址（IP地址）
    2.  目的主机中接受指定接受进程的标识符（端口号）。

### 可供应用程序使用的运输服务
    1. 可靠数据传输
    2.  吞吐量
    3. 定时
    4. 安全性
### 因特网提供的运输服务
    1. TCP服务
    2. UDP服务
    3. 因特网运输协议所不提供的服务
        Tcp可以提供可靠的端到端数据传送，并且可以通过SSL加强以提供安全服务。但是吞吐量和定时服务没有被提供。
### 应用层协议

## Web和HTTP

### HTTP概况
超文本传输协议（HyperText Transfer Protocol） HTTP

统一资源定位符（Uniform Resource Locator） URL(网页地址)

统一资源标识符（Uniform Resource Identifier） URI（由某个协议方案标识的资源的定位标识符）

HTTP使用TCP作为它的支撑运输协议。HTTP协议不用担心数据丢失，也不关注TCP从网络的数据丢失和乱序故障中恢复的细节。这是分层体系结构的最大优点。

服务器向客户发送被请求的文件，而不存储任何关于该客户的状态信息，所以HTTP是一个无状态协议（stateless protocol）

### 非持续连接和持续连接
+ 非持续连接
    每个请求/响应对是经过一个**单独**的TCP连接发送

    缺点：
    1.    必须为每个请求的对象建立和维护一个全新的连接。对每个这样的连接，在客户和服务器中都要分配TCP的缓冲区和保持TCP变量。
    2.    每一个对象经受两倍RTT的交付时间，一个RTT用于建立TCP，另一个RTT用于请求和接受一个对象。
+ 持续连接
    每个请求/响应对是经过一个**相同**的TCP连接发送

    对对象的请求可以一个接一个的发出，而不必等待对未决请求的回答。
    
+ HTTP/1.1 中默认保持持久连接，但是1.0版本的HTTP需要设置 connection:keep-live

### HTTP报文格式

#### HTTP请求报文
![HTTP请求报文](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/HTTP%E8%AF%B7%E6%B1%82%E6%8A%A5%E6%96%87.png)

包括请求行、首部行、空行、实体体

HTTP请求报文的第一行叫请求行， 有3个字段：方法字段、URL字段、HTTP版本字段。

使用GET方法是实体体为空，使用POST方法时才使用实体体。

CR（Carriage Return） 回车符
LF（Line Feed） 换行符

#### HTTP响应报文
![HTTP响应报文](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/HTTP%E5%93%8D%E5%BA%94%E6%8A%A5%E6%96%87.png)

包括状态行、首部行、空行、实体体

HTTP响应报文的第一行叫状态行，有3个字段： 协议版本字段、状态码字段、相应状态信息。

实体体部分时报文的主要部分，它包含了所请求的对象。

#### 请求方法

HTTP/1.1 协议中定了 9 种方法来表明Request-URL指定资源的不同的操作方式

1.  OPTIONS 询问支持的方法。返回服务器针对特定资源的HTTP请求方法
2.  HEAD 获得报文首部。向服务器索要与GET请求一致的响应，而响应体不会被返回
3.  GET 获取资源。  向特定资源发出请求（GET可能会被爬虫随意访问）
4.  POST 传输实体主体。 向指定资源提交数据处理的请求（提交表单、上传文件）数据被包含在请求体中。POST可能会导致新建资源或已有资源的修改
5.  PUT 传输文件。 自身不带验证机制，存在安全性问题。向指定资源上传最新内容
6.  DELETE 删除文件。与PUT一样，存在安全性问题。请求服务器删除 REQUEST_URL 所标识的资源
7.  TRACE 追踪路径。回显服务器收到的请求
8.  CONNECT 在与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。主要使用SSL和TLS协议把通信内容加密后将网络隧道传输。
9.  PATCH 局部修改某一资源

当请求的资源不支持请求方法时，服务器返回405（Method Nnt Allowed）

当服务器不认识或不支持方法时，返回501（Not Implement）

##### GET 与 POST的区别
**作用** GET用于获取资源，POST用于传输实体主体

**参数**  GET 和POST 都能使用额外的参数，但是GET的参数以查询字符串的方式出现在URL中，这个过程用户可见。而POST的参数存储在实体主体中。因为URL只支持ASCII码，因此GET参数中文会被编码，空格被编码为%20

**安全** 安全的HTTP方法不会改变服务器状态，可以说是只读的

GET方法安全，POST不是，POST方法传出主题内容，可能是表单数据，服务器可能把其存进数据库中，这样状态就发生了改变。

**幂等性** 幂等性的方法，同样的请求被执行一次和连续执行多次的效果是一样的，服务器状态也是一样的。

所有安全的方法是幂等的，GET、HEAD、PUT、DELETE应该是幂等的。
而post方法不是幂等的。

**其他** GET传输数据量小，因为受URL的限制，但是效率高；POST可以传输大量数据，文件只能通过POST传递。

GET方式只支持ASCII字符，向服务器传输的中文字符可能乱码。post支持标准字符集，可以正确的传递中文字符。

#### 首部行

##### HTTP首部Request

|Header|	解释	|某度首页示例|
|:---:|:---:|:---:|
|Accept	|客户端能够接受的内容类型|	text/html|
|Accept-Encoding|	浏览器可以支持的web服务器返回内容压缩编码类型|	gzip
|Accept-Language|	浏览器可以接受的语言|	zh-CN
|Cache-Control|	指定请求和相应遵循的缓存机制|	max-age=0
|Connection|	表示是否需要持久连接|	keep-alive
|Cookie	HTTP|请求发送时，会把保存在请求域名下的所有cookie值一起发送给web服务器	|键值对
|Host|	请求服务器的域名和端口号|	www.baidu.com
|Upgrade-Insecure-Requests|	浏览器可以处理HTTPS协议|	1
|User-Agent|	发出请求的用户信息|	Mozilla/5.0


##### HTTP首部Response

|Header|	解释	|某度首页示例|
|:---:|:---:|:---:|
|Cache-Control|	告诉所有的缓存机制是否可以缓存及缓存哪种类型|	private
|Connection	|是否保持持久连接|	keep-alive
|Content-Encoding|	返回内容压缩编码类型|	gzip
|Content-type|	返回内容的MIME类型|	text/html charset=utf-8
|Date	|原始服务器消息发出时间	|Wed 03 Oct2018 12:04:45 GMT
|Expires	|响应过期的时间	|Wed 03 Oct2018 12:04:45 GMT
|Server	Web|服务器软件名称|	BWS1.1
|Set-Cookie	|设置浏览器缓存|	BDSVRTM=114; path=/
|Transfer-Encoding	|文件传输编码|	chunked

#### HTTP状态码

状态码的类别
 ![](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/%E7%8A%B6%E6%80%81%E7%A0%81%E7%9A%84%E7%B1%BB%E5%88%AB.jpg)
 
##### 100 Containue：收到了请求的初始部分，请客户端继续
##### 200 Ok: 请求被正常处理
##### 204 No Content： 请求被接受，但是响应报文只有状态行和首部行，不含实体体。
##### 206 Partial Content:客户端进行了范围请求，服务器成功执行了这部分的GET请求
##### 301 Moved Permanently 永久重定向
##### 302 Found 临时重定向，资源被临时移动了。
##### 303 See Other 表示请求对应的资源代表另一个URI，应该使用GET获取资源
##### 304 Not Modified 当客户端发送附带请求时，服务器找到资源但未符合请求（与重定向无关）
##### 307 Temporary Redirect 临时重定向，与302相同。但是301，302不许将POST改为GET，大家并不遵守。307不会从POST变为GET。
##### 400 Bad Request 请求报文中存在语法错误。
##### 401 Unauthorized 请求需要进行认证
##### 403 Forbidden 请求被服务器拒绝
##### 404 Not Found 服务器无法找到对应资源
##### 405 Method Not Allowed 请求中带有不支持的方法
##### 500 Internet Server Error 服务器内部错误
##### 501 Not Implemented 服务器不认识或不支持对应的请求方法
##### 502 Bad GateWay 代理或网关服务器从下一条链路收到了伪响应
##### 503 Server Unavailable 服务器正忙
##### 504 GateWay Timeout 一个代理网关等待另一服务器超时了

### cookie

HTTP服务器时无状态的，但是一个Web站点通常希望能够识别用户，（限制访问、用户身份）为此使用cookie技术。

网络服务器用HTTP头向客户端发送cookies, 在客户终端，浏览器解析这些cookies 并将它们保存为一个本地文件，它们在会在下一次对服务器的请求时附上这些cookies。

cookie技术的4个组件：
1.  HTTP响应报文中的cookie首部行
2.  HTTP请求报文中的cookie首部行
3.  用户端系统中保留有一个cookie文件，由浏览器进行管理。
4.  位于Web站点的后端数据库

过期时间：
+ 会话cookie： 若不设置过期时间，表示这个cookie的生命周期未浏览器会话期间，若关闭浏览器，cookie就会消失。这种生命周期的cookie被称为会话cookie
+ 持久cookie： 若设置了过期时间，浏览器会把cookie存储到硬盘上（可以拒绝），关闭后在打开这些cookie仍然有效


### session
session机制是一种服务端的机制，服务器利用一种类似于散列表的结构来保存信息

当程序需要为某个客户端的请求创建session时，服务器检查这个客户端是否包含了一个session标志，称为session_id, 如果检测到说明该客户曾创建过ID，服务器会把这个ID检索出来使用（或者未检测到新建一个），session_id 既不会重复也不容易被找到仿造。

#### session_id的存储
1.  保存这个session_id可以采用cookie，这样交互过程中浏览器可以把这个标志返回给服务器。一般该变量名与session有关，如github的session ID即名为user_session
2.  由于cookie可以被人为的禁止，必须有其他机制保证session_id传回服务器，经常使用的一种方法是URL重写，即直接把session_ID附在URL后面。作为路径的附加信息或查询字符
3.  另一种技术是表单隐藏字段，服务器自动修改表单加入一个隐藏字段，便于传回session_id


### cookie与session的区别
+ #### 存取方式不同
    cookie只能保存ASCII字符，Unicode和二进制数据需要编码，cookie不能直接存取java对象，存储略微复杂的信息较难。
    而session中能够存取任何类型的数据，十分方便。
+ #### 隐私策略不同
    cookie存储在客户端浏览器中，对客户可见，客户端可以窥探甚至修改cookie内容。
    session存储在服务器上，对用户透明，不存在泄漏风险。
    cookie可以像google及百度一样将敏感信息加密后保存，在服务器上进行解密。

+ #### 有效时间不同
    由于session依赖于session_ID的cookie，而session_id的过期时间默认为-1，关闭浏览器即消失。而cookie可以设置长期的保存。
+ #### 服务器压力不同
    由于不从的存储方式，存储在客户点的cookie不会给服务器造成压力，而session由于存在服务器上，对服务器压力较大。
    
+ #### 浏览器支持不同
    cookie需要客户端浏览器的支持，假如客户端禁用或不支持cookie，则会话跟踪会失效
    假如客户端不支持cookie，就需要运用session及URL地址重写。注意，所有用到session的程序url都要进行重写，否则session会话会失效
+ #### 跨域支持不同
    cookie支持跨域名访问，一切以相同后缀的域名均可以访问该cookie，跨域名cookie被广泛应用
    session尽在当前域名有效

### Web缓存

缓存是指代理服务器或客户端本地磁盘内保存的资源副本。

### 条件GET方法

条件GET使缓存器证实他的对象是最新的。
1.  请求报文中使用GET方法
2.  请求报文中包含"If-Modified-Since"首部行

304 Not Modified 告诉缓存器可以继续使用该对象

### HTTP和HTTPS的区别
1.  HTTPS协议需要CA申请证书，需要缴费
2.  HTTP是超文本传输协议，明文传输，HTTPS是SSL加密传输
3.  80 和443
4.  HTTP连接很简单，无状态，HTTPS经过SSL+HTTP协议构建的，加密传输，身份认证
5.  HTTPS耗性能，安全性要求低用HTTP


### CGI（Common Gateway Interface）公共网关接口
CGI 是HTTP 中重要的技术之一，有着不可替代的作用。CGI是一个web服务器的标注接口。通过CGI接口Web服务器就能获取客户端提交的信息转交给服务器端的CGI程序处理，最后结果返回给客户端。

![](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/CGI.png)

CGI规范定义了Web服务器如何向扩展应用程序发送消息，在收到扩展应用程序的信息后又如何进行处理等内容。服务器和客户端之间的通信，是浏览器和服务端web服务器的HTTP通信，所以只需知道浏览器执行哪个CGI程序即可.
## 因特网中的电子邮件

因特网电子邮件系统由3个主要组成部分：**用户代理（user-agent)**、**邮件服务器（mail server)**、**简单邮件传输协议（Simple Mail Transfer Protocol，SMTP）**

### SMTP

25号端口、TCP连接、
传输的三个阶段： 握手、传输、关闭连接。

### 与HTTP的对比
都是TCP连接，持续的HTTP和SMTP都是持续连接。

1. HTTP是一个拉协议，TCP连接由想接受文件的机器发起。SMTP是一个推协议，TCP连接由发送文件的机器发起。
2. SMTP要求报文采用7比特ASCII码格式，如果报文包含了非7比特ASCII字符，必须按照7比特ASCII码进行编码。HTTP数据则不受这种限制。
3. 如何处理一个既包含文本又包含图形的文档。HTTP把每个对象封装到各自的HTTP响应报文中，SMTP则把所有报文对象放在同一个报文之中。


### 邮件报文格式

必须包含From首部行和To首部行。也许Subject首部行

### 邮件访问协议

由于取报文是一个拉操作，而SMTP是一个退协议。所以有邮件访问协议

#### 第三版邮局协议（Post Office Protocol-Version3，POP3）

#### 因特网邮件访问协议（Internet Mail Access Protocol， IMAP）

#### HTTP

## FTP 文件传输协议

FTP使用两个并行的TCP连接来传输数据，一个TCP（21号端口）被称为控制连接，用来传输FTP命令；一个TCP（20号端口）连接称为数据连接用于传输文件数据。

因为在FTP协议内，控制信息是通过一个独立的TCP连接传输，所以我们称FTP的控制信息是**带外传送**的，如果控制信息和数据信息通过同一个TCP传输，则称为带内传送

FTP中控制连接贯穿整个会话，但是数据连接在一个文件开始传输时建立，传输结束后关闭，所以每次传输一个新文件时，都会建立一个数据连接。

FTP需要在整个会话期间，保留用户的状态，也就是将控制连接同用户账户关联起来，同时记录在远程目录树上的操作，这就限制了FTP可以同时维持的会话总数
##  因特网的目录服务： DNS

### DNS提供的服务
主机名到IP地址转换的目录服务。
域名系统：（Domain Name System， DNS）

DNS运行在UDP传输协议之上，使用53号端口

DNS是：1. 一个由分层的DNS服务器实现的分布式数据库。2.   一个使得主机能够查询分布式数据库的应用层协议。

DNS采用分布式的设计方案，因为单一的DNS服务器无法解决单点故障，无法保证通信容量以及无法临近所有的查询主机和维护困难等问题。

**根DNS服务器**：因特网上由13个根DNS服务器，每台服务器是一个冗余的计算机网络以*提供安全性和可靠性

**顶级域DNS服务器**：负责顶级域名如com、org、net、edu等以及各个国家顶级域名的转换。

**权威DNS服务器**：因特网上，具有公共可访问主机的每个组织机构必须提供公共可访问的DNS记录，这些记录将这些主机的名字映射为IP地址。

**本地DNS服务器**：邻近其所在网络的其他主机。当主机发出DNS请求时，请求被发往本地DNS服务器，起着代理的作用。

**递归查询**：从请求主机到本地DNS服务器的查询是递归的，

**迭代查询**：其余都是迭代的

**DNS缓存**每当DNS服务器发出请求后受到回答时，就将回答的内容缓存在自己的主机空间上。注意有效时间
## P2P文件分发
p2p体系结构具有良好的自扩展性。这种扩展性的直接成因是对等方除了是比特的消费者之外还是重新分发者。

### BitTorrent
参与一个特定文件分发的所有对等方的集合被称为一个**洪流**

在一个洪流中的对等方彼此下载等长度的文件**块**

当一个对等方下载文件块的时候，也向其他对等方发送了多个块，一旦某对等方获得了完整文件，就可以自私地离开洪流或者大公无私地留下来继续向其他对等方发送文件。 


P2P文件共享协议，参与一个特定文件分发的所有对等方结合被称为一个洪流（torrent），在一个洪流的对等方彼此下载等长度的文件块，可以随时离开洪流，也可继续向其他对等方上载。每个洪流都有一个追踪器。

Alice加入某洪流时，会在追踪器里进行注册，周期性通知追踪器它仍在洪流中。我们称所有与ALICE成功的创建了一个TCP链接的对等方成为邻近对等方。

洪流随机从参与对等方的结合中选择一个子集，将他们的IP地址发给Alice，Alice维护这张对等方列表，试图与所有对等方建立并行的TCP连接。

Alice周期询问每个邻近对等方（连上的）他们有的文件块列表，她随时知道邻居有哪些文件块

Alice使用最稀缺优先技术，首先请求那些邻居们副本数量最少的块，使该文件块迅速分发，以均衡每个块在洪流中的副本数量

BitTorrent使用一种算法，Alice优先从像她传时速度最快的邻居（4个，每10s修改一次）那里获取文件块。

每过30s，Alice也要随机选择另外一个对等方Bob，向他发送块。若Alice是Bob最快的前四快，Bob也是Alice的前4快，则Bob和Alice互相发送数据。

每过30s换一个新的对象，互相交换数据（一报还一报），为了使对等方能够找到彼此协调的速率上传

### 分布式散列表（DHT）

## 视频流和内容分发网

### 经HTTP的动态适应性流（Dynamic Adaptive Streaming over HTTP，DASH）
在DASH中视频编码为几个不同的版本，每个版本具有不同的比特率，对应于不同的质量水平。

### 内容分发网（Content Distribution Network，CDN ）