---
title: 最长回文子串
date: 2020-03-19 11:51:48
categories: 刷题笔记
---


给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

#### 示例 1

* 输入: "babad"
* 输出: "bab"
* 注意: "aba" 也是一个有效答案。

#### 示例 2

* 输入: "cbbd"
* 输出: "bb"

在leetcode上看到了５种解法，在这里简单写一下。[原答案地址](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/zui-chang-hui-wen-zi-chuan-c-by-gpe3dbjds1/)

<!--more-->
### 1. 暴力法

找到所有可能的子串，判断是不是回文串。

### 2. 最长公共子串

将原字符串翻转，并寻找最长的公共子串，注意子串位置要对应，或者检查子串是不是回文串。
最长公共子串问题。

### 3. 动态规划

找到状态转移方程,和初始状态

``` c++
class Solution {
public:
    string longestPalindrome(string s) {
        int len=s.size();
        if(len==0||len==1)
            return s;
        int start=0;//回文串起始位置
        int max=1;//回文串最大长度
        vector<vector<int>>  dp(len,vector<int>(len));//定义二维动态数组
        for(int i=0;i<len;i++)//初始化状态
        {
            dp[i][i]=1;
            if(i<len-1&&s[i]==s[i+1])
            {
                dp[i][i+1]=1;
                max=2;
                start=i;
            }
        }
        for(int l=3;l<=len;l++)//l表示检索的子串长度，等于3表示先检索长度为3的子串
        {
            for(int i=0;i+l-1<len;i++)
            {
                int j=l+i-1;//终止字符位置
                if(s[i]==s[j]&&dp[i+1][j-1]==1)//状态转移
                {
                    dp[i][j]=1;
                    start=i;
                    max=l;
                }
            }
        }
        return s.substr(start,max);//获取最长回文子串
    }
};

```

### 4. 中心扩展算法

``` c++
class Solution {
public:
    string longestPalindrome(string s) {
        int len=s.size();
        if(len==0||len==1)
            return s;
        int start=0;//记录回文子串起始位置
        int end=0;//记录回文子串终止位置
        int mlen=0;//记录最大回文子串的长度
        for(int i=0;i<len;i++)
        {
            int len1=expendaroundcenter(s,i,i);//一个元素为中心
            int len2=expendaroundcenter(s,i,i+1);//两个元素为中心
            mlen=max(max(len1,len2),mlen);
            if(mlen>end-start+1)
            {
                start=i-(mlen-1)/2;
                end=i+mlen/2;
            }
        }
        return s.substr(start,mlen);
        //该函数的意思是获取从start开始长度为mlen长度的字符串
    }
private:
    int expendaroundcenter(string s,int left,int right)
    //计算以left和right为中心的回文串长度
    {
        int L=left;
        int R=right;
        while(L>=0 && R<s.length() && s[R]==s[L])
        {
            L--;
            R++;
        }
        return R-L-1;
    }
};
```


### 5. Manacher算法

``` c++
class Solution {
public:
    string longestPalindrome(string s) {
       if (s.empty()) return "";
        string manStr = maStr(s);
        // 存以i点为中心时的回文半径
        vector<int> pVec(manStr.size());
        // pR的中心
        int pC = -1;
        // 回文右边界
        int pR = -1;
        int maxLength = INT_MIN;
        int center = -1;
        for (int i = 0; i < manStr.size(); ++i) {
            // 如果i在pR里，可以让pVec[i]直接等于其关于pC对称的点，如果这个值超过了pR,就取pR - i;
            pVec[i] = pR > i ? min(pVec[pC * 2 - i], pR - i) : 1;
            while (i + pVec[i] < manStr.size() && i - pVec[i] > -1) {
                if (manStr[i + pVec[i]] == manStr[i - pVec[i]]) {
                    ++pVec[i];
                } else {
                    break;
                }
            }
            if (i + pVec[i] > pR) {
               pR = i + pVec[i];
               pC = i;
            }
            if (pVec[i] > maxLength) {
                center = pC;
                maxLength = pVec[i];
            }
        }
        int start = (center - maxLength + 1) / 2;
        return s.substr(start, maxLength - 1);
    }
    string maStr(const string& s) {
        string ret(s.size() * 2 + 1, '#');
        for (int i = 0; i < s.size(); ++i) {
            ret[i * 2 + 1] = s[i];
        }
        return ret;
    }
};
```
