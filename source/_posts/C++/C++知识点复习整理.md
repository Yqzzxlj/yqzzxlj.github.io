---
title: C++知识点复习整理
date: 2021-02-26 14:29:12
tags:
    - c++
    - 基础知识
categories:
    - 计算机基础知识
    - c++
---

参考之前的笔记以及该[leetbook](https://leetcode-cn.com/leetbook/read/cpp-interview-highlights)整理。

## 一、编译内存相关

### 1. C++程序编译过程

四个过程：预处理、编译、汇编、链接

1. 预处理：处理以#开头的指令（#define展开， #include递归包含， #if等条件编译指令，过滤注释，添加行号、文件标识名，#pragma保留）
2. 编译：生成汇编代码（词法分析、语法分析、语义分析、源代码优化、代码生成、目标代码优化）
3. 汇编：生成机器指令
4. 链接：把每个模块的源代码独立编译，然后组装起来。（把一些指令对其他符号地址的引用加以修正，包括地址和空间分配、符号决议、和重定位等步骤）。每个目标文件除了拥有自己的数据和二进制代码以外，还提供了3个符号表。未解决符号表、导出符号表、地址重定向表。extern、static、普通变量和函数。
   + 静态链接：编译时期完成，将代码从静态链接库copy到最终的程序中。在程序执行时，这些代码会被装入该进程的虚拟地址空间中。
   + 动态链接：对库函数的链接推迟到运行期。代码被放入动态链接库中，链接程序只是在最终的程序中记录了共享对象的名字等信息。在程序执行时，动态链接库的全部内容会被映射到运行时相应进程的地址空间中。
   + 优缺点：静态链接浪费空间，更新困难，执行时运行速度快。动态链接节省内存，更新方便，但每次执行都需要链接，会有性能损失。

### 2. C++ 内存管理

c++内存分区：栈、堆、静态存储区、常量存储区和代码区

+ 栈：存放局部变量、函数参数、返回地址等。由编译器自动分配和释放
+ 堆：动态申请的内存空间。malloc和free控制内存的分配和释放。如果程序执行结束还没有释放，则操作系统自动回收。
+ 静态存储区：存放全局变量和静态变量。程序运行结束操作系统自动释放
+ 常量存储区：存放常量，不允许修改，程序运行结束自动释放
+ 代码区：存放代码，不允许修改，程序运行结束自动释放

static const 常量应该存在常量区或代码区，编译器会在编译期间进行值替换，所以不能对其进行取地址操作。

### 3. 堆和栈的区别

申请方式（效率）、存放内容、访问效率

1. 申请方式：栈是系统自动分配，剩余空间大于申请空间即申请成功，否则申请失败栈溢出，申请效率高。堆是人为申请，堆分配时沿空闲内存地址链表寻找第一个大于申请空间的节点分配给程序。再将其从链表中删除，之后将剩余空闲节点链接到连表上，申请效率低。
2. 内存连续：栈在内存中是一段地址空间（向低地址扩展），最大容量由系统设置好；堆（向高地址扩展）。受限于计算机系统中有效的虚拟内存，比较大。
3. 存放内容：栈存放的是局部变量、函数参数、返回地址等。堆人为控制。
4. 访问效率：访问堆的一个具体单元需要两次访问内存，一次取得指针，二次取得内容。栈只需要一次。此外，堆的内容被操作系统交换到外存的概率较大。

### 4. 变量的区别

全局变量、局部变量、静态全局变量、静态局部变量的区别

C++变量根据定义的位置的不同，具有不同的作用域：全局作用域、局部作用域、语句作用域、类作用域、命名空间作用域和文件作用域。

从作用域看：

+ 全局变量：具有全局作用域。全局变量只需要在一个源文件中定义，就可以作用于所有的源文件。其他不包含全局变量定义的源文件需要用extern关键字再次声明该全局变量
+ 静态全局变量：具有文件作用域。它与全局变量的区别在于如果程序包含多个源文件的话，它作用于定义它的源文件中，不能作用到其他源文件中。即使两个不同的源文件都定义了相同名字的静态全局变量，也是不同变量。
+ 局部变量：具有局部作用域。在程序运行期间不是一直存在，只有在函数执行期间存在，执行完被销毁。
+ 静态局部变量：具有局部作用域。只被初始化一次，之后一直存在到程序运行结束。

从内存空间看：

+ 静态存储区：全局变量、静态全局变量、静态局部变量
+ 栈：局部变量。

附：

+ 静态变量和全局变量的区别：静态变量用static告知编译器，自己仅在变量的作用范围内可见。
+ 静态变量和栈变量、堆变量的区别：静态变量存储在静态存储区，下次调用时仍是原来的值，而栈变量和堆变量不能保证。

### 5. 对象创建限制在堆或栈

C++类的对象的建立分为两种：静态建立和动态建立。

+ 静态建立：由编译器为对象在栈空间上分配空间，直接调用类的构造函数创造对象。
+ 动态建立：使用new关键字在堆空间上创建对象。底层首先调用operator new()函数，在堆空间上寻找合适的内存并分配；然后调用类的构造函数创建对象。

#### 5.1 限制对象只能创建在堆上

构造函数设为protected，并提供一个public的静态函数来完成构造。

#### 5.2 限制对象只能创建在栈上

将operator new()函数设置为私有。

### 6. 内存对齐

什么是内存对齐？对齐的原则？原因？优点？

#### 6.1 什么是内存对齐

编译器将程序中的每个数据单元安排在字的整数倍的地址指向的内存空间之中。

#### 6.2 内存对齐的原则

> 1. 结构体变量的首地址能够被其最宽基本类型成员大小与对齐基数中的较小者所整除；
> 2. 结构体每个成员相对于结构体首地址的偏移量 （offset） 都是该成员大小与对齐基数中的较小者的整数倍，如有需要 编译器会在成员之间加上填充字节 （internal padding）；
> 3. 结构体的总大小为结构体最宽基本类型成员大小与对齐基数中的较小者的整数倍，如有需要编译器会在最末一个成员之后加上填充字节 （trailing padding）。

#### 6.3 内存对齐的原因

1. 会对CPU的存取效率产生影响：比如有些平台CPU从内存中偶数地址开始读取地址，如果数据其实位置正好为偶数，则1个读取周期就可以读出一个int类型的值，而如果数据地址为奇数，那我们就需要两个读取周期独处数据，并对高地址和低地址进行拼凑，这在读取效率上显然已经落后很多了。
2. 还有其他硬件设备的原因。

### 7. 类的大小

类的大小指类的实例化对象的大小。用sizeof对类型名操作时，结果是该类型的对象的大小。

计算原则：

+ 结构体的内存对齐原则
+ 与普通成员变量有关，与成员函数和静态成员变量无关，因为它们被类的对象共享，不属于那个具体的对象。
+ 虚函数对类的大小有影响，因为虚函数表指针。
+ 虚继承对类的大小有影响，因为虚基表指针。
+ 空类的大小为1，保证不同对象具有不同地址。

### 8. 内存泄漏

由于疏忽或错误导致程序未能释放已不再使用的内存。包括堆内存泄漏和系统资源泄露（scoket，bitmap...)

指针重新复制，类定义不规范。（释放对象数组、基类的析构函数应为虚函数。。。）

### 9. 防止内存泄露的方法

内部封装+智能指针

内存检测工具：建立两个全局表，valid-value和valid-address，检测每个字节对应的值或地址是有有效。

### 10 智能指针

解决动态内存分配时带来的内存泄露以及多次释放同一内存空间提出来的。<memory>

+ shared_ptr:多个指针可以指向同一个对象，当最后一个指针对象离开作用域时，内存自动释放。use_count()查看引用个数，release()释放所有权。
+ unique_ptr:资源只能被一个指针占有，该指针不能拷贝构造和赋值，但可以进行移动构造和移动赋值构造。move()
+ weak_ptr:指shared_ptr指向的对象，解决循环引用问题。

#### 10.1 智能指针的实现

```c++
#include <iostream>
#include <memory>

template <typename T>
class SmartPtr
{
private : 
	T *_ptr;
	size_t *_count;

public:
	SmartPtr(T *ptr = nullptr) : _ptr(ptr)
	{
		if (_ptr)
		{
			_count = new size_t(1);
		}
		else
		{
			_count = new size_t(0);
		}
	}

	~SmartPtr()
	{
		(*this->_count)--;
		if (*this->_count == 0)
		{
			delete this->_ptr;
			delete this->_count;
		}
	}

	SmartPtr(const SmartPtr &ptr) // 拷贝构造：计数 +1
	{
		if (this != &ptr)
		{
			this->_ptr = ptr._ptr;
			this->_count = ptr._count;
			(*this->_count)++;
		}
	}

	SmartPtr &operator=(const SmartPtr &ptr) // 赋值运算符重载 
	{
		if (this->_ptr == ptr._ptr)
		{
			return *this;
		}
		if (this->_ptr) // 将当前的 ptr 指向的原来的空间的计数 -1
		{
			(*this->_count)--;
			if (this->_count == 0)
			{
				delete this->_ptr;
				delete this->_count;
			}
		}
		this->_ptr = ptr._ptr;
		this->_count = ptr._count;
		(*this->_count)++; // 此时 ptr 指向了新赋值的空间，该空间的计数 +1
		return *this;
	}

	T &operator*()
	{
		assert(this->_ptr == nullptr);
		return *(this->_ptr);
	}

	T *operator->()
	{
		assert(this->_ptr == nullptr);
		return this->_ptr;
	}

	size_t use_count()
	{
		return *this->count;
	}
};
```

### 11. 循环引用

两个类中分别定义另一个类的共享指针，两个指针会互相指向对方的内存空间，导致内存无法释放。

使用weak_ptr解决问题。weak_ptr具有非拥有性，使用前先转化为shared_ptr.(项目1中httpdata与timernode)

### 12. float存储机制

32位 1（符号） + 8（指数） + 23（底数）

#### 指数

占用8bit的二进制数，可表示数值范围为0-255。

但是指数可正可负，所以，IEEE规定，此处算出的次方必须减去127才是真正的指数。

所以，float类型的指数可从-126到128

#### 底数

实际是占用24bit的一个值，但是最高位始终为1，所以，最高位省去不存储，在存储中占23bit
科学计数法。

## 二、语言对比

### 1. c++11新特性

#### 1.1 auto类型推导

自动类型推导，编译器在**编译期间**通过**初始值**推导出变量的类型，通过auto定义的变量必须有初始值。

#### 1.2 decltype类型推导

declare type的缩写，和auto一样，在编译期间进行类型推导。从表达式中推断出要定义的变量的类型。

区别：

1. auto根据=右边的初始值推断出变量的类型，decltype根据表达式推断变量的类型，变量的初始值与表达式的值无关
2. auto要求变量必须初始化

#### 1.3 lambda表达式（匿名函数）

```c++
[capture list](parameter list) -> return type {
	function body;
};
```

#### 1.4 范围for语句

```c++
for (delaration : expression) {
	statement;
}
```

+ expression 必须是一个序列。拥有能返回迭代器的begin，end成员
+ delaration 定义一个变量，序列中每一个元素都能转化成该变量的类型。常用auto

#### 1.5 右值引用

右值引用：绑定到右值的引用，用&&来获得右值引用，右值引用智能绑定到要销毁的对象。

#### 1.6 标准库move函数

通过该函数获得绑定到左值上的右值引用。

#### 1.7 智能指针

#### 1.8 delete函数和default函数

+ =delete表示该函数不能被调用
+ =default表示编译器默认生成的函数

### 2. C和C++的区别

+ 面向过程：分析解决分析需要的步骤，并用函数将这些步骤实现。
+ 面向对象：把构成问题的事物分解成各个对象，建立对象的目的不是完成一个步骤，而是描述某个事物在解决问题时的行为。

区别和联系

1. c语言是面向过程的编程。通过main函数来调用各个子函数，程序的执行顺序都是实现决定好的。C++面向对象编程，类是它的主要特点，过程的概念被淡化。以类驱动程序运行，将数据及操作封装在类中，以事件或消息来驱动对象执行处理。
2. 应用领域：c语言主要应用于嵌入式领域、驱动开发等与硬件直接打交道的领域。C++可以用于应用层开发，用户界面开发等与操作系统打交道的领域。
3. C++既继承了c强大的底层操作特性，又被赋予了面向对象机制。特性繁多，多继承，值传递和引用传递的区分以及const关键字等等
4. C++对c语言的增强表现在：类型检查更为严格，增加了面向对象的机制、泛性编程的机制。异常处理、运算符重载，STL、命名空间等。

### 3. JAVA和C++的区别

+ 语言特性
  + 指针。c++可以直接操作指针。
  + 多重继承。C++支持多重继承。
  + 数据类型和类。java完全面向对象，所有变量和函数必须是类的一部分。而C++允许将函数和变量定义成全局的。
+ 垃圾回收
  + java具备垃圾回收机制，有效防止内存泄露
+ 应用场景
  + java运行在虚拟机上，和开发平台无关。C++直接编译成可执行文件，是否跨平台在于用到的编译器是否有多平台的支持。
  + C++直接编译成可执行文件，运行效率比java高
  + java主要用来开发web应用，c++用在网络、并发编程等方面

### 4. python和C++的区别

+ 语言
  + python为脚本语言，解释执行，不需要经过编译。
  + C++是一种编译型语言，在特定的机器上编译后执行。
+ 运行效率
  + c++运行效率高，安全稳定。直接编译成机器指令，其中还有优化。
  + python解释执行，和cpu之间多了解释器，
+ 开发效率
  + python开发效率高，语法格式灵活。

## 三、面向对象

### 1. 什么是面向对象，面向对象的特性

面向对象：对象指的是某一事物，这些事物的抽象就是类，类中包含成员数据和成员方法。

面向对象的特性：

+ 封装：将具体的实现过程和数据封装成类，只能通过接口访问，降低耦合性。
+ 继承：子类继承父类的特征和行为。子类有父类的非private方法或成员变量，子类可以对父类的方法进行重写，增加耦合性。被关键字final修饰的类不能被继承，成员不能被重写或修改
+ 多态：不同继承类的对象，对同一消息能够做出不同反应。

### 2. 重载、重写和隐藏的区别

+ 重载：同一可访问区内被声明几个具有不同参数列表（类型，数量，顺序）的同名函数，根据参数列表确定调用哪个函数，重载函数不关心返回类型
+ 隐藏：指派生类的函数屏蔽了与其同名的基类函数。只要是同名函数，不管参数列表是否相同，基类函数都会被隐藏
+ 重写：指派生类存在重新定义的函数。函数名、参数列表、返回类型都必须与基类函数相同，只有函数体不同，且基类函数有virtual关键字修饰

### 3. 多态极其实现

多态就是不同继承类的对象，对同一消息作出不同反应。

基类的指针指向派生类的对象，使得基类指针呈现不同的表现方式。

在基类的函数前加上virtual关键字，在派生类中重写该函数，运行时会根据对象的实际类型来调用相应的函数。

#### 3.1 实现方法

通过虚函数实现，虚函数的地址保存在虚函数表中，虚函数表的地址保存在虚函数的类的实例对象的内存空间中。

#### 3.2 实现过程

1. 在类中用virtual关键字声明虚函数
2. 存在虚函数的类都存在一个虚函数表，当创建一个类的对象时，该对象有一个指向该虚函数表的虚表指针。
3. 当基类指针指向派生类对象，调用虚函数时，基类指针指向派生类的虚表指针，由于该虚表指针指向派生类虚函数表，通过遍历虚表，寻找相应的函数。

## 四、关键字和库函数

### 1. strlen 和sizeof的区别

1. strlen是头文件<cstring>中的库函数，sizeof是c++的运算符。

2. strlen测量的是字符串的实际长度，以'\0'结束，sizeof测量的是字符数组的分配大小。

   ```c++
   #include <iostream>
   #include <cstring>
   
   using namespace std;
   
   int main()
   {
       char arr[10] = "hello";
       cout << strlen(arr) << endl; // 5
       cout << sizeof(arr) << endl; // 10
       return 0;
   }
   ```

3. 若字符数组作为函数的形参，sizeof(arr)被当作字符指针来处理，strlen(arr)中arr依然是字符数组。

4. strlen是库函数，在运行时确定长度。sizeof是运算符，在编译时计算长度。

5. sizeof的参数可以是类型，也可以是变量。strlen的参数必须是char*类型的变量。

### 2. explict的作用

用来声明类的构造函数是显式调用的，而非隐式调用，可以阻止调用构造函数时进行隐式转换。只可以用来修饰**单参构造函数**。

### 3. static的作用

static用来修饰静态变量和静态函数

+ 保持变量内容持久：static修饰局部变量时，改变了其声明周期，使得该变量存在于定义后知道程序结束运行的时间内。
+ 隐藏：static修饰全局变量和函数时，改变了全局变量和函数的作用域，使得全局变量和函数只能在定义它的文件中使用。
+ static作用于类的成员变量和成员函数时，使得类变量或者类成员函数和类有关。不用定义类的对象就可以通过类访问这些静态成员。注意类的静态成员函数中只能访问静态成员变量和静态成员函数，不能将类的静态成员函数定义为虚函数。继承时父类子类的static变量是同一个。

### 4. static在类中的使用

+ static静态成员变量
  1. 静态成员变量是在类内进行声明，类外进行定义和初始化。在类外定义和初始化时不能出现static、private等关键字
  2. 静态成员变量被类的所有对象共享，**包括派生类的对象**
  3. 静态成员变量可以作为成员函数的参数。
  4. 静态成员变量的类型可以是所属类的类型。普通的只能是指针或引用。
+ static静态成员函数
  1. 静态成员函数不能调用非静态成员变量或非静态成员函数，因为静态成员函数没有this指针。静态成员函数作为类作用域的全局函数
  2. 静态成员函数不能声明为虚函数virtual，const函数和volatile函数

### 5. const作用及用法

+ 作用
  1. const修饰成员变量，定义成const常量，相较于宏常量，可进行类型检查、节省内存空间、提高效率。
  2. const修饰函数参数，使得传递过来的函数参数的值不能被改变。
  3. const修饰成员函数，使得成员函数不能修改任何类型的成员变量，**mutable修饰的成员变量除外**，也不能调用非const成员函数。
+ 用法
  1. const成员变量
     1. const成员变量只能在类内声明、定义，在构造函数初始化列表中初始化。
     2. const成员变量只在某个对象的生命周期内是是常量，对于整个类而言是可变的，所以不能在类声明中初始化const成员变量
  2. const成员函数
     1. 不能修改成员变量的值，除非有mutable修饰，只能访问成员变量。
     2. 不能调用非const成员函数

### 6. define和const的区别

+ 编译阶段：define是在预处理阶段进程替换，const是在编译阶段确定其值。
+ 安全性：define定义的宏常量没有数据类型，只是进行简单的替换，不会进行安全检查。const是有类型的，类型检查能避免一些简单的错误。
+ 内存占用：define定义的宏常量在程序中使用多少次就会发生多少次替换，内存中就会有多少次备份，占用代码段的空间；const定义的常量存储在静态存储区，运行过程中只有一份
+ 调试：define定义的宏常量不能调试，因为在预处理阶段就已经替换了，const定义的常量可以进行调试。

### 7. define和typedef的区别

+ 原理：#define作为预处理指令，在预处理阶段进行替换，不做正确性检查，只有在编译被展开的源程序时才会发现可能的错误并报错。typedef是关键字，在编译时处理，有类型检查功能，用来给一个已经存在的类型起别名，但不能在一个函数定义里面使用typedef。

+ 功能：typedef用来定义类型的别名，方便使用。#define不仅可以为类型取别名，还可以定义常量、变量、编译开关等

+ 指针操作：在处理指针是完全不一样

  ```c++
  #include <iostream>
  #define INTPTR1 int *
  typedef int * INTPTR2;
  
  using namespace std;
  
  int main()
  {
      INTPTR1 p1, p2; // p1: int *; p2: int
      INTPTR2 p3, p4; // p3: int *; p4: int *
  
      int var = 1;
      const INTPTR1 p5 = &var; // 相当于 const int * p5; 常量指针，即不可以通过 p5 去修改 p5 指向的内容，但是 p5 可以指向其他内容。
      const INTPTR2 p6 = &var; // 相当于 int * const p6; 指针常量，不可使 p6 再指向其他内容。
      
      return 0;
  }
  ```

### 8. inline作用及使用方法

+ 作用：inline是一个关键字，用来定义内联函数。内联函数能够像普通函数一样被调用，但是并不通过函数调用机制，而是直接在调用点展开，这样可以减少由函数调用带来的开销，从而提高程序的运行效率。
+ 使用方法：
  1. 类内定义成员函数默认是内联函数
  2. 类外定义成员函数，若想定义为内联函数，需用关键字声明

### 9. define和inline的区别

+ 编译阶段： define是在预处理阶段展开，inline是在编译时展开。
+ 安全性：宏只是简单的文本替换，不会对参数的类型、语句等能否进行正常编译进行检查。而内联函数是真正的函数，会进行检查。
+ 内联函数式真正的函数，避免了函数参数的压栈操作，减少调用的开销。宏定义编写较为复杂，常需要括号来避免歧义

### 10. new、delete和malloc、free的区别

new和delete搭配使用，malloc和free搭配使用

+ malloc、free式库函数，new和delete是关键字
+ 申请空间大小：new申请空间时，无需指定分配空间的大小，编译器会根据类型自行计算。malloc在申请空间时，需要确定所申请空间的大小。
+ 返回类型：new申请空间时，返回的类型是对象的指针类型，无需强制类型转换，类型安全；malloc返回void*类型，需要进行强制类型转换。
+ 错误类型：new申请失败时，会抛出bad_alloc异常，malloc返回空指针。
+ 自定义类型：new先调用operator new() 函数申请空间，然后调用构造函数初始化，最后返回自定义类型的指针。delete先调用析构函数，在调用operator delete() 释放空间。malloc、free无法进行自定义类型的构造和析构。
+ new从自由存储区上为对象动态分配内存，malloc函数从堆上动态分配内存。

> 附：指针的作用，指示指向对象的地址和长度，类型代表长度，值代表地址。不能对void*进行解引用操作。
>
> 如果函数的参数可以是任意类型的指针，可以将其声明为void*。
>
> void类型指针可以指向任意类型的数据，即可以用任意数据类型的指针对void指针赋值。

### 11. struct和union的区别

struct是结构体，union是联合体

区别：

1. struct和union都是由若干个数据类型不同的成员组成的。使用时联合体只有一个有效的成员，而结构体所有成员有效。
2. 对联合体的成员赋值，会覆盖其他成员的值。结构体成员互不影响
3. 联合体的大小为其内部所有变量的最大值，按照最大类型的倍数进行分配大小。结构体的大小遵循内存对齐原则

### 12. class和struct的异同

+ class和struct都可以定义数据类型，支持继承操作
+ struct中默认访问级别是public，继承级别也是public。class的都是private
+ class可以用于定义模板参数，struct不能

### 13. volatile

对象的值可能在程序的控制或检测之外被改动时，应定义为volatile。告知编译器不对其优化。

每次都去内存中读取，而不用上次的寄存器的内容。

## 五、类相关

### 1. 什么是虚函数？什么是纯虚函数？

+ 虚函数：用virtual关键字修饰的成员函数
+ 纯虚函数：纯虚函数在类中声明时加上=0；含有纯虚函数的类叫做抽象类，类中只有接口，没有实现；派生类如果没有完全实现基类中的纯虚函数依然是抽象类。
+ 抽象类对象不能作为函数的参数，不能创建对象，不能作为函数返回类型；可以声明抽象类指针、引用；

### 2. 虚函数的实现机制

虚函数通过虚函数表实现。虚函数的地址保存在虚函数表中，类的对象中有虚表指针。通过虚表指针可找到虚函数表，进而遍历找到要调用的函数。

在编译阶段建立虚函数表，虚表指针放在对象的内存空间中最前面的位置，以保证正确取到虚函数的偏移量。

### 3. 多继承下的虚函数表

1. 在多继承下，有多少个虚函数的基类就有多少个虚表指针
2. 当子类有多出来的虚函数时，添加在第一个虚表中，父类指针不能调用。
3. 当有多个虚函数表时，虚函数表的结果是0代表没有下一个虚函数表。其他位置看实现方式。

### 4. 构造函数、析构函数是否需要定义成虚函数？

+ 构造函数不定义为虚函数
  + 存储空间：对象还没构造，找不到虚表指针。
  + 类型：创建对象时需要明确类型。
+ 析构函数一般定义为虚函数：防止内存泄漏，当基类的指针或引用指向派生类的对象时，如果未定义成虚函数，会调用基类的析构函数，派生类中特有的成员变量就不会被释放。

### 5. 多重继承容易出现的问题及解决方法

命名冲突和数据冗余

命名冲突可以使用B::a，这样指出变量归属的方式来解决

数据冗余使用虚继承解决。

#### 虚继承

https://blog.csdn.net/longlovefilm/article/details/80558879

https://blog.csdn.net/chengonghao/article/details/51701290

在继承方式前面加上virtual关键字。使派生类中不会保留同一基类的多份拷贝。

#### 虚继承的实现机制

虚基类表：记录虚基类与本类的偏移量。通过偏移量找到虚基类成员。这样避免多份拷贝（不同类的偏移量不同）

虚基类指针：在对象中，指向虚基类表

多重继承时，会继承多个虚基类指针。

### 6. 空类占多少字节？编译器会自动给空类生成哪些函数？

空类声明时编译器不会生成任何成员函数。只会生成一个字节的占位符。

空类定义是编译器会自动生成6个成员函数。缺省的构造函数、拷贝构造函数、析构运算函数、复制运算符和两个取地址运算符。

### 7. 拷贝构造函数必须为引用？

避免无限制的递归，最终导致栈溢出。

### 8. C++类对象的初始化顺序

+ 构造函数调用顺序：
  1. 按照派生类继承基类的顺序，即派生列表中声明的顺序，依次调用基类的构造函数
  2. 按照派生类中成员变量的声明顺序，依次调用派生类中成员变量所属类的构造函数
  3. 执行派生类自身的构造函数
+ 类对象的初始化顺序：基类构造函数->派生类成员变量的构造函数->自身的构造函数
+ 注意：
  + 基类构造函数的调用顺序与派生类的派生列表中的顺序有关。
  + 成员变量的初始化顺序与声明顺序有关。
  + 析构顺序与构造顺序相反。

### 9. 为什么使用成员初始化列表会快

数据类型可分为内置类型和用户自定义类型（类类型），对于用户自定义类型，利用成员初始化列表效率高。

用户自定义类型如果使用类初始化列表，直接调用该成员变量对应的构造函数即完成初始化；如果在构造函数中初始化，因为 C++ 规定，对象的成员变量的初始化动作发生在进入构造函数本体之前，那么在执行构造函数的函数体之前首先调用默认的构造函数为成员变量设初值，在进入函数体之后，调用该成员变量对应的构造函数。因此，使用列表初始化会减少调用默认的构造函数的过程，效率高。

### 10. 实例化一个对象需要哪几个阶段

1. 分配空间：创建类对象首先要为该对象分配内存空间。不同的对象，为其分配空间的时机未必相同。全局对象，静态对象，分配在栈区域内的对象，在编译阶段进行内存分配。存储在堆空间的对象是在运行阶段进行内存分配。
2. 初始化：初始化发生在赋值之前，赋值是在对象初始化好后，为其赋上相应的值。初始化列表先于构造函数体内的代码执行，初始化列表执行的是数据成员的初始化过程。
3. 赋值：对于一个类的对象，其成员变量的赋值过程发生在类的构造函数的函数体中。当执行完该函数体，也就意味着类对象的实例化过程完成了。

注意：对于拥有虚函数的类的对象，还需要给虚表指针赋值。

+ 没有继承关系的类，分配完内存后，首先给虚表指针赋值，然后在进行初始化和赋值操作。
+ 有继承关系的类，分配完内存后，先执行基类的构造，再给虚表指针赋值，最后进行初始化和赋值操作。

### 11. 友元的作用及使用场景

友元提供了不同类的成员函数之间、类的成员函数与一般函数之间进行数据共享机制。通过友元，一个不同函数或另一个类的成员函数能够访问到类中的私有成员和保护成员

### 12. 静态绑定和动态绑定

+ 静态类型：变量在声明时的类型，是在编译阶段确定的。静态类型不能更改。
+ 动态类型：目前所知对象的类型，在运行阶段确定的。动态类型可以更改。

+ 静态绑定：程序在编译阶段确定对象的类型
+ 动态绑定：程序在运行阶段确定对象的类型

对于类的成员函数，只有虚函数是动态绑定，其他都是静态绑定。

### 13. 深拷贝与浅拷贝

如果一个类拥有资源，该类的对象进行复制时，如果资源重新分配就是深拷贝，否则就是浅拷贝。

+ 深拷贝：该对象和原对象占用不同的内存空间，既拷贝存储在栈中的内容，又拷贝存储在堆中的内容。
+ 浅拷贝：该对象和原对象占用同一块内存空间，只拷贝存储在栈中的内容

### 14. 编译时多态和运行时多态

+ 编译时多态：在程序编译过程中出现，发生在模板和函数重载中（泛性编程）
+ 运行时多态：在程序运行过程中出现，发生在继承体系中，指通过基类的指针访问派生类的虚函数

### 15. 别让异常逃离析构函数
C++并不禁止析构函数抛出异常，但不推荐。
1. 如果析构函数抛出异常，则异常点之后的程序不会执行，如果析构函数在异常点之后执行了某些必要的动作比如释放某些资源，则这些动作不会执行，会造成诸如资源泄漏的问题。
2. 通常异常发生时，c++的机制会调用已经构造对象的析构函数来释放资源，此时若析构函数本身也抛出异常，则前一个异常尚未处理，又有新的异常，会造成程序崩溃的问题。

无论何时，从构造函数中抛出异常都是可以的。动态创建对象要进行两个操作：分配内存和调用构造函数。若在分配内存时出错，会抛出bad_alloc异常；若在调用构造函数初始化时出错，会不会存在内存泄漏呢？答案是不会(使用智能指针）。已经构造好的对象由编译器进行挥手，不会调用析构函数.如果不用智能指针还是会出现泄露问题。0

## 六、语言特性相关

### 1. 左值和右值的区别？左值引用和右值引用的区别？

+ 左值：表达式结束后依然存在的持久对象(能够取地址）。
+ 右值：表达式结束就不存在的临时对象（不能取地址）。
+ 区别：左值持久、右值短暂

+ 左值引用不能绑定到要转换的表达式、字面常量或返回右值的表达式。右值引用恰好相反，可以绑定到这类表达式上但不能绑定到左值上。
+ 右值引用必须绑定到右值上，通过&&获得。该对象将要销毁，可以自由的移动其资源。

+ 使用std::move()可以将一个左值强制转化为右值。继而通过右值引用使用该值，用于移动语义。

移动构造为浅拷贝

### 2. 什么是野指针和空悬指针？

空悬指针：指针指向一块内存空间，当这块内存空间被释放后，该指针依然指向这块内存。这个指针就是悬空指针。

野指针：未初始化，指向不确定。

### 3. 指针和引用的区别

可变、为空、多级

+ 指针的指向可变，引用一旦绑定就不能再改变
+ 指针可以为空，引用必须绑定对象
+ 指针可以多级，引用只有一级。

### 4. 常量指针和指针常量的区别

常量指针本质上是指针，只不过这个指针指向的对象是常量。const在*左侧。

指针常量本质上是常量，常量的值是指针。const在*右侧。

### 5. 函数指针和指针函数的区别

指针函数本质是函数，返回类型是指针。

函数指针本质上是指针，指针指向函数。

### 6. 强制类型转换

#### 6.1 static_cast

用于数据的强制类型转换，将一种数据类型强制转换为另一种

+ 基本数据类型
+ 基类和派生类的指针（上行安全，下行不安全，建议用dynamic_cast)
+ 空指针转化成目标类型的空指针
+ 将任意类型的表达式转换成void类型

#### 6.2 const_cast

强制去掉const属性，用于指针或引用。（适用于处理常量字符串const char*）

#### 6.3 reinterpret_cast

处理无关类型之间的转换。指针与整数之间的转换，无关类型指针之间的转换。

#### 6.4 dynamic_cast

	1. 其他三种都是编译时完成的，动态类型转换是在程序运行时处理的，运行时进行类型检查。
 	2. 只能用于带虚函数的基类和派生类的指针或引用对象之间的转换。失败返回null。
 	3. 在进行上行转换时和static_cast效果一样
 	4. 具有类型检查的功能（typeid）。下行转换时只有指针指向的对象的类型和转化以后的对象类型相同时才会转化成功。

### 7. 如何判断结构体是否相等？能否用memcmp函数判断

需要重载==，不能使用memcmp函数，因为当有内存对齐时，补位的字节内容是随机的，而memcmp是逐个字节进行比较的。

### 8. 模板

可以是类型，也可以是值

+ 特化template<>
+ 偏特化 部分特化

## 七、STL

### 1. STL组件及其关系

STL六大组件：空间配置器、容器、迭代器、适配器、算法、仿函数

+ 容器通过空间配置器取得数据存储空间
+ 算法通过迭代器取得容器内容
+ 仿函数可以协助算法完成不同的策略变化
+ 适配器可以修饰或套接仿函数。

### 2. 空间配置器简单介绍

空间配置器为程序分配空间。

空间配置器分为两级，第一级配置器直接使用malloc()与free()。第二级配置器则视情况采用不同的策略；当配置空间大于128b时，采用第一级配置器。当需要分配的空间小于128b时，则采用内存池的方式。其目的是为了降低额外负担，减少内存碎片。

涉及到单例模式（一个进程只需要一个空间配置器），享元模式（小块内存统一由内存池进行管理）

#### 2.1 第一级配置器

+ 直接用malloc和free申请和释放内存
+ 使用new_handler机制处理内存不足的情况

#### 2.2 第二级配置器

二级空间配置器避免了太多额外的小区造成的内存碎片

allocate 和 deallocate

- allocate：如果用户需要的区块大于128B，则直接调用第一级空间适配器；如果用户需要的区块小于等于128b，则到自由链表中去找；如果自由链表有，则直接取走，不然需要装填自由链表（refill）
- deallocate：如果区块大于128，则直接由第一级空间配置器收回。如果区块小于等于128，则由自由链表收回。

##### 2.2.1 内存分配

1. free_list中有多余内存。如果申请3个字节的内存，则所需空间大小提升为8的倍数，然后去free_list中查找相应的链表，如果free_list[i]不为空，则返回第一个元素，然后把头指针往后移。
2. free_list中没有空余，但是内存池不为空。首先检验内存池中的大小是不是比申请的内存大，比如申请20*8的内存，如果足够，则分配相应内存，将其中一个分配给用户使用，其它的挂在相应的free_list中。如果内存池不够大，只够几个内存分配，则就分配这几个，把相应的数据返回。如果连一个都不够则执行第三种情况。
3. free_list中没有空余，内存池也不够。调用malloc重新分配内存。分配时会多分配一倍的内存，把相应的内存挂到free_list下，剩余的放到内存池中。
4. free_list中没有空余，内存池也不够。malloc也失败。调用一级空间配置器，里面会有循环处理，或抛出异常。

##### 2.2.2 内存回收

当用户从二级空间配置器中申请的内存被释放时，二级空间配置器将回收的内存插入到对应的free_list中

##### 2.2.3 问题

+ 内存碎片问题：比如用户需要3字节，会分配8字节，导致内存碎片
+ 内存回收会把不用的内存放在free_list中，导致其他进程无法使用

##### 2.2.4 注意

空间配置器中所有的函数都是静态的，为什么？？如果这些函数不是静态的，如果我们要申请空间，岂不是也要创建一个空间配置器的对象，由对象来调用里面的函数，进而申请空间，如果这样的话，那空间就跟随者空间配置器对象的生命周期，那这个岂不是很麻烦，每次都要额外创建对象。所以把所有的函数都设置为静态的，就不需要创建对象就能够调用函数申请空间，并且可以保证在程序结束的时候空间才会被回收。

### 3. 迭代器简单介绍

STL的中心思想在于，将数据容器和算法分开，彼此独立设计，最后再将他们撮合在一起，而迭代器就扮演了这个黏胶角色。

迭代器是一种行为类似指针的对象，而指针行为中最常见的内容是提领（dereference）和成员访问（member access）因此迭代器最重要的工作就是对opreator* 和 opreator-> 进行重载工作。

### 4. 容器

#### 4.1 容器分类

+ 序列化容器：array，vector，heap，priority_queue, list，slist（非标准），deque，stack（适配器），queue（适配器）
+ 关联型容器：set，map，multiset，multimap，hashtable（非标准），hash_set（非标准），hash_map（非标准），hash_multiset（非标准），hash_multimap（非标准）

#### 4.2 衍生

这里的衍生不是派生，是内含

+ heap内部包含vector
+ priority_queue内部包含一个heap
+ stack/queue都包含一个deque
+ set/map/multiset/multimap内含一个RB-tree
+ hash_x内含一个hashtable

#### 4.3 vector

##### 4.3.1 vector的扩容机制

新增元素：vector通过一个连续的数组存放元素，如果集合已满，在新增数据的时候就要分配一块更大的内存，将原来的数据复制过来，释放之前的内存，再插入新增的元素。

对vector的任何操作，一旦引起空间重新配置，指向原vector的所有迭代器就都失效了

初始时刻vector的capacity为0，插入第一个元素后capacity增加为1.

不同的编译器实现扩容的方式不一样，GCC以2倍扩容。有些选择1.5

- vector在push_back以成倍增长可以在均摊后达到O(1)的事件复杂度，相对于增长指定大小的O(n)时间复杂度更好。
- 为了防止申请内存的浪费，现在使用较多的有2倍与1.5倍的增长方式，而1.5倍的增长方式可以更好的实现对内存的重复利用，因为更好。

#### 4.4 红黑树

##### 4.4.1 红黑树的特性

1. 它是一棵二叉排序树
   1. 若左子树不为空，则左子树上所有节点的值都小于等于跟节点的值
   2. 若右子树不为空，则右子树上所有节点的值都大于等于跟节点的值
   3. 左右子树分别也是二叉排序树。
2. 红黑树的要求
   1. 树中节点非黑即红
   2. 根结点必须为黑节点
   3. 每个叶节点必须为黑节点
   4. 红节点的字节点必须为黑
   5. 从根出发任何路径上的黑节点数量相同
3. 查找时间为O(logN)

#### 4.4.2 与AVL树，BST树的区别

- 相比于AVL(平衡二叉查找树），红黑树的平衡性要差一些。不过创建红黑树时所需的旋转操作也会少很多。相比于最简单的BST（二叉搜索树），BST最差情况下的查找的时间复杂度会上升至O(n)，而红黑树最坏情况下查找效率依旧是O(logn).所以说红黑树之所以能够在STL及Linux内核中被广泛应用就是因为其折中了两种方案，既减少了树高，又减少了建树时旋转的次数。
- 从红黑树的定义来看，红黑树从根到NULL的每条路径拥有相同的黑节点数（假设为n），所以最短的路径长度为n（全为黑节点情况）。因为红节点不能连续出现，所以路径最长的情况就是插入最多的红色节点，在黑节点数一致的情况下，最可观的情况就是黑红黑红排列……最长路径不会大于2n，这里路径长就是树高.
- AVL最坏情况下也是O(logN),但是为了满足平衡性，需要更多的旋转操作，所以红黑树的统计性能要比AVL高。**此外，由于红黑树的设计，任何不平衡都会在三次旋转之内解决**（插入两次、删除三次）,O(logN)次变色。

#### 4.4.3 红黑树定义

```c++
enum Color {
    RED = 0,
    BLACK = 1
};
struct RBTreeNode {
    struct RBTreeNode*left, *right, *parent;
    int key;
    int data;
    Color color;
};
```

#### 4.5 hashtable

`hashtable`被视为一种字典结构，提供对于任何有名项的存取操作和删除操作。

如何避免array过大？是用某种映射函数，使得元素映射至“大小可以接受的索引”，这个函数被称为散列函数。使用散列函数必然会带来一个问题：可能有不同的元素被映射到相同的位置，这便是所谓的碰撞问题。

碰撞问题一般有两种方案：拉链法、线性探测法。

### 5. 仿函数

仿函数本质就是类重载了一个operator()，创建一个行为类似函数的对象。

仿函数对象仅仅占用1字节，因为内部没有数据成员，仅仅是一个重载的方法而已。实际上可以通过传递函数指针实现类似的功能，但是为了和STL内部配合使用，他提供了仿函数的特性。

### 6. 适配器

STL中的stack，queue通过双端队列deque适配实现

map，set通过RB-Tree适配实现。

涉及适配器模式。

### 7. sort函数

快排 + （插入排序/堆排序）防止递归过深