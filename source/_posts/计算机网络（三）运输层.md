---
title: 计算机网络（三）运输层
date: 2020-10-29 20:23:54
tags: 
    - 计算机网络
categories:
    - 计算机基础知识
    - 计算机网络
---
## 概述

网络层提供了主机之间的逻辑通信，运输层协议为不同主机上的应用进程之间提供了逻辑通信。通过逻辑通信，运行不同进程的主机好像直相连一样。

运输层协议实在端系统而不是路由器中实现的。在发送端，运输层将从发送应用程序进程接受到的报文转换成运输层分组，称为**报文段**（segment）。

**UDP（User Datagram Protocol，用户数据报协议）**为调用他的应用程序提供了一种不可靠、无连接的服务。

**TCP（Transmission Control Protocol， 传输控制协议）** 为调用它的应用程序提供了一种可靠的、面向连接的服务。

IP的服务模型是尽力而为交付服务，不做任何确保。所以是**不可靠服务**。

将主机间交付拓展到进程间交付被称为运输层的**多路复用（transport-layer multiplexing）**与**多路分解（demultiplexing）**

UDP流量是不可调节的，使用UDP的应用程序可以根据需要以其愿意的任何速率发送数据。

TCP 是面向连接的、可靠的流协议。流就是指不间断的数据结构。通过使用流量控制、序号、确认和定时器，TCP确保正确地、按序地将数据从发送进程交付给接受进程。

TCP还提供**拥塞控制（congestion control）**。拥塞控制与其说是一种提供给调用它的应用程序的服务，不如说是一种提供给整个因特网的服务。TCP拥塞控制防止任何一条TCP连接用过多流量来淹没通信主机之间的链路和交换设备。TCP力求为每个通过一条拥塞网络链路的连接平等地共享网络链路带宽。

## 多路复用与多路分解

一个进程有一个或多个套接字（socket），它相当于从网络向进程传递数据和从进程向网络传递数据地门户。在接受主机地运输层实际上并没有将数据直接交付给进程，二是将数据交给一个中间地套接字。每个套接字都有一个标识符，标识符的格式取决于他是UDP还是TCP套接字。

将运输层报文段中地数据交付到正确地套接字（通过端口号）的工作称为**多路分解（demultiplexing）**
在源主机从不同套接字中收集数据块，并为每个数据块封装上首部信息从而生成报文段，然后将报文段传递到网络层称为**多路复用**。

## UDP、无连接运输

UDP，常用在以下方面：
+ 包总量较少的通信（DNS，SNMP等）
+ 视频、音频等多媒体通信（及时通信）
+ 限定于LAN等特定网络中的应用通信
+ 广播通信

因为：
+ 关于发送什么数据以及何时发送的应用层控制更为精细：
    采用UDP时，只要应用进程将数据传递给UDP，UDP就会将此数据打包进UDP报文段并立即将其传递给网络层；TCP有拥塞控制机制，以便当源和目的主机间的一条或多条链路变得极度拥塞时来遏制TCP发送方。TCP仍将继续重新发送数据报文段直到目的主机收到此报文并加以确认，而不管可靠交付需要多长时间。

    而实时应用通常要求及时性，能够容忍一些数据丢失。
+ 无需建立连接：
    TCP开始数据传输之前需要三次握手。UDP不需要任何准备即可进行数据传输。
+ 无状态连接：
    TCP需要在端系统中维护连接状态。包括接受和发送缓存、拥塞控制参数以及序号与确认号的参数。UDP不维护连接状态，也不跟踪这些参数。
+ 分组首部开销小 ：
    TCP40字节，UDP8字节。


### UDP报文端结构
![](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/UDP%E6%8A%A5%E6%96%87%E5%AD%97%E6%AE%B5.png)

端口号可以使目的主机将应用数据交给运行在目的端系统中的相应进程。

长度字段只是了UDP报文段中的字节数（首部＋数据)
### UDP检验和

检验和提供了差错检测功能。因为不能保证源和目的之间的所有链路都提供差错检测。

虽然提供差错检测，但他对差错恢复无能为力。

## TCP 面向连接的运输

TCP提供**全双工服务（full-duplex service）**，点对点。

### TCP报文段结构
![](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/TCP%E6%8A%A5%E6%96%87%E5%AD%97%E6%AE%B5.png)

20字节

 + **源端口号**和**目的端口号**用于多路复用与多路分解。16比特。
 + 同UDP一样，TCP也包括**检验和**字段。16比特
 + **序号**和**确认号**。32比特。用来实现可靠数据传输服务。
 + **接受窗口**。16比特。用于流量控制，限制窗口大小到65535字节。
 + **首部长度**。4比特。指示以32比特的字为单位的TCP首部长度，因为有**选项字段**，作为一个4比特的字节，TCP被限制为只能带60字节的头部。
 + **保留字段**。4比特
 + **选项**。可选与变长。在发送方与接收方协商最大报文段长度（MSS）时使用，或者在高速网络环境下用作窗口调节因子时使用、时间戳、ASCK（选择确认)。
 + **标志** 8比特。
    1. ACK比特。指示确认字段中的值是有效的，即该报文段包括一个对已被成功接受报文段的确认
    2. RST、SYN和FIN比特用于连接建立和拆除。
    3. 当PSH比特被置位，就指示接收方应立即将数据交给上层。
    4. URG比特用来指示报文段里存在着被发送端的上层实体置为“紧急”的数据。紧急数据的最后一个字节由16比特的**紧急数据指针字段（urgent data pointer field）**指出，这个指针是一个必须要加到报文段的序列号字段上的正偏移。当紧急数据存在并给出指向紧急数据尾指针的时候，TCP必须通知接受端的上层实体。
    5. CWR 拥塞窗口减（发送方降低它的发送速率）
    6. ECE ECN回显（发送方接收到了一个更早的拥塞通告）
TCP包没有IP地址，这属于网络层，一个TCP连接需要4个元组（双方的IP端口）来保证是同一连接。

SequenceNumber来解决网络包乱序问题

ACK用于确认不丢包

RST 重置连接(连接取消，经常是因为错误)

Window是滑动窗口用来解决流控问题


### TCP连接管理

#### 连接创建：三次握手

1. 客户端发送SYN报文段（不包含应用层数据，SYN比特置为1）到服务器，指明想要连接的端口号。并随机选择一个初始序号（client_isn，Initial Sequence Number)，并将此编号放置于SYN报文段的序号字段中。并且进入SYN_SEND状态等待服务器确认
2. 服务器收到SYN报文段，为该TCP连接分配TCP缓存和变量，并向该客户段TCP发送允许连接的报文段（也不包含应用层数据，SYN比特置为1）。其次，确认号字段被置为client_isn + 1.最后选择自己的初始序号（server_isn)放置到序号字段中。 服务器由LISTEN进入SYN_RECV状态。
3. 客户端收到SYN+ACK报文段，为该连接分配TCP缓存和变量，并向服务器发送确认报文段（SYN比特置0，可以包含应用层数据）。将server_isn + 1 放进去确认字段。发送完毕客户端和服务器进入ESTABLISHED状态。


#### 连接关闭：四次挥手

TCP有个特殊的概念叫半关闭，因为TCP连接是全双工连接，因此关闭连接必须关闭两个方向上的连接。

1.  客户端给服务器发送一个FIN报文段（FIN比特置为1）。并由ESTABLISHED状态进入FIN_WAIT_1状态，等待来自服务器的带有确认的TCP报文段。
2.  服务器收到该报文段后，就向发送方回送一个确认报文段。由ESTABLISHED状态进入CLOSE_WAIT状态。客户端接收到确认后进入FIN_WAIT_2状态。
3.  服务器发送自己的终止报文段（FIN比特置为1）。进入LAST_ACK状态。
4.  客户端对终止报文段进行确认。客户端进入TIME_WAIT状态，等待30秒进入CLOSED状态。接受到报文后服务器进入CLOSED状态。


![](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/tcp%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2.png)


当主机接收到TCP报文段与进行中的进程都不匹配的情况时，发送重置报文段。当主机发送一个重置报文段时，他告诉该源“我没有那个报文段的套接字，请不要发送该报文段了”。
当UDP套接字不匹配时，主机发送特殊的ICMP数据报。

在连接建立的时候，通信双方需要确认最大报文长度。一般这个SYN是MTU减去IP和TCP的首部长度，对于以太网一般可以达到1460字节，非本地IP只有536字节，中间传输的MSS更小的话这个值更小。

2MSL（Maximum Segment Lifetime）状态: 在图中有一个TIME_WAIT等待状态，这个状态又叫2MSL状态在 发送了最后一个ACK数据报以后，要进入TIME_WAIT状态，这个状态是防止最后一次握手的数据报没有传到对方那里而准备的，态保证了双方都可以正常结束。当一个连接处于2MSL状态时，任何延迟到达的报文段都将被丢弃。当TCP处于2MSL状态时，通信双方将该连接定义为不可重新使用。

这对于客户端无所谓，但是服务程序（httpd）总要用一个端口来服务。而这个2MSL时间内，可能会发生错误重新启动，重新建立连接，这样上一个连接延迟到达的数据会被认为是新连接中的数据。为了避免这个错误，服务器给出了平静时间的概念，虽然可以重新启动服务器，但是要平静的等待一个MSL才能进行下一次连接

FIN_WAIT_2 半关闭状态，还可以接受数据但不能发送数据。还有一种可能是客户端一直FIN_WAIT_2 服务器一直WAIT_CLOSE,直到应用层来决定关闭这个状态。

RST 重置连接(连接取消，经常是因为错误)。

初始序列号会随时间改变，因此没有个连接都拥有不同的初始序列号。初始序列号可被视为一个32位的计数器。该计数器的数值每4微秒加一。防止出现与其他连接的序列号重叠的情况，尤其对于同一连接的两个不同实例。一个TCP报文段只有同时具备连接的4元组与当前活动窗口的序列号，才会在通信过程中被对方认为是正确的。

### TCP超时重传

异常网络状况下，可能出现以下情况：
1. 数据顺利到达对端，对端顺利响应ACK
2. 数据包中途丢失
3. 数据包顺利到达，但ACK报文中途丢失
4. 数据包顺利到达，但对端异常未响应ACK或被对端丢弃。

![](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/%E7%BD%91%E7%BB%9C%E5%BC%82%E5%B8%B8%E6%83%85%E5%86%B5.jpg)

出现异常情况时，TCP就会超时重传。TCP每发送一个报文段，就对这个报文段，就对这个报文段设一个计时器，如果确认的时间到了而没有收到确认，就会重传报文段。这就是超时重传。

客户端一直没有得到ACK报文，客户端会一直重传，影响重传效率的是RTO（Retransmission Timeout）。RTO指发送数据后，传送数据等待ACK的时间。RTO非常重要。
1.  设长了，重发慢，没有效率
2.  设短了，重发快，网络拥塞。

如果底层传输特性已知，则重传相对简单，但是TCP体层完全异构，所以必须适应适应时延差异。

经典的自适应算法：

`$SRTT = \alpha * SRTT + (1 - \alpha) * RTT$`

`$RTO = min(UBOUND, max(LBOUND, \beta * SRTT)$`

UBOUND是最大的timeout时间，上限值，LBOUND是最小的timeout
时间，下限值。但这样会因为ACK传输导致RTT多义性问题。

carn算法，忽略重传，不采样重传的RTT，一旦发生重传，就对现有的RTO翻倍。
当不发生重传时，才根据上式计算平均往返时间RTT和重传时间。


处理差错的两种主要方法是差错校正码和数据重传。

当RTT测量值小于连接地实际值，就可能发生伪重传。在这种情况下，若TCP地等待时间稍长，不必要地重传就可能不发生。




### TCP滑动窗口

TCP的滑动窗口主要有两个作用：一是提供TCP的可靠性；二是提供TCP的流控特性。同时滑动 窗口机制还体现了TCP面向字节流的设计思路。

对于TCP会话的的发送方，任何时候器缓存数据可以分为四类:
1.  已经发送并受到对方的ACK
2.  已经发送但未收到ACK
3.  未发送但对方允许发送
4.  对方不允许发送

其中，已经发送还未收到ACK和未发生但是对方允许发送的部分称为发送窗口
![](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3.jpg)

当接收到ACK后续的确认字节时，窗口便会滑动

![](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/TCP%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E6%BB%91%E5%8A%A8%E7%A4%BA%E6%84%8F%E5%9B%BE.jpg)

对于TCP会话的接收方，缓存数据可以分为三类
1.  已接受
2.  未接受准备接收
3.  未准备接收

其中未接受准备接收称为接收窗口。

TCP是双工的协议，会话的双方可以同时接收、发送数据。TCP会话双方都各自维护一个发送窗口和接收窗口。滑动窗口实现面向流的可靠性来源于“确认重传机制”，TCP滑动窗口的可靠性也来源与确认重传。发送窗口只有受到对方对于本段ACK的确认，才会移动左边界。前面还有字节未接收的情况下，窗口不会移动。

#### 延时确认
在许多情况下，TCP并不对每个到来的数据包都反回ACK，利用TCP的累积ACK字段就能实现该功能。累积确认可以允许TCP延迟一段时间发送ACK，以便将ACK和相同方向上需要传的数据结合发送。这种捎带传输的方法经常用于批量数据传输。

#### Nagle算法 
当一个TCP连接中有在传数据（已发送还未经确认的数据）时，小的报文段（长度小于SMSS）就不能被发送，直到所有的在传数据都收到ACK。在收到ACK后，TCP需要收集这些小数据，将其整合到一个报文段中发送。

#### 零窗口与TCP持续计时器
TCP通过接受端的通告窗口来实现流量控制。通告窗口指示了接受端可接受的数据量。当窗口值变为0时，可以阻止发送端继续发送，直到窗口大小恢复非零值。

当接收端重新获得可用空间时，会给发送端传输一个**窗口更新**，告知其可以继续发送数据。这样的窗口更新不包含数据，且没有可靠性，如果丢失，双方就一直处于等待状态。

为防止这种死锁发生，发送方会采用一个**持续计时器**间歇性地查询接收端，看其窗口是否增长。持续计时器会触发**窗口探测**地传输，强制要求接受端返回ACK（包含窗口大小）。


#### 糊涂窗口综合征
通告窗口较小时，发送端会立即发送数据填满该窗口，这样在连接中就会出现大量高耗费地小数据包。对发送端来说，通告窗口较小应该避免发送小数据包；接受端应该尽量避免通告小窗口。



### TCP拥塞控制

计算机网络中的带宽、交换节点中的缓存和处理机等都是网络的资源。某段时间，网络需求超过了可用部分，网络性能就会变坏，这被称为拥塞。拥塞控制就是防止过多的网络流量注入到网络中。TCP拥塞控制由四个核心算法组成：满开始、拥塞避免、快速重传和快速恢复。

#### 慢开始和拥塞避免

发送发维持一个拥塞窗口的状态变量，拥塞窗口取决于网络的拥塞程度。发送方让自己的发送窗口等于拥塞窗口。考虑到接收方的接受能力，发送窗口可能小于拥塞窗口

慢开始的思路就是一开始不发送大量的数据，先探测网络的拥塞程度。由小到大增加拥塞窗口。

1. 当主机发送数据时，如果将较大的发送窗口全部注入到网络中，可能引起拥塞
2. 可以试探一下，由小到大增大拥塞窗口的数量
3. 慢开始从1个MSS开始指数增长，为了防止其增长过大，设置一个门限ssthresh，当其达到门限时，变为拥塞避免算法。

拥塞避免算法是使拥塞窗口缓慢增长，每经过一个RTT就将拥塞窗口加一。

1. TCP连接初始化，拥塞窗口为1
2. 执行慢开始算法，cwind指数增长，指导cwind=ssthresh时，开始拥塞避免算法
3. 当网络拥塞时（超时的丢包事件）将ssthresh设为当前的一半，cwind设为1重新开始。

![](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/TCP%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3.png)

![](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/TCP%E6%8B%A5%E5%A1%9E%E7%AA%97%E5%8F%A3%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

#### 快重传和快恢复

快重传要求接收方受到一个失序的报文段后立即发送重复确认（为使发送方尽早知道报文段为传到对方）。快重传规定只要一连收到3个重复确认就立即重传对方尚未收到的报文段，而不必继续等待。

快重传还配合有快恢复，主要思想包括：
1.  一旦受到三个重复确认，执行乘法减小，ssthresh门限减半，但是并不执行慢开始
2.  将cwind设为ssthresh，执行拥塞避免算法。


整体上，TCP拥塞窗口的原则时加法增大、乘法减小。可以看出TCP较好的保证了流之间的公平性，一旦丢包就减半退让。

![](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/TCP%E5%BF%AB%E9%87%8D%E4%BC%A0%E7%9A%84%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

![](https://raw.githubusercontent.com/Yqzzxlj/Image-Hosting/master/TCP%E5%BF%AB%E9%87%8D%E4%BC%A0%E8%BD%AC%E5%85%A5%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8D.png)

ACK号与接收端缓存中的其他数据之间的间隔称为空缺。序列号高于空缺的数据称为失序数据，因为这些数据和之前接收的序列号不连续。合理采用SACK信息能更快地实现空缺填补，且能减少不必要地重传。

#### 为什么进行三次握手

本质上TCP协议的三次握手需要解决一个这样的问题：在不可靠的信道上（IP数据报尽最大努力交付）完成可靠的数据传输。而全双工的连接建立需要双方的连接请求和确认，这样最小需要三次握手才能建立连接。

至于为什么三次是最少，客户端服务器最少都需要向对方发送一个同步报文（SYN），但是如果只有这两次握手，服务器就只能接收连接，无法确认连接；设想如果服务器接收一个SYN报文就建立连接，那客户端因为阻塞原因重发了N个SYN同步报文，服务器每接收到一个就需要建立一次连接，这是不堪设想的。所以只有当服务器接收到客户端的第二次ack确认报文后才会建立连接。

#### 为什么进行四次挥手

TCP是全双工的协议，通信中双方都需要知道对方的存在，而在结束时，双方也同时需要发送断开于确认对方断开的信息。当主机1发送FIN希望断开连接时，主机1已经没有要发送的数据了，但是其还是有可能接收主机2发送的数据，此时单方面的连接断开了，这是处于半连接状态。而只有主机2也向主机1发送断开请求并确认，双方才完全的断开。

#### TCP的半打开状态

如果TCP连接中一方已经关闭或异常终止另一方还不知道，这样的连接称为半打开状态。任何一端的主机都可能检测到这一情况，如果双方没有在半打开的连接上传输数据，双发就无法获悉异常。

半打开的一个常见原因时一方程序的非正常结束（断电、断网），如果A已经没有向B发送的数据，则B永远无法获悉A是否已经消失了，而当一方获取到异常的数据连接后（比如重启）直接进行复位（RST）处理。

#### 同时打开与同时关闭

两个程序的同时打开与同时关闭是有可能的，例如A:port1 向B:port2发送SYN同步信息的同时，B:port2也向A:port1发送了一个SYN同步信息，此时双发收到对方的SYN后各自向对方回一个ack表示，确认，连接就正常建立了，这样一个打开需要四个报文段。

而同时关闭同理，也是双方同时发送FIN报文段，双方在ack确认，这样还是使用4个报文段双方完成了连接的关闭只不过此时双方都跳过了FINWAIT2阶段

#### 大量的Time-wait怎么办

Time-wait 状态不能消除，只能快速的回收或重用

reuse 处于Time-wait状态可以被后续连接重用

recycle 开启服务器对于time-wait的快速回收

time-out 修改系统默认的TIMEOUT时间

#### 重置报文段 RST字段

1.  针对不存在端口的连接请求
2.  终止一条连接：重置报文段会被立即发送，任何排队的数据都将被抛弃；接收方会说明通信另一端采用了终止的方式而不是一次正常关闭。
3.  半开连接：服务器主机被切断连接重启后，留给客户端一个半开的连接。当再次从这条连接上接收到数据时，服务器对其一无所知，并回复一个重置报文段关闭连接。
4.  一个重置报文段能破坏TIME_WAIT状态并强制连接关闭。


#### TCP保活机制
若某个连接长时间处于空闲状态，在该连接地一端会发送一个探测数据包（可以不含任何数据，但一般会包含垃圾字节）从而实现保活功能。
1. 对方主机正在工作且可以到达。正常响应，保活计时器重置
2. 对方主机崩溃。没有响应，请求段会保活时间间隔指定地时间后超时断开连接。
3. 对方主机崩溃已重启。重置报文段，断开连接
4. 对方主机正在工作但无法到达。同2

#### TCP 连接的本质是什么，真的是“链接”吗

状态和序列号，以及错误校验（可以查看TCP和UDP的请求头，就会发现两者之间的差距了），其实所谓的TCP三次握手请求连接，无非就是初始化一个序列号，保证后面的数据有序到达，同时TCP还支持重传，错误校验，保证数据的可靠性，当然UDP也提供校验。

+ 建立连接（标志位）：通信前确认通信实体存在。

+ 序号机制（序号、确认号）：确保了数据是按序、完整到达。

+ 数据校验（校验和）：CRC校验全部数据。

+ 超时重传（定时器）：保证因链路故障未能到达数据能够被多次重发。

+ 窗口机制（窗口）：提供流量控制，避免过量发送。

+ 拥塞控制：同上。