---
title: 二叉树遍历
date: 2020-03-11 11:14:24
categories: algorithm
---

## 二叉树递归遍历

``` c++
void traverse(TreeNode* root) {
  if(root == nullptr) {
    return;
  }
  traverse(root->left);
  traverse(root->right);
}
```
<!--more-->

## 二叉树非递归遍历

### 中序遍历

用栈，当前结点非空入站,移动到左孩子。为空赋值为栈顶结点，出栈结点的左子树已经访问结束，继续访问右子树，当前结点移动到右子树。

``` c++
void inTraverse(TreeNode* root) {
  if(root != nullptr) {
    stack<TreeNode*> s;
    while(!s.empty() || root != nullptr) {
      if(root) {
        s.push(root);
        root = root->left;
      } else {
        root = s.top();
        s.pop();
        // root->val;
        root = root->right;
      }
    }
  }
}
```

### 前序遍历

用栈，中左右的顺序。先访问当前结点，右结点压栈，左结点压栈。然后左结点弹出，访问左子树。

``` c++
void preTraverse(TreeNode* root) {
  if(root != nullptr) {
    stack<TreeNode*> s;
    s.push(root);
    while(!s.empty()) {
      root = s.top();
      s.pop();
      // root->val;
      if(root->right != nullptr) {
        s.push(root->right);
      }
      if(root->left != nullptr) {
        s.push(root->left);
      }
    }
  }
}
```

### 后序遍历

用栈，左右中的顺序，判断要访问哪一个。

``` c++
void postorderTraversal(TreeNode* root) {
  if (root != nullptr) {
    stack<TreeNode*> s;
    s.push(root);
    // h 为最近打印过的元素, 将ｈ初始化为root，避免ｈ初始为c的左右孩子，(为使代码简洁可复用root,但为了更好理解用两个变量)
    TreeNode* h = root;
    // c 为栈顶元素,待执行元素，判断访问ｃ还是将其子结点压栈
    TreeNode* c = nullptr;
    while (!s.empty()) {
      c = s.top();
      // 由于是后序遍历(左右中), c 的左右孩子都不是最近打印的结点，说明左右ｃ的左右子树都没打印，应先打印ｃ的左子树，将左子结点压栈（先打印左子树）
      if (c->left != nullptr && h != c->left && h != c->right) {
        s.push(c->left);
      // 由于没有执行分支１，说明ｃ的左孩子要么不存在，要么打印过左子树，要么打印过右子树，如果没打印过右子树说明是前两种情况，此时应该打印右子树，将右孩子压栈，
      } else if (c->right != nullptr && h != c->right) {
        s.push(c->right);
      // 左右子树打印完毕，打印ｃ结点，ｃ结点出栈，更新ｈ。
      } else {
        // c->val
        s.pop();
        h = c;
      }
    }
  }
}
```

### 层次遍历

用队列，访问当前结点的时候将子结点加进队尾

``` c++
void levelTraverse(TreeNode* root) {
  if(root != nullptr) {
    queue<TreeNode*> q;
    q.push(root);
    while(!q.empty()) {
      root = q.front();
      q.pop();
      // root->val
      if(root->left != nullptr) {
        q.push(root->left);
      }
      if(root->right != nullptr) {
        q.push(root->right);
      }
    }
  }
}
```

### Morris遍历

不用栈，用有限个变量访问整棵树。将当前结点左子树的最右结点指向当前结点。这样遍历完左子树就**又回到**了当前结点

``` c++
void morrisTraverse(TreeNode* root) {
  if(root == nullptr) return;
  TreeNode* cur = root;
  TreeNode* mostRight = nullptr;
  while(cur != nullptr) {
    mostRight = cur->left;
    if (mostRight != nullptr) {
      while(mostRight->right != nullptr && mostRight->right != cur){
        mostRight = mostRight->right;
      }
      if(mostRight->right = nullptr) {
        mostRight->right = cur;
        cur = cur->left;
        continue;
      } else {
        mostRight->right = nullptr;
      }
    }
    cur = cur->right;
  }
}
```

#### Morris先序遍历

在cur指针第一次来到该结点的时候处理结点(指向左孩子之前,或者当左孩子为空时)

``` c++
void morrisTraverse(TreeNode* root) {
  if(root == nullptr) return;
  TreeNode* cur = root;
  TreeNode* mostRight = nullptr;
  while(cur != nullptr) {
    mostRight = cur->left;
    if (mostRight != nullptr) {
      while(mostRight->right != nullptr && mostRight->right != cur){
        mostRight = mostRight->right;
      }
      if(mostRight->right = nullptr) {
        mostRight->right = cur;
        // cur->val;
        cur = cur->left;
        continue;
      } else {
        mostRight->right = nullptr;
      }
    } else {
      // cur->val;
    }
    cur = cur->right;
  }
}
```

#### Morris中序遍历

在cur指针第二次来到当前结点时处理该结点（指向右结点之前）

``` c++
void morrisTraverse(TreeNode* root) {
  if(root == nullptr) return;
  TreeNode* cur = root;
  TreeNode* mostRight = nullptr;
  while(cur != nullptr) {
    mostRight = cur->left;
    if (mostRight != nullptr) {
      while(mostRight->right != nullptr && mostRight->right != cur){
        mostRight = mostRight->right;
      }
      if(mostRight->right = nullptr) {
        mostRight->right = cur;
        cur = cur->left;
        continue;
      } else {
        mostRight->right = nullptr;
      }
    }
    // cur->val;
    cur = cur->right;
  }
}
```

#### Morris后序遍历

``` c++
void morrisTraverse(TreeNode* root) {
  if(root == nullptr) return;
  TreeNode* cur = root;
  TreeNode* mostRight = nullptr;
  while(cur != nullptr) {
    mostRight = cur->left;
    if (mostRight != nullptr) {
      while(mostRight->right != nullptr && mostRight->right != cur){
        mostRight = mostRight->right;
      }
      if(mostRight->right = nullptr) {
        mostRight->right = cur;
        cur = cur->left;
        continue;
      } else {
        mostRight->right = nullptr;
        // pushRightEdge(cur->left, vector<int>&)
      }
    }
    cur = cur->right;
  }
  // pushRightEdge(cur->left, vector<int>&)
  // return ret;
}

vector<int> pushRightEdge(TreeNode* node, vector<int>& ret) {
  TreeNode* tail = reverse(node);
  TreeNode* cur = tail;
  while(cur != nullptr) {
    ret.push_back(cur);
    cur = cur->right;
  }
  reverse(tail);
  return ret;
}

TreeNode* reverse(TreeNode* node) {
  TreeNode* pre = nullptr;
  TreeNode* next = nullptr;
  TreeNode* cur = node;

  while(cur != nullptr) {
    next = cur->right;
    cur->right = pre;
    pre = cur;
    cur = next;
  }
  return pre;
}
```



