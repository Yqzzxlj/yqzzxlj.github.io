<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>二叉树遍历 | Yqzzxlj</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="二叉树递归遍历void traverse(TreeNode* root) {   if(root &#x3D;&#x3D; nullptr) {     return;   }   traverse(root-&gt;left);   traverse(root-&gt;right); } 二叉树非递归遍历中序遍历用栈，当前结点非空入站,移动到左孩子。为空赋值为栈顶结点，出栈结点的左子树已经访问结束，继续访问右子树，">
<meta property="og:type" content="article">
<meta property="og:title" content="二叉树遍历">
<meta property="og:url" content="http://yoursite.com/2020/03/11/%E4%BA%8C%E5%8F%89%E6%A0%91%E9%81%8D%E5%8E%86/index.html">
<meta property="og:site_name" content="Yqzzxlj">
<meta property="og:description" content="二叉树递归遍历void traverse(TreeNode* root) {   if(root &#x3D;&#x3D; nullptr) {     return;   }   traverse(root-&gt;left);   traverse(root-&gt;right); } 二叉树非递归遍历中序遍历用栈，当前结点非空入站,移动到左孩子。为空赋值为栈顶结点，出栈结点的左子树已经访问结束，继续访问右子树，">
<meta property="og:locale" content="zh">
<meta property="article:published_time" content="2020-03-11T03:14:24.000Z">
<meta property="article:modified_time" content="2020-03-11T14:49:32.891Z">
<meta property="article:author" content="Yqzzxlj">
<meta name="twitter:card" content="summary">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
  </script>
  
<link rel="stylesheet" href="/css/index.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">Yqzzxlj</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="https://github.com/Yqzzxlj" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/" class="nav-menu ">HOME</a>
          
        
            <a href="/archives" class="nav-menu ">ARCHIVE</a>
          
        
            <a href="/tags" class="nav-menu ">TAG</a>
          
        
            <a href="/categories" class="nav-menu ">CATEGORY</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">二叉树遍历</h2>
  <p class="sub">Mar 11, 2020</p>
  <article class="content">
    <h2 id="二叉树递归遍历"><a href="#二叉树递归遍历" class="headerlink" title="二叉树递归遍历"></a>二叉树递归遍历</h2><pre><code class="c++">void traverse(TreeNode* root) {
  if(root == nullptr) {
    return;
  }
  traverse(root-&gt;left);
  traverse(root-&gt;right);
}</code></pre>
<h2 id="二叉树非递归遍历"><a href="#二叉树非递归遍历" class="headerlink" title="二叉树非递归遍历"></a>二叉树非递归遍历</h2><h3 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h3><p>用栈，当前结点非空入站,移动到左孩子。为空赋值为栈顶结点，出栈结点的左子树已经访问结束，继续访问右子树，当前结点移动到右子树。</p>
<pre><code class="c++">void inTraverse(TreeNode* root) {
  if(root != nullptr) {
    stack&lt;TreeNode*&gt; s;
    while(!s.empty() || root != nullptr) {
      if(root) {
        s.push(root);
        root = root-&gt;left;
      } else {
        root = s.top();
        s.pop();
        // root-&gt;val;
        root = root-&gt;right;
      }
    }
  }
}</code></pre>
<h3 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h3><p>用栈，中左右的顺序。先访问当前结点，右结点压栈，左结点压栈。然后左结点弹出，访问左子树。</p>
<pre><code class="c++">void preTraverse(TreeNode* root) {
  if(root != nullptr) {
    stack&lt;TreeNode*&gt; s;
    s.push(root);
    while(!s.empty()) {
      root = s.top();
      s.pop();
      // root-&gt;val;
      if(root-&gt;right != nullptr) {
        s.push(root-&gt;right);
      }
      if(root-&gt;left != nullptr) {
        s.push(root-&gt;left);
      }
    }
  }
}</code></pre>
<h3 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h3><p>用栈，左右中的顺序，判断要访问哪一个。</p>
<pre><code class="c++">void postorderTraversal(TreeNode* root) {
  if (root != nullptr) {
    stack&lt;TreeNode*&gt; s;
    s.push(root);
    // h 为最近打印过的元素, 将ｈ初始化为root，避免ｈ初始为c的左右孩子，(为使代码简洁可复用root,但为了更好理解用两个变量)
    TreeNode* h = root;
    // c 为栈顶元素,待执行元素，判断访问ｃ还是将其子结点压栈
    TreeNode* c = nullptr;
    while (!s.empty()) {
      c = s.top();
      // 由于是后序遍历(左右中), c 的左右孩子都不是最近打印的结点，说明左右ｃ的左右子树都没打印，应先打印ｃ的左子树，将左子结点压栈（先打印左子树）
      if (c-&gt;left != nullptr &amp;&amp; h != c-&gt;left &amp;&amp; h != c-&gt;right) {
        s.push(c-&gt;left);
      // 由于没有执行分支１，说明ｃ的左孩子要么不存在，要么打印过左子树，要么打印过右子树，如果没打印过右子树说明是前两种情况，此时应该打印右子树，将右孩子压栈，
      } else if (c-&gt;right != nullptr &amp;&amp; h != c-&gt;right) {
        s.push(c-&gt;right);
      // 左右子树打印完毕，打印ｃ结点，ｃ结点出栈，更新ｈ。
      } else {
        // c-&gt;val
        s.pop();
        h = c;
      }
    }
  }
}</code></pre>
<h3 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h3><p>用队列，访问当前结点的时候将子结点加进队尾</p>
<pre><code class="c++">void levelTraverse(TreeNode* root) {
  if(root != nullptr) {
    queue&lt;TreeNode*&gt; q;
    q.push(root);
    while(!q.empty()) {
      root = q.front();
      q.pop();
      // root-&gt;val
      if(root-&gt;left != nullptr) {
        q.push(root-&gt;left);
      }
      if(root-&gt;right != nullptr) {
        q.push(root-&gt;right);
      }
    }
  }
}</code></pre>
<h3 id="Morris遍历"><a href="#Morris遍历" class="headerlink" title="Morris遍历"></a>Morris遍历</h3><p>不用栈，用有限个变量访问整棵树。将当前结点左子树的最右结点指向当前结点。这样遍历完左子树就<strong>又回到</strong>了当前结点</p>
<pre><code class="c++">void morrisTraverse(TreeNode* root) {
  if(root == nullptr) return;
  TreeNode* cur = root;
  TreeNode* mostRight = nullptr;
  while(cur != nullptr) {
    mostRight = cur-&gt;left;
    if (mostRight != nullptr) {
      while(mostRight-&gt;right != nullptr &amp;&amp; mostRight-&gt;right != cur){
        mostRight = mostRight-&gt;right;
      }
      if(mostRight-&gt;right = nullptr) {
        mostRight-&gt;right = cur;
        cur = cur-&gt;left;
        continue;
      } else {
        mostRight-&gt;right = nullptr;
      }
    }
    cur = cur-&gt;right;
  }
}</code></pre>
<h4 id="Morris先序遍历"><a href="#Morris先序遍历" class="headerlink" title="Morris先序遍历"></a>Morris先序遍历</h4><p>在cur指针第一次来到该结点的时候处理结点(指向左孩子之前,或者当左孩子为空时)</p>
<pre><code class="c++">void morrisTraverse(TreeNode* root) {
  if(root == nullptr) return;
  TreeNode* cur = root;
  TreeNode* mostRight = nullptr;
  while(cur != nullptr) {
    mostRight = cur-&gt;left;
    if (mostRight != nullptr) {
      while(mostRight-&gt;right != nullptr &amp;&amp; mostRight-&gt;right != cur){
        mostRight = mostRight-&gt;right;
      }
      if(mostRight-&gt;right = nullptr) {
        mostRight-&gt;right = cur;
        // cur-&gt;val;
        cur = cur-&gt;left;
        continue;
      } else {
        mostRight-&gt;right = nullptr;
      }
    } else {
      // cur-&gt;val;
    }
    cur = cur-&gt;right;
  }
}</code></pre>
<h4 id="Morris中序遍历"><a href="#Morris中序遍历" class="headerlink" title="Morris中序遍历"></a>Morris中序遍历</h4><p>在cur指针第二次来到当前结点时处理该结点（指向右结点之前）</p>
<pre><code class="c++">void morrisTraverse(TreeNode* root) {
  if(root == nullptr) return;
  TreeNode* cur = root;
  TreeNode* mostRight = nullptr;
  while(cur != nullptr) {
    mostRight = cur-&gt;left;
    if (mostRight != nullptr) {
      while(mostRight-&gt;right != nullptr &amp;&amp; mostRight-&gt;right != cur){
        mostRight = mostRight-&gt;right;
      }
      if(mostRight-&gt;right = nullptr) {
        mostRight-&gt;right = cur;
        cur = cur-&gt;left;
        continue;
      } else {
        mostRight-&gt;right = nullptr;
      }
    }
    // cur-&gt;val;
    cur = cur-&gt;right;
  }
}</code></pre>
<h4 id="Morris后序遍历"><a href="#Morris后序遍历" class="headerlink" title="Morris后序遍历"></a>Morris后序遍历</h4><pre><code class="c++">void morrisTraverse(TreeNode* root) {
  if(root == nullptr) return;
  TreeNode* cur = root;
  TreeNode* mostRight = nullptr;
  while(cur != nullptr) {
    mostRight = cur-&gt;left;
    if (mostRight != nullptr) {
      while(mostRight-&gt;right != nullptr &amp;&amp; mostRight-&gt;right != cur){
        mostRight = mostRight-&gt;right;
      }
      if(mostRight-&gt;right = nullptr) {
        mostRight-&gt;right = cur;
        cur = cur-&gt;left;
        continue;
      } else {
        mostRight-&gt;right = nullptr;
        // pushRightEdge(cur-&gt;left, vector&lt;int&gt;&amp;)
      }
    }
    cur = cur-&gt;right;
  }
  // pushRightEdge(cur-&gt;left, vector&lt;int&gt;&amp;)
  // return ret;
}

vector&lt;int&gt; pushRightEdge(TreeNode* node, vector&lt;int&gt;&amp; ret) {
  TreeNode* tail = reverse(node);
  TreeNode* cur = tail;
  while(cur != nullptr) {
    ret.push_back(cur);
    cur = cur-&gt;right;
  }
  reverse(tail);
  return ret;
}

TreeNode* reverse(TreeNode* node) {
  TreeNode* pre = nullptr;
  TreeNode* next = nullptr;
  TreeNode* cur = node;

  while(cur != nullptr) {
    next = cur-&gt;right;
    cur-&gt;right = pre;
    pre = cur;
    cur = next;
  }
  return pre;
}</code></pre>

  </article>
  <footer class="f-cf">
    
      <a href="/2020/03/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E6%80%9D%E8%B7%AF/" class="link f-fl">⟵动态规划思路</a>
    
    
      <a href="/2020/03/10/%E8%87%AA%E7%BC%96%E7%A0%81%E3%80%81DQN%E3%80%81GAN%E7%BD%91%E7%BB%9C%E5%AD%A6%E4%B9%A0/" class="link f-fr">自编码、DQN、GAN网络学习⟶</a>
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  1186859107@qq.com
  
    
      
        · <a href="https://github.com/Yqzzxlj" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">All rights reserved @Yqzzxlj</span>
</footer>
  </div>
</body>
</html>