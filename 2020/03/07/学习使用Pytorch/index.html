<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>学习使用Pytorch | Yqzzxlj</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="代码来自于这里 解惑torch.manual_seed(1)    # reproducible这句代码的意思是这样的，因为网络的参数是随机初始化的，所以将seed固定可以保证每次的结果固定 x &#x3D; torch.unsqueeze(torch.linspace(-1, 1, 100), dim&#x3D;1)  # x data (tensor), shape&#x3D;(100, 1)这句代码是说，要从-1 到1">
<meta property="og:type" content="article">
<meta property="og:title" content="学习使用Pytorch">
<meta property="og:url" content="http://yoursite.com/2020/03/07/%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8Pytorch/index.html">
<meta property="og:site_name" content="Yqzzxlj">
<meta property="og:description" content="代码来自于这里 解惑torch.manual_seed(1)    # reproducible这句代码的意思是这样的，因为网络的参数是随机初始化的，所以将seed固定可以保证每次的结果固定 x &#x3D; torch.unsqueeze(torch.linspace(-1, 1, 100), dim&#x3D;1)  # x data (tensor), shape&#x3D;(100, 1)这句代码是说，要从-1 到1">
<meta property="og:locale" content="zh">
<meta property="article:published_time" content="2020-03-07T12:08:15.000Z">
<meta property="article:modified_time" content="2020-03-19T14:05:00.428Z">
<meta property="article:author" content="Yqzzxlj">
<meta name="twitter:card" content="summary">
  
  <link rel="stylesheet" href="//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css">
  <script src="//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js"></script>
  <script>
    document.addEventListener('DOMContentLoaded', (event) => {
      document.querySelectorAll('pre code').forEach((block) => {
        hljs.highlightBlock(block);
      });
    });
  </script>
  
<link rel="stylesheet" href="/css/index.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body style="


  background-color: #eff0f6

">
  <div id="container">
    <nav id="nav">
  <header class="header">
    <a href="/" class="title">Yqzzxlj</a>
  </header>
  <div class="ctnWrap">
    <div class="icons">
      
        
          
            <a href="https://github.com/Yqzzxlj" target="_blank" class="nav-icn iconfont icon-github"></a>
          
        
      
    </div>
    <div class="menu">
      
        
            <a href="/" class="nav-menu ">HOME</a>
          
        
            <a href="/archives" class="nav-menu ">ARCHIVE</a>
          
        
            <a href="/categories" class="nav-menu ">CATEGORY</a>
          
        
      
    </div>
  </div>
</nav>
    <div id="main"><section class="article">
  <h2 class="title">学习使用Pytorch</h2>
  <p class="sub">Mar 7, 2020</p>
  <article class="content">
    <p>代码来自于<a href="https://github.com/MorvanZhou/PyTorch-Tutorial/tree/master/tutorial-contents" target="_blank" rel="noopener">这里</a></p>
<h2 id="解惑"><a href="#解惑" class="headerlink" title="解惑"></a>解惑</h2><p><code>torch.manual_seed(1)    # reproducible</code><br>这句代码的意思是这样的，因为网络的参数是随机初始化的，所以将seed固定可以保证每次的结果固定</p>
<p><code>x = torch.unsqueeze(torch.linspace(-1, 1, 100), dim=1)  # x data (tensor), shape=(100, 1)</code><br>这句代码是说，要从-1 到1 的区间内取100个点（此时是一维），然后用unsqueeze函数升一维，至于在哪里升就要看那个dim参数的设定了，具体的看可以看<a href="https://blog.csdn.net/flysky_jay/article/details/81607289" target="_blank" rel="noopener">这个博客</a></p>
<pre><code class="python">loss_func = torch.nn.MSELoss()  # this is for regression mean squared loss
loss_func = torch.nn.CrossEntropyLoss()  # the target label is NOT an one-hotted</code></pre>
<p>这两个损失函数是常用的，第一个是均方差损失，常用于回归；第二个是交叉熵损失，常用于分类。简单清楚的描述可以看<a href="https://zhuanlan.zhihu.com/p/35709485" target="_blank" rel="noopener">知乎大佬</a></p>
<pre><code class="python">n_data = torch.ones(100, 2)
x0 = torch.normal(2*n_data, 1)      # class0 x data (tensor), shape=(100, 2)</code></pre>
<p>normal()函数第一个是你输入的数据，第二个是std标准差(不一定是一个数，也可以是和输入数据对应的tensor).</p>
<p><code>prediction = torch.max(out, 1)[1]</code><br>max()第一个参数是输入的数据，第二个是维度。函数返回两个tensor，第一个是value，第二个是index，此处用index来表示类别</p>
<pre><code class="python">for t in range(200):
    prediction = net(x)     # input x and predict based on x

    loss = loss_func(prediction, y)     # must be (1. nn output, 2. target)

    optimizer.zero_grad()   # clear gradients for next train
    loss.backward()         # backpropagation, compute gradients
    optimizer.step()        # apply gradients</code></pre>
<p>这里注意注释</p>
<p>one-hotted 就是[0, 1, 0]这种只有1和0的,表示数据的所处的状态。</p>
<h2 id="回归"><a href="#回归" class="headerlink" title="回归"></a>回归</h2><pre><code class="python">import torch
import torch.nn.functional as F
import matplotlib.pyplot as plt


x = torch.unsqueeze(torch.linspace(-1, 1, 100), dim=1)  # x data (tensor), shape=(100, 1)
y = x.pow(2) + 0.2*torch.rand(x.size())                 # noisy y data (tensor), shape=(100, 1)


class Net(torch.nn.Module):
    def __init__(self, n_feature, n_hidden, n_output):
        super(Net, self).__init__()
        self.hidden = torch.nn.Linear(n_feature, n_hidden)   # hidden layer
        self.predict = torch.nn.Linear(n_hidden, n_output)   # output layer

    def forward(self, x):
        x = F.relu(self.hidden(x))      # activation function for hidden layer
        x = self.predict(x)             # linear output
        return x

net = Net(n_feature=1, n_hidden=10, n_output=1)     # define the network
print(net)  # net architecture

optimizer = torch.optim.SGD(net.parameters(), lr=0.2)
loss_func = torch.nn.MSELoss()  # this is for regression mean squared loss

plt.ion()   # something about plotting

for t in range(200):
    prediction = net(x)     # input x and predict based on x

    loss = loss_func(prediction, y)     # must be (1. nn output, 2. target)

    optimizer.zero_grad()   # clear gradients for next train
    loss.backward()         # backpropagation, compute gradients
    optimizer.step()        # apply gradients

    if t % 5 == 0:
        # plot and show learning process
        plt.cla()
        plt.scatter(x.data.numpy(), y.data.numpy())
        plt.plot(x.data.numpy(), prediction.data.numpy(), &#39;r-&#39;, lw=5)
        plt.text(0.5, 0, &#39;Loss=%.4f&#39; % loss.data.numpy(), fontdict={&#39;size&#39;: 20, &#39;color&#39;:  &#39;red&#39;})
        plt.pause(0.1)

plt.ioff()
plt.show()</code></pre>
<p>好了，到这里已经看到了一个简单的回归网络</p>
<h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><pre><code class="python">import torch
import torch.nn.functional as F
import matplotlib.pyplot as plt

# torch.manual_seed(1)    # reproducible

# make fake data
n_data = torch.ones(100, 2)
x0 = torch.normal(2*n_data, 1)      # class0 x data (tensor), shape=(100, 2)
y0 = torch.zeros(100)               # class0 y data (tensor), shape=(100, 1)
x1 = torch.normal(-2*n_data, 1)     # class1 x data (tensor), shape=(100, 2)
y1 = torch.ones(100)                # class1 y data (tensor), shape=(100, 1)
x = torch.cat((x0, x1), 0).type(torch.FloatTensor)  # shape (200, 2) FloatTensor = 32-bit floating
y = torch.cat((y0, y1), ).type(torch.LongTensor)    # shape (200,) LongTensor = 64-bit integer


class Net(torch.nn.Module):
    def __init__(self, n_feature, n_hidden, n_output):
        super(Net, self).__init__()
        self.hidden = torch.nn.Linear(n_feature, n_hidden)   # hidden layer
        self.out = torch.nn.Linear(n_hidden, n_output)   # output layer

    def forward(self, x):
        x = F.relu(self.hidden(x))      # activation function for hidden layer
        x = self.out(x)
        return x

net = Net(n_feature=2, n_hidden=10, n_output=2)     # define the network
print(net)  # net architecture

optimizer = torch.optim.SGD(net.parameters(), lr=0.02)
loss_func = torch.nn.CrossEntropyLoss()  # the target label is NOT an one-hotted

plt.ion()   # something about plotting

for t in range(100):
    out = net(x)                 # input x and predict based on x
    loss = loss_func(out, y)     # must be (1. nn output, 2. target), the target label is NOT one-hotted

    optimizer.zero_grad()   # clear gradients for next train
    loss.backward()         # backpropagation, compute gradients
    optimizer.step()        # apply gradients

    if t % 2 == 0:
        # plot and show learning process
        plt.cla()
        prediction = torch.max(out, 1)[1]
        pred_y = prediction.data.numpy()
        target_y = y.data.numpy()
        plt.scatter(x.data.numpy()[:, 0], x.data.numpy()[:, 1], c=pred_y, s=100, lw=0, cmap=&#39;RdYlGn&#39;)
        accuracy = float((pred_y == target_y).astype(int).sum()) / float(target_y.size)
        plt.text(1.5, -4, &#39;Accuracy=%.2f&#39; % accuracy, fontdict={&#39;size&#39;: 20, &#39;color&#39;:  &#39;red&#39;})
        plt.pause(0.1)

plt.ioff()
plt.show()</code></pre>
<p>好了，到这里我们也见过了简单的分类网络。</p>
<h2 id="快速搭建网络"><a href="#快速搭建网络" class="headerlink" title="快速搭建网络"></a>快速搭建网络</h2><p>除了上面的像这样的搭建方法</p>
<pre><code class="python">class Net(torch.nn.Module):
    def __init__(self, n_feature, n_hidden, n_output):
        super(Net, self).__init__()
        self.hidden = torch.nn.Linear(n_feature, n_hidden)   # hidden layer
        self.predict = torch.nn.Linear(n_hidden, n_output)   # output layer

    def forward(self, x):
        x = F.relu(self.hidden(x))      # activation function for hidden layer
        x = self.predict(x)             # linear output
        return x

net1 = Net(1, 10, 1)</code></pre>
<p>还可以像这样</p>
<pre><code class="python">net2 = torch.nn.Sequential(
    torch.nn.Linear(1, 10),
    torch.nn.ReLU(),
    torch.nn.Linear(10, 1)
)</code></pre>
<h2 id="保存提取"><a href="#保存提取" class="headerlink" title="保存提取"></a>保存提取</h2><p>这里有两种保存方式，一种是保存网络， 一种是只保存参数</p>
<pre><code class="python">import torch
import matplotlib.pyplot as plt

# fake data
x = torch.unsqueeze(torch.linspace(-1, 1, 100), dim=1)  # x data (tensor), shape=(100, 1)
y = x.pow(2) + 0.2*torch.rand(x.size())  # noisy y data (tensor), shape=(100, 1)

def save():
    # save net1
    net1 = torch.nn.Sequential(
        torch.nn.Linear(1, 10),
        torch.nn.ReLU(),
        torch.nn.Linear(10, 1)
    )
    optimizer = torch.optim.SGD(net1.parameters(), lr=0.5)
    loss_func = torch.nn.MSELoss()

    for t in range(100):
        prediction = net1(x)
        loss = loss_func(prediction, y)
        optimizer.zero_grad()
        loss.backward()
        optimizer.step()

    # plot result
    plt.figure(1, figsize=(10, 3))
    plt.subplot(131)
    plt.title(&#39;Net1&#39;)
    plt.scatter(x.data.numpy(), y.data.numpy())
    plt.plot(x.data.numpy(), prediction.data.numpy(), &#39;r-&#39;, lw=5)

    # 2 ways to save the net
    torch.save(net1, &#39;net.pkl&#39;)  # save entire net
    torch.save(net1.state_dict(), &#39;net_params.pkl&#39;)   # save only the parameters


def restore_net():
    # restore entire net1 to net2
    net2 = torch.load(&#39;net.pkl&#39;)
    prediction = net2(x)

    # plot result
    plt.subplot(132)
    plt.title(&#39;Net2&#39;)
    plt.scatter(x.data.numpy(), y.data.numpy())
    plt.plot(x.data.numpy(), prediction.data.numpy(), &#39;r-&#39;, lw=5)


def restore_params():
    # restore only the parameters in net1 to net3
    net3 = torch.nn.Sequential(
        torch.nn.Linear(1, 10),
        torch.nn.ReLU(),
        torch.nn.Linear(10, 1)
    )

    # copy net1&#39;s parameters into net3
    net3.load_state_dict(torch.load(&#39;net_params.pkl&#39;))
    prediction = net3(x)

    # plot result
    plt.subplot(133)
    plt.title(&#39;Net3&#39;)
    plt.scatter(x.data.numpy(), y.data.numpy())
    plt.plot(x.data.numpy(), prediction.data.numpy(), &#39;r-&#39;, lw=5)
    plt.show()

# save net1
save()

# restore entire net (may slow)
restore_net()

# restore only the net parameters
restore_params()</code></pre>
<h2 id="批训练"><a href="#批训练" class="headerlink" title="批训练"></a>批训练</h2><p>数据量很大时我们需要分批次进行训练</p>
<pre><code class="python">import torch
import torch.utils.data as Data

torch.manual_seed(1)    # reproducible

BATCH_SIZE = 5
# BATCH_SIZE = 8

x = torch.linspace(1, 10, 10)       # this is x data (torch tensor)
y = torch.linspace(10, 1, 10)       # this is y data (torch tensor)

torch_dataset = Data.TensorDataset(x, y)
loader = Data.DataLoader(
    dataset=torch_dataset,      # torch TensorDataset format
    batch_size=BATCH_SIZE,      # mini batch size
    shuffle=True,               # random shuffle for training
    num_workers=2,              # subprocesses for loading data
)


def show_batch():
    for epoch in range(3):   # train entire dataset 3 times
        for step, (batch_x, batch_y) in enumerate(loader):  # for each training step
            # train your data...
            print(&#39;Epoch: &#39;, epoch, &#39;| Step: &#39;, step, &#39;| batch x: &#39;,
                  batch_x.numpy(), &#39;| batch y: &#39;, batch_y.numpy())


if __name__ == &#39;__main__&#39;:
    show_batch()</code></pre>
<h2 id="优化器"><a href="#优化器" class="headerlink" title="优化器"></a>优化器</h2><p>SGD只是一个很简单的方法（相对于大佬）， 处理数据时会有点慢，所以要学习叼的方法</p>
<pre><code class="python">import torch
import torch.utils.data as Data
import torch.nn.functional as F
import matplotlib.pyplot as plt

# torch.manual_seed(1)    # reproducible

LR = 0.01
BATCH_SIZE = 32
EPOCH = 12

# fake dataset
x = torch.unsqueeze(torch.linspace(-1, 1, 1000), dim=1)
y = x.pow(2) + 0.1*torch.normal(torch.zeros(*x.size()))

# plot dataset
plt.scatter(x.numpy(), y.numpy())
plt.show()

# put dateset into torch dataset
torch_dataset = Data.TensorDataset(x, y)
loader = Data.DataLoader(dataset=torch_dataset, batch_size=BATCH_SIZE, shuffle=True, num_workers=2,)


# default network
class Net(torch.nn.Module):
    def __init__(self):
        super(Net, self).__init__()
        self.hidden = torch.nn.Linear(1, 20)   # hidden layer
        self.predict = torch.nn.Linear(20, 1)   # output layer

    def forward(self, x):
        x = F.relu(self.hidden(x))      # activation function for hidden layer
        x = self.predict(x)             # linear output
        return x

if __name__ == &#39;__main__&#39;:
    # different nets
    net_SGD         = Net()
    net_Momentum    = Net()
    net_RMSprop     = Net()
    net_Adam        = Net()
    nets = [net_SGD, net_Momentum, net_RMSprop, net_Adam]

    # different optimizers
    opt_SGD         = torch.optim.SGD(net_SGD.parameters(), lr=LR)
    opt_Momentum    = torch.optim.SGD(net_Momentum.parameters(), lr=LR, momentum=0.8)
    opt_RMSprop     = torch.optim.RMSprop(net_RMSprop.parameters(), lr=LR, alpha=0.9)
    opt_Adam        = torch.optim.Adam(net_Adam.parameters(), lr=LR, betas=(0.9, 0.99))
    optimizers = [opt_SGD, opt_Momentum, opt_RMSprop, opt_Adam]

    loss_func = torch.nn.MSELoss()
    losses_his = [[], [], [], []]   # record loss

    # training
    for epoch in range(EPOCH):
        print(&#39;Epoch: &#39;, epoch)
        for step, (b_x, b_y) in enumerate(loader):          # for each training step
            for net, opt, l_his in zip(nets, optimizers, losses_his):
                output = net(b_x)              # get output for every net
                loss = loss_func(output, b_y)  # compute loss for every net
                opt.zero_grad()                # clear gradients for next train
                loss.backward()                # backpropagation, compute gradients
                opt.step()                     # apply gradients
                l_his.append(loss.data.numpy())     # loss recoder

    labels = [&#39;SGD&#39;, &#39;Momentum&#39;, &#39;RMSprop&#39;, &#39;Adam&#39;]
    for i, l_his in enumerate(losses_his):
        plt.plot(l_his, label=labels[i])
    plt.legend(loc=&#39;best&#39;)
    plt.xlabel(&#39;Steps&#39;)
    plt.ylabel(&#39;Loss&#39;)
    plt.ylim((0, 0.2))
    plt.show()
    ```

    好了，到这里你已经学习了使用Pytorch的基本方法流程了。</code></pre>

  </article>
  <footer class="f-cf">
    
      <a href="/2020/03/08/CNN,RNN%E7%BD%91%E7%BB%9C%E6%90%AD%E5%BB%BA%E5%AD%A6%E4%B9%A0/" class="link f-fl">⟵CNN,RNN网络搭建学习</a>
    
    
      <a href="/2020/03/06/Hello-Pytorch/" class="link f-fr">Hello Pytorch⟶</a>
    
  </footer>
</section></div>
    <footer id="footer" class="f-cf">
  1186859107@qq.com
  
    
      
        · <a href="https://github.com/Yqzzxlj" target="_blank" class="nav-icn">GitHub</a>
      
    
  
  <span class="copyright">All rights reserved @Yqzzxlj</span>
</footer>
  </div>
</body>
</html>